
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  createdAt: Date
  loginId: string
  loginPw: string | null
  username: string
  loginType: LoginType
  userType: UserType
  nickname: string
  email: string
  isDisable: boolean
}

/**
 * Model Notice
 * 
 */
export type Notice = {
  id: number
  createdAt: Date
  title: string
  content: string | null
  link: string | null
  userId: number
}

/**
 * Model Board
 * 
 */
export type Board = {
  id: number
  createdAt: Date
  title: string
  content: string | null
  link: string | null
  startDay: Date
  endDay: Date | null
  isDisable: boolean
  isReplyAvaliable: boolean
  userId: number
  boardType: BoardType
}

/**
 * Model BoardImage
 * 
 */
export type BoardImage = {
  id: number
  createdAt: Date
  url: string
  thumbnailUrl: string
  width: number
  height: number
  size: number
  isThumb: boolean
  isDisable: boolean
  boardId: number
}

/**
 * Model BoardReply
 * 
 */
export type BoardReply = {
  id: number
  createdAt: Date
  updatedAt: Date | null
  content: string
  isDisable: boolean
  userId: number
  boardId: number
  boardReplyId: number | null
}

/**
 * Model CafeBoard
 * 
 */
export type CafeBoard = {
  boardId: number
  cafeInfoId: number
  createdAt: Date
}

/**
 * Model RegionCategory
 * 
 */
export type RegionCategory = {
  id: number
  createdAt: Date
  name: string
  isDisable: boolean
  govermentType: GovermentType
}

/**
 * Model ClosureRegionCategory
 * 
 */
export type ClosureRegionCategory = {
  ancestor: number
  descendant: number
  depth: number
}

/**
 * Model CafeInfo
 * 
 */
export type CafeInfo = {
  id: number
  createdAt: Date
  isDisable: boolean
  name: string
  code: string | null
  regionCategoryId: number
  address: string
  directions: string
  businessNumber: string
  ceoName: string
}

/**
 * Model CafeThumbnailImage
 * 
 */
export type CafeThumbnailImage = {
  id: number
  createdAt: Date
  url: string
  thumbnailUrl: string
  width: number
  height: number
  size: number
  priority: number
  isDisable: boolean
  cafeInfoId: number
}

/**
 * Model CafeVirtualImage
 * 
 */
export type CafeVirtualImage = {
  id: number
  createdAt: Date
  url: string
  width: number
  height: number
  size: number
  priority: number
  isDisable: boolean
  cafeInfoId: number
}

/**
 * Model CafeRealImage
 * 
 */
export type CafeRealImage = {
  id: number
  createdAt: Date
  url: string
  width: number
  height: number
  size: number
  priority: number
  isDisable: boolean
  cafeInfoId: number
}

/**
 * Model CafeVirtualLink
 * 
 */
export type CafeVirtualLink = {
  id: number
  createdAt: Date
  name: string
  url: string
  type: string
  isDisable: boolean
  isAvaliable: boolean
  cafeInfoId: number
}

/**
 * Model CafeVirtualLinkThumbnailImage
 * 
 */
export type CafeVirtualLinkThumbnailImage = {
  id: number
  createdAt: Date
  url: string
  width: number
  height: number
  size: number
  cafeVirtualLinkId: number
}

/**
 * Model CafeCouponGroup
 * 
 */
export type CafeCouponGroup = {
  id: number
  createdAt: Date
  code: string
  name: string
  tag: string
  description: string
  isDisable: boolean
  startDay: Date
  endDay: Date
  issuanceStartDay: Date
  issuanceEndDay: Date
}

/**
 * Model CafeCouponGoupPartner
 * 
 */
export type CafeCouponGoupPartner = {
  cafeCouponGroupId: number
  cafeInfoId: number
}

/**
 * Model ProxyUser
 * 
 */
export type ProxyUser = {
  id: number
  memberId: string
  createdAt: Date
  proxyUserType: ProxyUserType
  name: string
  token: string
  userId: number | null
}

/**
 * Model CafeCoupon
 * 
 */
export type CafeCoupon = {
  id: number
  createdAt: Date
  name: string
  content: string
  serialNumber: string
  startDay: Date
  endDay: Date | null
  isDisable: boolean
  proxyUserId: number
  cafeCouponGroupId: number
}

/**
 * Model CafeCouponHistory
 * 
 */
export type CafeCouponHistory = {
  id: number
  createdAt: Date
  cafeCouponId: number
  eventType: CafeCouponEventType
  description: string
  actorId: number
  statusBefore: CafeCouponStatus | null
  statusAfter: CafeCouponStatus | null
}

/**
 * Model CafeCouponQRCode
 * 
 */
export type CafeCouponQRCode = {
  serialNumber: string
  createdAt: Date
  isDisable: boolean
  cafeCouponId: number | null
  size: number
  base64Data: string
}

/**
 * Model MetaViewerInfo
 * 
 */
export type MetaViewerInfo = {
  id: number
  createdAt: Date
  code: string
  isDisable: boolean
  worldData: Prisma.JsonValue
  cafeInfoId: number
}

/**
 * Model MetaViewerMap
 * 
 */
export type MetaViewerMap = {
  id: number
  createdAt: Date
  type: MetaMapType
  version: number
  url: string
  size: number
  contentKey: string | null
  isDraco: boolean
  metaViewerInfoId: number
}

/**
 * Model MetaViewerActiveMap
 * 
 */
export type MetaViewerActiveMap = {
  id: number
  updatedAt: Date
  metaViewerInfoId: number
  activeRenderMapId: number
  activeColliderMapId: number
}

/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = {
  id: number
  createdAt: Date
  name: string
  description: string | null
  isDisable: boolean
  code: string
}

/**
 * Model ClosureProductCategory
 * 
 */
export type ClosureProductCategory = {
  ancestor: number
  descendant: number
  depth: number
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: number
  createdAt: Date
  updatedAt: Date
  name: string
  code: string
  description: string | null
  price: number
  originalPrice: number | null
  stockQuantity: number
  minOrderQuantity: number
  isDisable: boolean
  isAvailable: boolean
  categoryId: number
  cafeInfoId: number | null
  productRedirectUrl: string | null
  isSignature: boolean
}

/**
 * Model WishlistProduct
 * 
 */
export type WishlistProduct = {
  id: number
  createdAt: Date
  productId: number
  proxyUserId: number
}

/**
 * Model ProductImage
 * 
 */
export type ProductImage = {
  id: number
  createdAt: Date
  url: string
  thumbnailUrl: string
  width: number
  height: number
  size: number
  isDisable: boolean
  isThumb: boolean
  productId: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const BoardType: {
  BTALK: 'BTALK',
  BINFORM: 'BINFORM',
  BQUESTION: 'BQUESTION',
  BEVENT: 'BEVENT'
};

export type BoardType = (typeof BoardType)[keyof typeof BoardType]


export const CafeCouponEventType: {
  CREATED: 'CREATED',
  USED: 'USED',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED',
  UPDATE: 'UPDATE'
};

export type CafeCouponEventType = (typeof CafeCouponEventType)[keyof typeof CafeCouponEventType]


export const CafeCouponStatus: {
  ACTIVE: 'ACTIVE',
  USED: 'USED',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED'
};

export type CafeCouponStatus = (typeof CafeCouponStatus)[keyof typeof CafeCouponStatus]


export const GovermentType: {
  SPECIAL_CITY: 'SPECIAL_CITY',
  METROPOLITAN_CITY: 'METROPOLITAN_CITY',
  SPECIAL_SELF_GOVERNING_CITY: 'SPECIAL_SELF_GOVERNING_CITY',
  PROVINCE: 'PROVINCE',
  SPECIAL_SELF_GOVERNING_PROVINCE: 'SPECIAL_SELF_GOVERNING_PROVINCE',
  DISTRICT: 'DISTRICT',
  CITY: 'CITY',
  COUNTY: 'COUNTY',
  TOWN: 'TOWN',
  TOWNSHIP: 'TOWNSHIP',
  NEIGHBORHOOD: 'NEIGHBORHOOD',
  PLACENAME: 'PLACENAME'
};

export type GovermentType = (typeof GovermentType)[keyof typeof GovermentType]


export const LoginType: {
  LOCAL: 'LOCAL',
  ADMIN: 'ADMIN',
  KAKAO: 'KAKAO',
  NAVER: 'NAVER',
  GOOGLE: 'GOOGLE',
  APPLE: 'APPLE',
  ZEPETO: 'ZEPETO'
};

export type LoginType = (typeof LoginType)[keyof typeof LoginType]


export const MetaMapType: {
  RENDER: 'RENDER',
  COLLIDER: 'COLLIDER'
};

export type MetaMapType = (typeof MetaMapType)[keyof typeof MetaMapType]


export const ProxyUserType: {
  ETC: 'ETC',
  WEB: 'WEB',
  ZEPETO: 'ZEPETO',
  WEV_VIEWER: 'WEV_VIEWER'
};

export type ProxyUserType = (typeof ProxyUserType)[keyof typeof ProxyUserType]


export const UserType: {
  GENERAL: 'GENERAL',
  BUSINESS: 'BUSINESS',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<GlobalReject>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<GlobalReject>;

  /**
   * `prisma.boardImage`: Exposes CRUD operations for the **BoardImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardImages
    * const boardImages = await prisma.boardImage.findMany()
    * ```
    */
  get boardImage(): Prisma.BoardImageDelegate<GlobalReject>;

  /**
   * `prisma.boardReply`: Exposes CRUD operations for the **BoardReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardReplies
    * const boardReplies = await prisma.boardReply.findMany()
    * ```
    */
  get boardReply(): Prisma.BoardReplyDelegate<GlobalReject>;

  /**
   * `prisma.cafeBoard`: Exposes CRUD operations for the **CafeBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeBoards
    * const cafeBoards = await prisma.cafeBoard.findMany()
    * ```
    */
  get cafeBoard(): Prisma.CafeBoardDelegate<GlobalReject>;

  /**
   * `prisma.regionCategory`: Exposes CRUD operations for the **RegionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionCategories
    * const regionCategories = await prisma.regionCategory.findMany()
    * ```
    */
  get regionCategory(): Prisma.RegionCategoryDelegate<GlobalReject>;

  /**
   * `prisma.closureRegionCategory`: Exposes CRUD operations for the **ClosureRegionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClosureRegionCategories
    * const closureRegionCategories = await prisma.closureRegionCategory.findMany()
    * ```
    */
  get closureRegionCategory(): Prisma.ClosureRegionCategoryDelegate<GlobalReject>;

  /**
   * `prisma.cafeInfo`: Exposes CRUD operations for the **CafeInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeInfos
    * const cafeInfos = await prisma.cafeInfo.findMany()
    * ```
    */
  get cafeInfo(): Prisma.CafeInfoDelegate<GlobalReject>;

  /**
   * `prisma.cafeThumbnailImage`: Exposes CRUD operations for the **CafeThumbnailImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeThumbnailImages
    * const cafeThumbnailImages = await prisma.cafeThumbnailImage.findMany()
    * ```
    */
  get cafeThumbnailImage(): Prisma.CafeThumbnailImageDelegate<GlobalReject>;

  /**
   * `prisma.cafeVirtualImage`: Exposes CRUD operations for the **CafeVirtualImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeVirtualImages
    * const cafeVirtualImages = await prisma.cafeVirtualImage.findMany()
    * ```
    */
  get cafeVirtualImage(): Prisma.CafeVirtualImageDelegate<GlobalReject>;

  /**
   * `prisma.cafeRealImage`: Exposes CRUD operations for the **CafeRealImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeRealImages
    * const cafeRealImages = await prisma.cafeRealImage.findMany()
    * ```
    */
  get cafeRealImage(): Prisma.CafeRealImageDelegate<GlobalReject>;

  /**
   * `prisma.cafeVirtualLink`: Exposes CRUD operations for the **CafeVirtualLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeVirtualLinks
    * const cafeVirtualLinks = await prisma.cafeVirtualLink.findMany()
    * ```
    */
  get cafeVirtualLink(): Prisma.CafeVirtualLinkDelegate<GlobalReject>;

  /**
   * `prisma.cafeVirtualLinkThumbnailImage`: Exposes CRUD operations for the **CafeVirtualLinkThumbnailImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeVirtualLinkThumbnailImages
    * const cafeVirtualLinkThumbnailImages = await prisma.cafeVirtualLinkThumbnailImage.findMany()
    * ```
    */
  get cafeVirtualLinkThumbnailImage(): Prisma.CafeVirtualLinkThumbnailImageDelegate<GlobalReject>;

  /**
   * `prisma.cafeCouponGroup`: Exposes CRUD operations for the **CafeCouponGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponGroups
    * const cafeCouponGroups = await prisma.cafeCouponGroup.findMany()
    * ```
    */
  get cafeCouponGroup(): Prisma.CafeCouponGroupDelegate<GlobalReject>;

  /**
   * `prisma.cafeCouponGoupPartner`: Exposes CRUD operations for the **CafeCouponGoupPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponGoupPartners
    * const cafeCouponGoupPartners = await prisma.cafeCouponGoupPartner.findMany()
    * ```
    */
  get cafeCouponGoupPartner(): Prisma.CafeCouponGoupPartnerDelegate<GlobalReject>;

  /**
   * `prisma.proxyUser`: Exposes CRUD operations for the **ProxyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxyUsers
    * const proxyUsers = await prisma.proxyUser.findMany()
    * ```
    */
  get proxyUser(): Prisma.ProxyUserDelegate<GlobalReject>;

  /**
   * `prisma.cafeCoupon`: Exposes CRUD operations for the **CafeCoupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCoupons
    * const cafeCoupons = await prisma.cafeCoupon.findMany()
    * ```
    */
  get cafeCoupon(): Prisma.CafeCouponDelegate<GlobalReject>;

  /**
   * `prisma.cafeCouponHistory`: Exposes CRUD operations for the **CafeCouponHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponHistories
    * const cafeCouponHistories = await prisma.cafeCouponHistory.findMany()
    * ```
    */
  get cafeCouponHistory(): Prisma.CafeCouponHistoryDelegate<GlobalReject>;

  /**
   * `prisma.cafeCouponQRCode`: Exposes CRUD operations for the **CafeCouponQRCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponQRCodes
    * const cafeCouponQRCodes = await prisma.cafeCouponQRCode.findMany()
    * ```
    */
  get cafeCouponQRCode(): Prisma.CafeCouponQRCodeDelegate<GlobalReject>;

  /**
   * `prisma.metaViewerInfo`: Exposes CRUD operations for the **MetaViewerInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaViewerInfos
    * const metaViewerInfos = await prisma.metaViewerInfo.findMany()
    * ```
    */
  get metaViewerInfo(): Prisma.MetaViewerInfoDelegate<GlobalReject>;

  /**
   * `prisma.metaViewerMap`: Exposes CRUD operations for the **MetaViewerMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaViewerMaps
    * const metaViewerMaps = await prisma.metaViewerMap.findMany()
    * ```
    */
  get metaViewerMap(): Prisma.MetaViewerMapDelegate<GlobalReject>;

  /**
   * `prisma.metaViewerActiveMap`: Exposes CRUD operations for the **MetaViewerActiveMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaViewerActiveMaps
    * const metaViewerActiveMaps = await prisma.metaViewerActiveMap.findMany()
    * ```
    */
  get metaViewerActiveMap(): Prisma.MetaViewerActiveMapDelegate<GlobalReject>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<GlobalReject>;

  /**
   * `prisma.closureProductCategory`: Exposes CRUD operations for the **ClosureProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClosureProductCategories
    * const closureProductCategories = await prisma.closureProductCategory.findMany()
    * ```
    */
  get closureProductCategory(): Prisma.ClosureProductCategoryDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.wishlistProduct`: Exposes CRUD operations for the **WishlistProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistProducts
    * const wishlistProducts = await prisma.wishlistProduct.findMany()
    * ```
    */
  get wishlistProduct(): Prisma.WishlistProductDelegate<GlobalReject>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.0
   * Query Engine version: 39190b250ebc338586e25e6da45e5e783bc8a635
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Notice: 'Notice',
    Board: 'Board',
    BoardImage: 'BoardImage',
    BoardReply: 'BoardReply',
    CafeBoard: 'CafeBoard',
    RegionCategory: 'RegionCategory',
    ClosureRegionCategory: 'ClosureRegionCategory',
    CafeInfo: 'CafeInfo',
    CafeThumbnailImage: 'CafeThumbnailImage',
    CafeVirtualImage: 'CafeVirtualImage',
    CafeRealImage: 'CafeRealImage',
    CafeVirtualLink: 'CafeVirtualLink',
    CafeVirtualLinkThumbnailImage: 'CafeVirtualLinkThumbnailImage',
    CafeCouponGroup: 'CafeCouponGroup',
    CafeCouponGoupPartner: 'CafeCouponGoupPartner',
    ProxyUser: 'ProxyUser',
    CafeCoupon: 'CafeCoupon',
    CafeCouponHistory: 'CafeCouponHistory',
    CafeCouponQRCode: 'CafeCouponQRCode',
    MetaViewerInfo: 'MetaViewerInfo',
    MetaViewerMap: 'MetaViewerMap',
    MetaViewerActiveMap: 'MetaViewerActiveMap',
    ProductCategory: 'ProductCategory',
    ClosureProductCategory: 'ClosureProductCategory',
    Product: 'Product',
    WishlistProduct: 'WishlistProduct',
    ProductImage: 'ProductImage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Boards: number
    BoardReplies: number
    Notices: number
    ProxyUsers: number
    CafeCouponHistories: number
  }

  export type UserCountOutputTypeSelect = {
    Boards?: boolean
    BoardReplies?: boolean
    Notices?: boolean
    ProxyUsers?: boolean
    CafeCouponHistories?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type BoardCountOutputType
   */


  export type BoardCountOutputType = {
    BoardImages: number
    BoardReplies: number
    CafeBoards: number
  }

  export type BoardCountOutputTypeSelect = {
    BoardImages?: boolean
    BoardReplies?: boolean
    CafeBoards?: boolean
  }

  export type BoardCountOutputTypeGetPayload<S extends boolean | null | undefined | BoardCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoardCountOutputTypeArgs)
    ? BoardCountOutputType 
    : S extends { select: any } & (BoardCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoardCountOutputType ? BoardCountOutputType[P] : never
  } 
      : BoardCountOutputType




  // Custom InputTypes

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     * 
    **/
    select?: BoardCountOutputTypeSelect | null
  }



  /**
   * Count Type BoardReplyCountOutputType
   */


  export type BoardReplyCountOutputType = {
    BoardNestedReplies: number
  }

  export type BoardReplyCountOutputTypeSelect = {
    BoardNestedReplies?: boolean
  }

  export type BoardReplyCountOutputTypeGetPayload<S extends boolean | null | undefined | BoardReplyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardReplyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoardReplyCountOutputTypeArgs)
    ? BoardReplyCountOutputType 
    : S extends { select: any } & (BoardReplyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoardReplyCountOutputType ? BoardReplyCountOutputType[P] : never
  } 
      : BoardReplyCountOutputType




  // Custom InputTypes

  /**
   * BoardReplyCountOutputType without action
   */
  export type BoardReplyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoardReplyCountOutputType
     * 
    **/
    select?: BoardReplyCountOutputTypeSelect | null
  }



  /**
   * Count Type RegionCategoryCountOutputType
   */


  export type RegionCategoryCountOutputType = {
    CafeInfos: number
    AncestorCategories: number
    DescendantCategories: number
  }

  export type RegionCategoryCountOutputTypeSelect = {
    CafeInfos?: boolean
    AncestorCategories?: boolean
    DescendantCategories?: boolean
  }

  export type RegionCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | RegionCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RegionCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RegionCategoryCountOutputTypeArgs)
    ? RegionCategoryCountOutputType 
    : S extends { select: any } & (RegionCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RegionCategoryCountOutputType ? RegionCategoryCountOutputType[P] : never
  } 
      : RegionCategoryCountOutputType




  // Custom InputTypes

  /**
   * RegionCategoryCountOutputType without action
   */
  export type RegionCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RegionCategoryCountOutputType
     * 
    **/
    select?: RegionCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type CafeInfoCountOutputType
   */


  export type CafeInfoCountOutputType = {
    CafeVirtualLinks: number
    CafeThumbnailImages: number
    CafeVirtualImages: number
    CafeRealImages: number
    CafeCouponGroupPartners: number
    CafeBoards: number
    MetaViewerInfos: number
    Products: number
  }

  export type CafeInfoCountOutputTypeSelect = {
    CafeVirtualLinks?: boolean
    CafeThumbnailImages?: boolean
    CafeVirtualImages?: boolean
    CafeRealImages?: boolean
    CafeCouponGroupPartners?: boolean
    CafeBoards?: boolean
    MetaViewerInfos?: boolean
    Products?: boolean
  }

  export type CafeInfoCountOutputTypeGetPayload<S extends boolean | null | undefined | CafeInfoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeInfoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CafeInfoCountOutputTypeArgs)
    ? CafeInfoCountOutputType 
    : S extends { select: any } & (CafeInfoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CafeInfoCountOutputType ? CafeInfoCountOutputType[P] : never
  } 
      : CafeInfoCountOutputType




  // Custom InputTypes

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CafeInfoCountOutputType
     * 
    **/
    select?: CafeInfoCountOutputTypeSelect | null
  }



  /**
   * Count Type CafeCouponGroupCountOutputType
   */


  export type CafeCouponGroupCountOutputType = {
    CafeCoupons: number
    CafeCouponGoupPartners: number
  }

  export type CafeCouponGroupCountOutputTypeSelect = {
    CafeCoupons?: boolean
    CafeCouponGoupPartners?: boolean
  }

  export type CafeCouponGroupCountOutputTypeGetPayload<S extends boolean | null | undefined | CafeCouponGroupCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCouponGroupCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponGroupCountOutputTypeArgs)
    ? CafeCouponGroupCountOutputType 
    : S extends { select: any } & (CafeCouponGroupCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CafeCouponGroupCountOutputType ? CafeCouponGroupCountOutputType[P] : never
  } 
      : CafeCouponGroupCountOutputType




  // Custom InputTypes

  /**
   * CafeCouponGroupCountOutputType without action
   */
  export type CafeCouponGroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroupCountOutputType
     * 
    **/
    select?: CafeCouponGroupCountOutputTypeSelect | null
  }



  /**
   * Count Type ProxyUserCountOutputType
   */


  export type ProxyUserCountOutputType = {
    CafeCoupons: number
    WishlistProducts: number
  }

  export type ProxyUserCountOutputTypeSelect = {
    CafeCoupons?: boolean
    WishlistProducts?: boolean
  }

  export type ProxyUserCountOutputTypeGetPayload<S extends boolean | null | undefined | ProxyUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProxyUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProxyUserCountOutputTypeArgs)
    ? ProxyUserCountOutputType 
    : S extends { select: any } & (ProxyUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProxyUserCountOutputType ? ProxyUserCountOutputType[P] : never
  } 
      : ProxyUserCountOutputType




  // Custom InputTypes

  /**
   * ProxyUserCountOutputType without action
   */
  export type ProxyUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProxyUserCountOutputType
     * 
    **/
    select?: ProxyUserCountOutputTypeSelect | null
  }



  /**
   * Count Type CafeCouponCountOutputType
   */


  export type CafeCouponCountOutputType = {
    CafeCouponQRCodes: number
    CafeCouponHistories: number
  }

  export type CafeCouponCountOutputTypeSelect = {
    CafeCouponQRCodes?: boolean
    CafeCouponHistories?: boolean
  }

  export type CafeCouponCountOutputTypeGetPayload<S extends boolean | null | undefined | CafeCouponCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCouponCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponCountOutputTypeArgs)
    ? CafeCouponCountOutputType 
    : S extends { select: any } & (CafeCouponCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CafeCouponCountOutputType ? CafeCouponCountOutputType[P] : never
  } 
      : CafeCouponCountOutputType




  // Custom InputTypes

  /**
   * CafeCouponCountOutputType without action
   */
  export type CafeCouponCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponCountOutputType
     * 
    **/
    select?: CafeCouponCountOutputTypeSelect | null
  }



  /**
   * Count Type MetaViewerInfoCountOutputType
   */


  export type MetaViewerInfoCountOutputType = {
    MetaViewerMaps: number
  }

  export type MetaViewerInfoCountOutputTypeSelect = {
    MetaViewerMaps?: boolean
  }

  export type MetaViewerInfoCountOutputTypeGetPayload<S extends boolean | null | undefined | MetaViewerInfoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetaViewerInfoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MetaViewerInfoCountOutputTypeArgs)
    ? MetaViewerInfoCountOutputType 
    : S extends { select: any } & (MetaViewerInfoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MetaViewerInfoCountOutputType ? MetaViewerInfoCountOutputType[P] : never
  } 
      : MetaViewerInfoCountOutputType




  // Custom InputTypes

  /**
   * MetaViewerInfoCountOutputType without action
   */
  export type MetaViewerInfoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfoCountOutputType
     * 
    **/
    select?: MetaViewerInfoCountOutputTypeSelect | null
  }



  /**
   * Count Type MetaViewerMapCountOutputType
   */


  export type MetaViewerMapCountOutputType = {
    ActiveRenderFor: number
    ActiveColliderFor: number
  }

  export type MetaViewerMapCountOutputTypeSelect = {
    ActiveRenderFor?: boolean
    ActiveColliderFor?: boolean
  }

  export type MetaViewerMapCountOutputTypeGetPayload<S extends boolean | null | undefined | MetaViewerMapCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetaViewerMapCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MetaViewerMapCountOutputTypeArgs)
    ? MetaViewerMapCountOutputType 
    : S extends { select: any } & (MetaViewerMapCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MetaViewerMapCountOutputType ? MetaViewerMapCountOutputType[P] : never
  } 
      : MetaViewerMapCountOutputType




  // Custom InputTypes

  /**
   * MetaViewerMapCountOutputType without action
   */
  export type MetaViewerMapCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMapCountOutputType
     * 
    **/
    select?: MetaViewerMapCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCategoryCountOutputType
   */


  export type ProductCategoryCountOutputType = {
    AncestorCategories: number
    DescendantCategories: number
    Products: number
  }

  export type ProductCategoryCountOutputTypeSelect = {
    AncestorCategories?: boolean
    DescendantCategories?: boolean
    Products?: boolean
  }

  export type ProductCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCategoryCountOutputTypeArgs)
    ? ProductCategoryCountOutputType 
    : S extends { select: any } & (ProductCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCategoryCountOutputType ? ProductCategoryCountOutputType[P] : never
  } 
      : ProductCategoryCountOutputType




  // Custom InputTypes

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     * 
    **/
    select?: ProductCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    WishlistProducts: number
    ProductImages: number
  }

  export type ProductCountOutputTypeSelect = {
    WishlistProducts?: boolean
    ProductImages?: boolean
  }

  export type ProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCountOutputTypeArgs)
    ? ProductCountOutputType 
    : S extends { select: any } & (ProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
      : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    loginId: string | null
    loginPw: string | null
    username: string | null
    loginType: LoginType | null
    userType: UserType | null
    nickname: string | null
    email: string | null
    isDisable: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    loginId: string | null
    loginPw: string | null
    username: string | null
    loginType: LoginType | null
    userType: UserType | null
    nickname: string | null
    email: string | null
    isDisable: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    loginId: number
    loginPw: number
    username: number
    loginType: number
    userType: number
    nickname: number
    email: number
    isDisable: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    loginId?: true
    loginPw?: true
    username?: true
    loginType?: true
    userType?: true
    nickname?: true
    email?: true
    isDisable?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    loginId?: true
    loginPw?: true
    username?: true
    loginType?: true
    userType?: true
    nickname?: true
    email?: true
    isDisable?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    loginId?: true
    loginPw?: true
    username?: true
    loginType?: true
    userType?: true
    nickname?: true
    email?: true
    isDisable?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    loginId: string
    loginPw: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    loginId?: boolean
    loginPw?: boolean
    username?: boolean
    loginType?: boolean
    userType?: boolean
    nickname?: boolean
    email?: boolean
    isDisable?: boolean
    Boards?: boolean | BoardFindManyArgs
    BoardReplies?: boolean | BoardReplyFindManyArgs
    Notices?: boolean | NoticeFindManyArgs
    ProxyUsers?: boolean | ProxyUserFindManyArgs
    CafeCouponHistories?: boolean | CafeCouponHistoryFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    Boards?: boolean | BoardFindManyArgs
    BoardReplies?: boolean | BoardReplyFindManyArgs
    Notices?: boolean | NoticeFindManyArgs
    ProxyUsers?: boolean | ProxyUserFindManyArgs
    CafeCouponHistories?: boolean | CafeCouponHistoryFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Boards' ? Array < BoardGetPayload<S['include'][P]>>  :
        P extends 'BoardReplies' ? Array < BoardReplyGetPayload<S['include'][P]>>  :
        P extends 'Notices' ? Array < NoticeGetPayload<S['include'][P]>>  :
        P extends 'ProxyUsers' ? Array < ProxyUserGetPayload<S['include'][P]>>  :
        P extends 'CafeCouponHistories' ? Array < CafeCouponHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Boards' ? Array < BoardGetPayload<S['select'][P]>>  :
        P extends 'BoardReplies' ? Array < BoardReplyGetPayload<S['select'][P]>>  :
        P extends 'Notices' ? Array < NoticeGetPayload<S['select'][P]>>  :
        P extends 'ProxyUsers' ? Array < ProxyUserGetPayload<S['select'][P]>>  :
        P extends 'CafeCouponHistories' ? Array < CafeCouponHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Boards<T extends BoardFindManyArgs= {}>(args?: Subset<T, BoardFindManyArgs>): PrismaPromise<Array<BoardGetPayload<T>>| Null>;

    BoardReplies<T extends BoardReplyFindManyArgs= {}>(args?: Subset<T, BoardReplyFindManyArgs>): PrismaPromise<Array<BoardReplyGetPayload<T>>| Null>;

    Notices<T extends NoticeFindManyArgs= {}>(args?: Subset<T, NoticeFindManyArgs>): PrismaPromise<Array<NoticeGetPayload<T>>| Null>;

    ProxyUsers<T extends ProxyUserFindManyArgs= {}>(args?: Subset<T, ProxyUserFindManyArgs>): PrismaPromise<Array<ProxyUserGetPayload<T>>| Null>;

    CafeCouponHistories<T extends CafeCouponHistoryFindManyArgs= {}>(args?: Subset<T, CafeCouponHistoryFindManyArgs>): PrismaPromise<Array<CafeCouponHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Notice
   */


  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    userId: number | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    userId: number | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    content: number
    link: number
    userId: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    userId?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    userId?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    userId?: true
    _all?: true
  }

  export type NoticeAggregateArgs = {
    /**
     * Filter which Notice to aggregate.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs = {
    where?: NoticeWhereInput
    orderBy?: Enumerable<NoticeOrderByWithAggregationInput>
    by: Array<NoticeScalarFieldEnum>
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }


  export type NoticeGroupByOutputType = {
    id: number
    createdAt: Date
    title: string
    content: string | null
    link: string | null
    userId: number
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    userId?: boolean
    User?: boolean | UserArgs
  }


  export type NoticeInclude = {
    User?: boolean | UserArgs
  } 

  export type NoticeGetPayload<S extends boolean | null | undefined | NoticeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notice :
    S extends undefined ? never :
    S extends { include: any } & (NoticeArgs | NoticeFindManyArgs)
    ? Notice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NoticeArgs | NoticeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :  P extends keyof Notice ? Notice[P] : never
  } 
      : Notice


  type NoticeCountArgs = Merge<
    Omit<NoticeFindManyArgs, 'select' | 'include'> & {
      select?: NoticeCountAggregateInputType | true
    }
  >

  export interface NoticeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoticeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoticeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notice'> extends True ? Prisma__NoticeClient<NoticeGetPayload<T>> : Prisma__NoticeClient<NoticeGetPayload<T> | null, null>

    /**
     * Find one Notice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NoticeFindUniqueOrThrowArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoticeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoticeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notice'> extends True ? Prisma__NoticeClient<NoticeGetPayload<T>> : Prisma__NoticeClient<NoticeGetPayload<T> | null, null>

    /**
     * Find the first Notice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NoticeFindFirstOrThrowArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoticeFindManyArgs>(
      args?: SelectSubset<T, NoticeFindManyArgs>
    ): PrismaPromise<Array<NoticeGetPayload<T>>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
    **/
    create<T extends NoticeCreateArgs>(
      args: SelectSubset<T, NoticeCreateArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Create many Notices.
     *     @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     *     @example
     *     // Create many Notices
     *     const notice = await prisma.notice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoticeCreateManyArgs>(
      args?: SelectSubset<T, NoticeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
    **/
    delete<T extends NoticeDeleteArgs>(
      args: SelectSubset<T, NoticeDeleteArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoticeUpdateArgs>(
      args: SelectSubset<T, NoticeUpdateArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoticeDeleteManyArgs>(
      args?: SelectSubset<T, NoticeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoticeUpdateManyArgs>(
      args: SelectSubset<T, NoticeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
    **/
    upsert<T extends NoticeUpsertArgs>(
      args: SelectSubset<T, NoticeUpsertArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoticeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notice base type for findUnique actions
   */
  export type NoticeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * Filter, which Notice to fetch.
     * 
    **/
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice: findUnique
   */
  export interface NoticeFindUniqueArgs extends NoticeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * Filter, which Notice to fetch.
     * 
    **/
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice base type for findFirst actions
   */
  export type NoticeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * Filter, which Notice to fetch.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     * 
    **/
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }

  /**
   * Notice: findFirst
   */
  export interface NoticeFindFirstArgs extends NoticeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * Filter, which Notice to fetch.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     * 
    **/
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }


  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * Filter, which Notices to fetch.
     * 
    **/
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     * 
    **/
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     * 
    **/
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }


  /**
   * Notice create
   */
  export type NoticeCreateArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * The data needed to create a Notice.
     * 
    **/
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }


  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs = {
    /**
     * The data used to create many Notices.
     * 
    **/
    data: Enumerable<NoticeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notice update
   */
  export type NoticeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * The data needed to update a Notice.
     * 
    **/
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     * 
    **/
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs = {
    /**
     * The data used to update Notices.
     * 
    **/
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     * 
    **/
    where?: NoticeWhereInput
  }


  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * The filter to search for the Notice to update in case it exists.
     * 
    **/
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     * 
    **/
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }


  /**
   * Notice delete
   */
  export type NoticeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
    /**
     * Filter which Notice to delete.
     * 
    **/
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs = {
    /**
     * Filter which Notices to delete
     * 
    **/
    where?: NoticeWhereInput
  }


  /**
   * Notice without action
   */
  export type NoticeArgs = {
    /**
     * Select specific fields to fetch from the Notice
     * 
    **/
    select?: NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NoticeInclude | null
  }



  /**
   * Model Board
   */


  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BoardSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BoardMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    isReplyAvaliable: boolean | null
    userId: number | null
    boardType: BoardType | null
  }

  export type BoardMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    isReplyAvaliable: boolean | null
    userId: number | null
    boardType: BoardType | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    content: number
    link: number
    startDay: number
    endDay: number
    isDisable: number
    isReplyAvaliable: number
    userId: number
    boardType: number
    _all: number
  }


  export type BoardAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BoardSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BoardMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    isReplyAvaliable?: true
    userId?: true
    boardType?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    isReplyAvaliable?: true
    userId?: true
    boardType?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    isReplyAvaliable?: true
    userId?: true
    boardType?: true
    _all?: true
  }

  export type BoardAggregateArgs = {
    /**
     * Filter which Board to aggregate.
     * 
    **/
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs = {
    where?: BoardWhereInput
    orderBy?: Enumerable<BoardOrderByWithAggregationInput>
    by: Array<BoardScalarFieldEnum>
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _avg?: BoardAvgAggregateInputType
    _sum?: BoardSumAggregateInputType
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }


  export type BoardGroupByOutputType = {
    id: number
    createdAt: Date
    title: string
    content: string | null
    link: string | null
    startDay: Date
    endDay: Date | null
    isDisable: boolean
    isReplyAvaliable: boolean
    userId: number
    boardType: BoardType
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: boolean | BoardImageFindManyArgs
    BoardReplies?: boolean | BoardReplyFindManyArgs
    userId?: boolean
    User?: boolean | UserArgs
    boardType?: boolean
    CafeBoards?: boolean | CafeBoardFindManyArgs
    _count?: boolean | BoardCountOutputTypeArgs
  }


  export type BoardInclude = {
    BoardImages?: boolean | BoardImageFindManyArgs
    BoardReplies?: boolean | BoardReplyFindManyArgs
    User?: boolean | UserArgs
    CafeBoards?: boolean | CafeBoardFindManyArgs
    _count?: boolean | BoardCountOutputTypeArgs
  } 

  export type BoardGetPayload<S extends boolean | null | undefined | BoardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Board :
    S extends undefined ? never :
    S extends { include: any } & (BoardArgs | BoardFindManyArgs)
    ? Board  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'BoardImages' ? Array < BoardImageGetPayload<S['include'][P]>>  :
        P extends 'BoardReplies' ? Array < BoardReplyGetPayload<S['include'][P]>>  :
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'CafeBoards' ? Array < CafeBoardGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoardCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardArgs | BoardFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'BoardImages' ? Array < BoardImageGetPayload<S['select'][P]>>  :
        P extends 'BoardReplies' ? Array < BoardReplyGetPayload<S['select'][P]>>  :
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'CafeBoards' ? Array < CafeBoardGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoardCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Board ? Board[P] : never
  } 
      : Board


  type BoardCountArgs = Merge<
    Omit<BoardFindManyArgs, 'select' | 'include'> & {
      select?: BoardCountAggregateInputType | true
    }
  >

  export interface BoardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Board'> extends True ? Prisma__BoardClient<BoardGetPayload<T>> : Prisma__BoardClient<BoardGetPayload<T> | null, null>

    /**
     * Find one Board that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardFindUniqueOrThrowArgs>
    ): Prisma__BoardClient<BoardGetPayload<T>>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Board'> extends True ? Prisma__BoardClient<BoardGetPayload<T>> : Prisma__BoardClient<BoardGetPayload<T> | null, null>

    /**
     * Find the first Board that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardFindFirstOrThrowArgs>
    ): Prisma__BoardClient<BoardGetPayload<T>>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardFindManyArgs>(
      args?: SelectSubset<T, BoardFindManyArgs>
    ): PrismaPromise<Array<BoardGetPayload<T>>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
    **/
    create<T extends BoardCreateArgs>(
      args: SelectSubset<T, BoardCreateArgs>
    ): Prisma__BoardClient<BoardGetPayload<T>>

    /**
     * Create many Boards.
     *     @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     *     @example
     *     // Create many Boards
     *     const board = await prisma.board.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardCreateManyArgs>(
      args?: SelectSubset<T, BoardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
    **/
    delete<T extends BoardDeleteArgs>(
      args: SelectSubset<T, BoardDeleteArgs>
    ): Prisma__BoardClient<BoardGetPayload<T>>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardUpdateArgs>(
      args: SelectSubset<T, BoardUpdateArgs>
    ): Prisma__BoardClient<BoardGetPayload<T>>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardDeleteManyArgs>(
      args?: SelectSubset<T, BoardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardUpdateManyArgs>(
      args: SelectSubset<T, BoardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
    **/
    upsert<T extends BoardUpsertArgs>(
      args: SelectSubset<T, BoardUpsertArgs>
    ): Prisma__BoardClient<BoardGetPayload<T>>

    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    BoardImages<T extends BoardImageFindManyArgs= {}>(args?: Subset<T, BoardImageFindManyArgs>): PrismaPromise<Array<BoardImageGetPayload<T>>| Null>;

    BoardReplies<T extends BoardReplyFindManyArgs= {}>(args?: Subset<T, BoardReplyFindManyArgs>): PrismaPromise<Array<BoardReplyGetPayload<T>>| Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    CafeBoards<T extends CafeBoardFindManyArgs= {}>(args?: Subset<T, CafeBoardFindManyArgs>): PrismaPromise<Array<CafeBoardGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Board base type for findUnique actions
   */
  export type BoardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * Filter, which Board to fetch.
     * 
    **/
    where: BoardWhereUniqueInput
  }

  /**
   * Board: findUnique
   */
  export interface BoardFindUniqueArgs extends BoardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * Filter, which Board to fetch.
     * 
    **/
    where: BoardWhereUniqueInput
  }


  /**
   * Board base type for findFirst actions
   */
  export type BoardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * Filter, which Board to fetch.
     * 
    **/
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     * 
    **/
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     * 
    **/
    distinct?: Enumerable<BoardScalarFieldEnum>
  }

  /**
   * Board: findFirst
   */
  export interface BoardFindFirstArgs extends BoardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * Filter, which Board to fetch.
     * 
    **/
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     * 
    **/
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     * 
    **/
    distinct?: Enumerable<BoardScalarFieldEnum>
  }


  /**
   * Board findMany
   */
  export type BoardFindManyArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * Filter, which Boards to fetch.
     * 
    **/
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     * 
    **/
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BoardScalarFieldEnum>
  }


  /**
   * Board create
   */
  export type BoardCreateArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * The data needed to create a Board.
     * 
    **/
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }


  /**
   * Board createMany
   */
  export type BoardCreateManyArgs = {
    /**
     * The data used to create many Boards.
     * 
    **/
    data: Enumerable<BoardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Board update
   */
  export type BoardUpdateArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * The data needed to update a Board.
     * 
    **/
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     * 
    **/
    where: BoardWhereUniqueInput
  }


  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs = {
    /**
     * The data used to update Boards.
     * 
    **/
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     * 
    **/
    where?: BoardWhereInput
  }


  /**
   * Board upsert
   */
  export type BoardUpsertArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * The filter to search for the Board to update in case it exists.
     * 
    **/
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     * 
    **/
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }


  /**
   * Board delete
   */
  export type BoardDeleteArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
    /**
     * Filter which Board to delete.
     * 
    **/
    where: BoardWhereUniqueInput
  }


  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs = {
    /**
     * Filter which Boards to delete
     * 
    **/
    where?: BoardWhereInput
  }


  /**
   * Board without action
   */
  export type BoardArgs = {
    /**
     * Select specific fields to fetch from the Board
     * 
    **/
    select?: BoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardInclude | null
  }



  /**
   * Model BoardImage
   */


  export type AggregateBoardImage = {
    _count: BoardImageCountAggregateOutputType | null
    _avg: BoardImageAvgAggregateOutputType | null
    _sum: BoardImageSumAggregateOutputType | null
    _min: BoardImageMinAggregateOutputType | null
    _max: BoardImageMaxAggregateOutputType | null
  }

  export type BoardImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    boardId: number | null
  }

  export type BoardImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    boardId: number | null
  }

  export type BoardImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isThumb: boolean | null
    isDisable: boolean | null
    boardId: number | null
  }

  export type BoardImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isThumb: boolean | null
    isDisable: boolean | null
    boardId: number | null
  }

  export type BoardImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    thumbnailUrl: number
    width: number
    height: number
    size: number
    isThumb: number
    isDisable: number
    boardId: number
    _all: number
  }


  export type BoardImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    boardId?: true
  }

  export type BoardImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    boardId?: true
  }

  export type BoardImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isThumb?: true
    isDisable?: true
    boardId?: true
  }

  export type BoardImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isThumb?: true
    isDisable?: true
    boardId?: true
  }

  export type BoardImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isThumb?: true
    isDisable?: true
    boardId?: true
    _all?: true
  }

  export type BoardImageAggregateArgs = {
    /**
     * Filter which BoardImage to aggregate.
     * 
    **/
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardImages
    **/
    _count?: true | BoardImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardImageMaxAggregateInputType
  }

  export type GetBoardImageAggregateType<T extends BoardImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardImage[P]>
      : GetScalarType<T[P], AggregateBoardImage[P]>
  }




  export type BoardImageGroupByArgs = {
    where?: BoardImageWhereInput
    orderBy?: Enumerable<BoardImageOrderByWithAggregationInput>
    by: Array<BoardImageScalarFieldEnum>
    having?: BoardImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardImageCountAggregateInputType | true
    _avg?: BoardImageAvgAggregateInputType
    _sum?: BoardImageSumAggregateInputType
    _min?: BoardImageMinAggregateInputType
    _max?: BoardImageMaxAggregateInputType
  }


  export type BoardImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb: boolean
    isDisable: boolean
    boardId: number
    _count: BoardImageCountAggregateOutputType | null
    _avg: BoardImageAvgAggregateOutputType | null
    _sum: BoardImageSumAggregateOutputType | null
    _min: BoardImageMinAggregateOutputType | null
    _max: BoardImageMaxAggregateOutputType | null
  }

  type GetBoardImageGroupByPayload<T extends BoardImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BoardImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardImageGroupByOutputType[P]>
            : GetScalarType<T[P], BoardImageGroupByOutputType[P]>
        }
      >
    >


  export type BoardImageSelect = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isThumb?: boolean
    isDisable?: boolean
    boardId?: boolean
    Board?: boolean | BoardArgs
  }


  export type BoardImageInclude = {
    Board?: boolean | BoardArgs
  } 

  export type BoardImageGetPayload<S extends boolean | null | undefined | BoardImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardImage :
    S extends undefined ? never :
    S extends { include: any } & (BoardImageArgs | BoardImageFindManyArgs)
    ? BoardImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Board' ? BoardGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardImageArgs | BoardImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Board' ? BoardGetPayload<S['select'][P]> :  P extends keyof BoardImage ? BoardImage[P] : never
  } 
      : BoardImage


  type BoardImageCountArgs = Merge<
    Omit<BoardImageFindManyArgs, 'select' | 'include'> & {
      select?: BoardImageCountAggregateInputType | true
    }
  >

  export interface BoardImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one BoardImage that matches the filter.
     * @param {BoardImageFindUniqueArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardImage'> extends True ? Prisma__BoardImageClient<BoardImageGetPayload<T>> : Prisma__BoardImageClient<BoardImageGetPayload<T> | null, null>

    /**
     * Find one BoardImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardImageFindUniqueOrThrowArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardImageFindUniqueOrThrowArgs>
    ): Prisma__BoardImageClient<BoardImageGetPayload<T>>

    /**
     * Find the first BoardImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageFindFirstArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardImage'> extends True ? Prisma__BoardImageClient<BoardImageGetPayload<T>> : Prisma__BoardImageClient<BoardImageGetPayload<T> | null, null>

    /**
     * Find the first BoardImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageFindFirstOrThrowArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardImageFindFirstOrThrowArgs>
    ): Prisma__BoardImageClient<BoardImageGetPayload<T>>

    /**
     * Find zero or more BoardImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardImages
     * const boardImages = await prisma.boardImage.findMany()
     * 
     * // Get first 10 BoardImages
     * const boardImages = await prisma.boardImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardImageWithIdOnly = await prisma.boardImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardImageFindManyArgs>(
      args?: SelectSubset<T, BoardImageFindManyArgs>
    ): PrismaPromise<Array<BoardImageGetPayload<T>>>

    /**
     * Create a BoardImage.
     * @param {BoardImageCreateArgs} args - Arguments to create a BoardImage.
     * @example
     * // Create one BoardImage
     * const BoardImage = await prisma.boardImage.create({
     *   data: {
     *     // ... data to create a BoardImage
     *   }
     * })
     * 
    **/
    create<T extends BoardImageCreateArgs>(
      args: SelectSubset<T, BoardImageCreateArgs>
    ): Prisma__BoardImageClient<BoardImageGetPayload<T>>

    /**
     * Create many BoardImages.
     *     @param {BoardImageCreateManyArgs} args - Arguments to create many BoardImages.
     *     @example
     *     // Create many BoardImages
     *     const boardImage = await prisma.boardImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardImageCreateManyArgs>(
      args?: SelectSubset<T, BoardImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BoardImage.
     * @param {BoardImageDeleteArgs} args - Arguments to delete one BoardImage.
     * @example
     * // Delete one BoardImage
     * const BoardImage = await prisma.boardImage.delete({
     *   where: {
     *     // ... filter to delete one BoardImage
     *   }
     * })
     * 
    **/
    delete<T extends BoardImageDeleteArgs>(
      args: SelectSubset<T, BoardImageDeleteArgs>
    ): Prisma__BoardImageClient<BoardImageGetPayload<T>>

    /**
     * Update one BoardImage.
     * @param {BoardImageUpdateArgs} args - Arguments to update one BoardImage.
     * @example
     * // Update one BoardImage
     * const boardImage = await prisma.boardImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardImageUpdateArgs>(
      args: SelectSubset<T, BoardImageUpdateArgs>
    ): Prisma__BoardImageClient<BoardImageGetPayload<T>>

    /**
     * Delete zero or more BoardImages.
     * @param {BoardImageDeleteManyArgs} args - Arguments to filter BoardImages to delete.
     * @example
     * // Delete a few BoardImages
     * const { count } = await prisma.boardImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardImageDeleteManyArgs>(
      args?: SelectSubset<T, BoardImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardImages
     * const boardImage = await prisma.boardImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardImageUpdateManyArgs>(
      args: SelectSubset<T, BoardImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardImage.
     * @param {BoardImageUpsertArgs} args - Arguments to update or create a BoardImage.
     * @example
     * // Update or create a BoardImage
     * const boardImage = await prisma.boardImage.upsert({
     *   create: {
     *     // ... data to create a BoardImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardImage we want to update
     *   }
     * })
    **/
    upsert<T extends BoardImageUpsertArgs>(
      args: SelectSubset<T, BoardImageUpsertArgs>
    ): Prisma__BoardImageClient<BoardImageGetPayload<T>>

    /**
     * Count the number of BoardImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageCountArgs} args - Arguments to filter BoardImages to count.
     * @example
     * // Count the number of BoardImages
     * const count = await prisma.boardImage.count({
     *   where: {
     *     // ... the filter for the BoardImages we want to count
     *   }
     * })
    **/
    count<T extends BoardImageCountArgs>(
      args?: Subset<T, BoardImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardImageAggregateArgs>(args: Subset<T, BoardImageAggregateArgs>): PrismaPromise<GetBoardImageAggregateType<T>>

    /**
     * Group by BoardImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardImageGroupByArgs['orderBy'] }
        : { orderBy?: BoardImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Board<T extends BoardArgs= {}>(args?: Subset<T, BoardArgs>): Prisma__BoardClient<BoardGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardImage base type for findUnique actions
   */
  export type BoardImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * Filter, which BoardImage to fetch.
     * 
    **/
    where: BoardImageWhereUniqueInput
  }

  /**
   * BoardImage: findUnique
   */
  export interface BoardImageFindUniqueArgs extends BoardImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardImage findUniqueOrThrow
   */
  export type BoardImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * Filter, which BoardImage to fetch.
     * 
    **/
    where: BoardImageWhereUniqueInput
  }


  /**
   * BoardImage base type for findFirst actions
   */
  export type BoardImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * Filter, which BoardImage to fetch.
     * 
    **/
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardImages.
     * 
    **/
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardImages.
     * 
    **/
    distinct?: Enumerable<BoardImageScalarFieldEnum>
  }

  /**
   * BoardImage: findFirst
   */
  export interface BoardImageFindFirstArgs extends BoardImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardImage findFirstOrThrow
   */
  export type BoardImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * Filter, which BoardImage to fetch.
     * 
    **/
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardImages.
     * 
    **/
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardImages.
     * 
    **/
    distinct?: Enumerable<BoardImageScalarFieldEnum>
  }


  /**
   * BoardImage findMany
   */
  export type BoardImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * Filter, which BoardImages to fetch.
     * 
    **/
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardImages.
     * 
    **/
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BoardImageScalarFieldEnum>
  }


  /**
   * BoardImage create
   */
  export type BoardImageCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * The data needed to create a BoardImage.
     * 
    **/
    data: XOR<BoardImageCreateInput, BoardImageUncheckedCreateInput>
  }


  /**
   * BoardImage createMany
   */
  export type BoardImageCreateManyArgs = {
    /**
     * The data used to create many BoardImages.
     * 
    **/
    data: Enumerable<BoardImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardImage update
   */
  export type BoardImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * The data needed to update a BoardImage.
     * 
    **/
    data: XOR<BoardImageUpdateInput, BoardImageUncheckedUpdateInput>
    /**
     * Choose, which BoardImage to update.
     * 
    **/
    where: BoardImageWhereUniqueInput
  }


  /**
   * BoardImage updateMany
   */
  export type BoardImageUpdateManyArgs = {
    /**
     * The data used to update BoardImages.
     * 
    **/
    data: XOR<BoardImageUpdateManyMutationInput, BoardImageUncheckedUpdateManyInput>
    /**
     * Filter which BoardImages to update
     * 
    **/
    where?: BoardImageWhereInput
  }


  /**
   * BoardImage upsert
   */
  export type BoardImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * The filter to search for the BoardImage to update in case it exists.
     * 
    **/
    where: BoardImageWhereUniqueInput
    /**
     * In case the BoardImage found by the `where` argument doesn't exist, create a new BoardImage with this data.
     * 
    **/
    create: XOR<BoardImageCreateInput, BoardImageUncheckedCreateInput>
    /**
     * In case the BoardImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BoardImageUpdateInput, BoardImageUncheckedUpdateInput>
  }


  /**
   * BoardImage delete
   */
  export type BoardImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
    /**
     * Filter which BoardImage to delete.
     * 
    **/
    where: BoardImageWhereUniqueInput
  }


  /**
   * BoardImage deleteMany
   */
  export type BoardImageDeleteManyArgs = {
    /**
     * Filter which BoardImages to delete
     * 
    **/
    where?: BoardImageWhereInput
  }


  /**
   * BoardImage without action
   */
  export type BoardImageArgs = {
    /**
     * Select specific fields to fetch from the BoardImage
     * 
    **/
    select?: BoardImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardImageInclude | null
  }



  /**
   * Model BoardReply
   */


  export type AggregateBoardReply = {
    _count: BoardReplyCountAggregateOutputType | null
    _avg: BoardReplyAvgAggregateOutputType | null
    _sum: BoardReplySumAggregateOutputType | null
    _min: BoardReplyMinAggregateOutputType | null
    _max: BoardReplyMaxAggregateOutputType | null
  }

  export type BoardReplyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplySumAggregateOutputType = {
    id: number | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplyMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    isDisable: boolean | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplyMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    isDisable: boolean | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplyCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    content: number
    isDisable: number
    userId: number
    boardId: number
    boardReplyId: number
    _all: number
  }


  export type BoardReplyAvgAggregateInputType = {
    id?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplySumAggregateInputType = {
    id?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplyMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    isDisable?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    isDisable?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplyCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    isDisable?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
    _all?: true
  }

  export type BoardReplyAggregateArgs = {
    /**
     * Filter which BoardReply to aggregate.
     * 
    **/
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardReplies
    **/
    _count?: true | BoardReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardReplyMaxAggregateInputType
  }

  export type GetBoardReplyAggregateType<T extends BoardReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardReply[P]>
      : GetScalarType<T[P], AggregateBoardReply[P]>
  }




  export type BoardReplyGroupByArgs = {
    where?: BoardReplyWhereInput
    orderBy?: Enumerable<BoardReplyOrderByWithAggregationInput>
    by: Array<BoardReplyScalarFieldEnum>
    having?: BoardReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardReplyCountAggregateInputType | true
    _avg?: BoardReplyAvgAggregateInputType
    _sum?: BoardReplySumAggregateInputType
    _min?: BoardReplyMinAggregateInputType
    _max?: BoardReplyMaxAggregateInputType
  }


  export type BoardReplyGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    content: string
    isDisable: boolean
    userId: number
    boardId: number
    boardReplyId: number | null
    _count: BoardReplyCountAggregateOutputType | null
    _avg: BoardReplyAvgAggregateOutputType | null
    _sum: BoardReplySumAggregateOutputType | null
    _min: BoardReplyMinAggregateOutputType | null
    _max: BoardReplyMaxAggregateOutputType | null
  }

  type GetBoardReplyGroupByPayload<T extends BoardReplyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BoardReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardReplyGroupByOutputType[P]>
            : GetScalarType<T[P], BoardReplyGroupByOutputType[P]>
        }
      >
    >


  export type BoardReplySelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    isDisable?: boolean
    userId?: boolean
    User?: boolean | UserArgs
    boardId?: boolean
    Board?: boolean | BoardArgs
    boardReplyId?: boolean
    BoardReply?: boolean | BoardReplyArgs
    BoardNestedReplies?: boolean | BoardReplyFindManyArgs
    _count?: boolean | BoardReplyCountOutputTypeArgs
  }


  export type BoardReplyInclude = {
    User?: boolean | UserArgs
    Board?: boolean | BoardArgs
    BoardReply?: boolean | BoardReplyArgs
    BoardNestedReplies?: boolean | BoardReplyFindManyArgs
    _count?: boolean | BoardReplyCountOutputTypeArgs
  } 

  export type BoardReplyGetPayload<S extends boolean | null | undefined | BoardReplyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardReply :
    S extends undefined ? never :
    S extends { include: any } & (BoardReplyArgs | BoardReplyFindManyArgs)
    ? BoardReply  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'Board' ? BoardGetPayload<S['include'][P]> :
        P extends 'BoardReply' ? BoardReplyGetPayload<S['include'][P]> | null :
        P extends 'BoardNestedReplies' ? Array < BoardReplyGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoardReplyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardReplyArgs | BoardReplyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'Board' ? BoardGetPayload<S['select'][P]> :
        P extends 'BoardReply' ? BoardReplyGetPayload<S['select'][P]> | null :
        P extends 'BoardNestedReplies' ? Array < BoardReplyGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoardReplyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BoardReply ? BoardReply[P] : never
  } 
      : BoardReply


  type BoardReplyCountArgs = Merge<
    Omit<BoardReplyFindManyArgs, 'select' | 'include'> & {
      select?: BoardReplyCountAggregateInputType | true
    }
  >

  export interface BoardReplyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one BoardReply that matches the filter.
     * @param {BoardReplyFindUniqueArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardReplyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardReplyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardReply'> extends True ? Prisma__BoardReplyClient<BoardReplyGetPayload<T>> : Prisma__BoardReplyClient<BoardReplyGetPayload<T> | null, null>

    /**
     * Find one BoardReply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardReplyFindUniqueOrThrowArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardReplyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardReplyFindUniqueOrThrowArgs>
    ): Prisma__BoardReplyClient<BoardReplyGetPayload<T>>

    /**
     * Find the first BoardReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyFindFirstArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardReplyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardReplyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardReply'> extends True ? Prisma__BoardReplyClient<BoardReplyGetPayload<T>> : Prisma__BoardReplyClient<BoardReplyGetPayload<T> | null, null>

    /**
     * Find the first BoardReply that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyFindFirstOrThrowArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardReplyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardReplyFindFirstOrThrowArgs>
    ): Prisma__BoardReplyClient<BoardReplyGetPayload<T>>

    /**
     * Find zero or more BoardReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardReplies
     * const boardReplies = await prisma.boardReply.findMany()
     * 
     * // Get first 10 BoardReplies
     * const boardReplies = await prisma.boardReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardReplyWithIdOnly = await prisma.boardReply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardReplyFindManyArgs>(
      args?: SelectSubset<T, BoardReplyFindManyArgs>
    ): PrismaPromise<Array<BoardReplyGetPayload<T>>>

    /**
     * Create a BoardReply.
     * @param {BoardReplyCreateArgs} args - Arguments to create a BoardReply.
     * @example
     * // Create one BoardReply
     * const BoardReply = await prisma.boardReply.create({
     *   data: {
     *     // ... data to create a BoardReply
     *   }
     * })
     * 
    **/
    create<T extends BoardReplyCreateArgs>(
      args: SelectSubset<T, BoardReplyCreateArgs>
    ): Prisma__BoardReplyClient<BoardReplyGetPayload<T>>

    /**
     * Create many BoardReplies.
     *     @param {BoardReplyCreateManyArgs} args - Arguments to create many BoardReplies.
     *     @example
     *     // Create many BoardReplies
     *     const boardReply = await prisma.boardReply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardReplyCreateManyArgs>(
      args?: SelectSubset<T, BoardReplyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BoardReply.
     * @param {BoardReplyDeleteArgs} args - Arguments to delete one BoardReply.
     * @example
     * // Delete one BoardReply
     * const BoardReply = await prisma.boardReply.delete({
     *   where: {
     *     // ... filter to delete one BoardReply
     *   }
     * })
     * 
    **/
    delete<T extends BoardReplyDeleteArgs>(
      args: SelectSubset<T, BoardReplyDeleteArgs>
    ): Prisma__BoardReplyClient<BoardReplyGetPayload<T>>

    /**
     * Update one BoardReply.
     * @param {BoardReplyUpdateArgs} args - Arguments to update one BoardReply.
     * @example
     * // Update one BoardReply
     * const boardReply = await prisma.boardReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardReplyUpdateArgs>(
      args: SelectSubset<T, BoardReplyUpdateArgs>
    ): Prisma__BoardReplyClient<BoardReplyGetPayload<T>>

    /**
     * Delete zero or more BoardReplies.
     * @param {BoardReplyDeleteManyArgs} args - Arguments to filter BoardReplies to delete.
     * @example
     * // Delete a few BoardReplies
     * const { count } = await prisma.boardReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardReplyDeleteManyArgs>(
      args?: SelectSubset<T, BoardReplyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardReplies
     * const boardReply = await prisma.boardReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardReplyUpdateManyArgs>(
      args: SelectSubset<T, BoardReplyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardReply.
     * @param {BoardReplyUpsertArgs} args - Arguments to update or create a BoardReply.
     * @example
     * // Update or create a BoardReply
     * const boardReply = await prisma.boardReply.upsert({
     *   create: {
     *     // ... data to create a BoardReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardReply we want to update
     *   }
     * })
    **/
    upsert<T extends BoardReplyUpsertArgs>(
      args: SelectSubset<T, BoardReplyUpsertArgs>
    ): Prisma__BoardReplyClient<BoardReplyGetPayload<T>>

    /**
     * Count the number of BoardReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyCountArgs} args - Arguments to filter BoardReplies to count.
     * @example
     * // Count the number of BoardReplies
     * const count = await prisma.boardReply.count({
     *   where: {
     *     // ... the filter for the BoardReplies we want to count
     *   }
     * })
    **/
    count<T extends BoardReplyCountArgs>(
      args?: Subset<T, BoardReplyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardReplyAggregateArgs>(args: Subset<T, BoardReplyAggregateArgs>): PrismaPromise<GetBoardReplyAggregateType<T>>

    /**
     * Group by BoardReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardReplyGroupByArgs['orderBy'] }
        : { orderBy?: BoardReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardReplyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardReplyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Board<T extends BoardArgs= {}>(args?: Subset<T, BoardArgs>): Prisma__BoardClient<BoardGetPayload<T> | Null>;

    BoardReply<T extends BoardReplyArgs= {}>(args?: Subset<T, BoardReplyArgs>): Prisma__BoardReplyClient<BoardReplyGetPayload<T> | Null>;

    BoardNestedReplies<T extends BoardReplyFindManyArgs= {}>(args?: Subset<T, BoardReplyFindManyArgs>): PrismaPromise<Array<BoardReplyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardReply base type for findUnique actions
   */
  export type BoardReplyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * Filter, which BoardReply to fetch.
     * 
    **/
    where: BoardReplyWhereUniqueInput
  }

  /**
   * BoardReply: findUnique
   */
  export interface BoardReplyFindUniqueArgs extends BoardReplyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardReply findUniqueOrThrow
   */
  export type BoardReplyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * Filter, which BoardReply to fetch.
     * 
    **/
    where: BoardReplyWhereUniqueInput
  }


  /**
   * BoardReply base type for findFirst actions
   */
  export type BoardReplyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * Filter, which BoardReply to fetch.
     * 
    **/
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardReplies.
     * 
    **/
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardReplies.
     * 
    **/
    distinct?: Enumerable<BoardReplyScalarFieldEnum>
  }

  /**
   * BoardReply: findFirst
   */
  export interface BoardReplyFindFirstArgs extends BoardReplyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardReply findFirstOrThrow
   */
  export type BoardReplyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * Filter, which BoardReply to fetch.
     * 
    **/
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardReplies.
     * 
    **/
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardReplies.
     * 
    **/
    distinct?: Enumerable<BoardReplyScalarFieldEnum>
  }


  /**
   * BoardReply findMany
   */
  export type BoardReplyFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * Filter, which BoardReplies to fetch.
     * 
    **/
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     * 
    **/
    orderBy?: Enumerable<BoardReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardReplies.
     * 
    **/
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BoardReplyScalarFieldEnum>
  }


  /**
   * BoardReply create
   */
  export type BoardReplyCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * The data needed to create a BoardReply.
     * 
    **/
    data: XOR<BoardReplyCreateInput, BoardReplyUncheckedCreateInput>
  }


  /**
   * BoardReply createMany
   */
  export type BoardReplyCreateManyArgs = {
    /**
     * The data used to create many BoardReplies.
     * 
    **/
    data: Enumerable<BoardReplyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardReply update
   */
  export type BoardReplyUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * The data needed to update a BoardReply.
     * 
    **/
    data: XOR<BoardReplyUpdateInput, BoardReplyUncheckedUpdateInput>
    /**
     * Choose, which BoardReply to update.
     * 
    **/
    where: BoardReplyWhereUniqueInput
  }


  /**
   * BoardReply updateMany
   */
  export type BoardReplyUpdateManyArgs = {
    /**
     * The data used to update BoardReplies.
     * 
    **/
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyInput>
    /**
     * Filter which BoardReplies to update
     * 
    **/
    where?: BoardReplyWhereInput
  }


  /**
   * BoardReply upsert
   */
  export type BoardReplyUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * The filter to search for the BoardReply to update in case it exists.
     * 
    **/
    where: BoardReplyWhereUniqueInput
    /**
     * In case the BoardReply found by the `where` argument doesn't exist, create a new BoardReply with this data.
     * 
    **/
    create: XOR<BoardReplyCreateInput, BoardReplyUncheckedCreateInput>
    /**
     * In case the BoardReply was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BoardReplyUpdateInput, BoardReplyUncheckedUpdateInput>
  }


  /**
   * BoardReply delete
   */
  export type BoardReplyDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
    /**
     * Filter which BoardReply to delete.
     * 
    **/
    where: BoardReplyWhereUniqueInput
  }


  /**
   * BoardReply deleteMany
   */
  export type BoardReplyDeleteManyArgs = {
    /**
     * Filter which BoardReplies to delete
     * 
    **/
    where?: BoardReplyWhereInput
  }


  /**
   * BoardReply without action
   */
  export type BoardReplyArgs = {
    /**
     * Select specific fields to fetch from the BoardReply
     * 
    **/
    select?: BoardReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BoardReplyInclude | null
  }



  /**
   * Model CafeBoard
   */


  export type AggregateCafeBoard = {
    _count: CafeBoardCountAggregateOutputType | null
    _avg: CafeBoardAvgAggregateOutputType | null
    _sum: CafeBoardSumAggregateOutputType | null
    _min: CafeBoardMinAggregateOutputType | null
    _max: CafeBoardMaxAggregateOutputType | null
  }

  export type CafeBoardAvgAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
  }

  export type CafeBoardSumAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
  }

  export type CafeBoardMinAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
    createdAt: Date | null
  }

  export type CafeBoardMaxAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
    createdAt: Date | null
  }

  export type CafeBoardCountAggregateOutputType = {
    boardId: number
    cafeInfoId: number
    createdAt: number
    _all: number
  }


  export type CafeBoardAvgAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
  }

  export type CafeBoardSumAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
  }

  export type CafeBoardMinAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
    createdAt?: true
  }

  export type CafeBoardMaxAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
    createdAt?: true
  }

  export type CafeBoardCountAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
    createdAt?: true
    _all?: true
  }

  export type CafeBoardAggregateArgs = {
    /**
     * Filter which CafeBoard to aggregate.
     * 
    **/
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeBoards
    **/
    _count?: true | CafeBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeBoardMaxAggregateInputType
  }

  export type GetCafeBoardAggregateType<T extends CafeBoardAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeBoard[P]>
      : GetScalarType<T[P], AggregateCafeBoard[P]>
  }




  export type CafeBoardGroupByArgs = {
    where?: CafeBoardWhereInput
    orderBy?: Enumerable<CafeBoardOrderByWithAggregationInput>
    by: Array<CafeBoardScalarFieldEnum>
    having?: CafeBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeBoardCountAggregateInputType | true
    _avg?: CafeBoardAvgAggregateInputType
    _sum?: CafeBoardSumAggregateInputType
    _min?: CafeBoardMinAggregateInputType
    _max?: CafeBoardMaxAggregateInputType
  }


  export type CafeBoardGroupByOutputType = {
    boardId: number
    cafeInfoId: number
    createdAt: Date
    _count: CafeBoardCountAggregateOutputType | null
    _avg: CafeBoardAvgAggregateOutputType | null
    _sum: CafeBoardSumAggregateOutputType | null
    _min: CafeBoardMinAggregateOutputType | null
    _max: CafeBoardMaxAggregateOutputType | null
  }

  type GetCafeBoardGroupByPayload<T extends CafeBoardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeBoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeBoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeBoardGroupByOutputType[P]>
            : GetScalarType<T[P], CafeBoardGroupByOutputType[P]>
        }
      >
    >


  export type CafeBoardSelect = {
    boardId?: boolean
    cafeInfoId?: boolean
    Board?: boolean | BoardArgs
    CafeInfo?: boolean | CafeInfoArgs
    createdAt?: boolean
  }


  export type CafeBoardInclude = {
    Board?: boolean | BoardArgs
    CafeInfo?: boolean | CafeInfoArgs
  } 

  export type CafeBoardGetPayload<S extends boolean | null | undefined | CafeBoardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeBoard :
    S extends undefined ? never :
    S extends { include: any } & (CafeBoardArgs | CafeBoardFindManyArgs)
    ? CafeBoard  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Board' ? BoardGetPayload<S['include'][P]> :
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeBoardArgs | CafeBoardFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Board' ? BoardGetPayload<S['select'][P]> :
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :  P extends keyof CafeBoard ? CafeBoard[P] : never
  } 
      : CafeBoard


  type CafeBoardCountArgs = Merge<
    Omit<CafeBoardFindManyArgs, 'select' | 'include'> & {
      select?: CafeBoardCountAggregateInputType | true
    }
  >

  export interface CafeBoardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeBoard that matches the filter.
     * @param {CafeBoardFindUniqueArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeBoardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeBoardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeBoard'> extends True ? Prisma__CafeBoardClient<CafeBoardGetPayload<T>> : Prisma__CafeBoardClient<CafeBoardGetPayload<T> | null, null>

    /**
     * Find one CafeBoard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeBoardFindUniqueOrThrowArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeBoardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeBoardFindUniqueOrThrowArgs>
    ): Prisma__CafeBoardClient<CafeBoardGetPayload<T>>

    /**
     * Find the first CafeBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardFindFirstArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeBoardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeBoardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeBoard'> extends True ? Prisma__CafeBoardClient<CafeBoardGetPayload<T>> : Prisma__CafeBoardClient<CafeBoardGetPayload<T> | null, null>

    /**
     * Find the first CafeBoard that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardFindFirstOrThrowArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeBoardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeBoardFindFirstOrThrowArgs>
    ): Prisma__CafeBoardClient<CafeBoardGetPayload<T>>

    /**
     * Find zero or more CafeBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeBoards
     * const cafeBoards = await prisma.cafeBoard.findMany()
     * 
     * // Get first 10 CafeBoards
     * const cafeBoards = await prisma.cafeBoard.findMany({ take: 10 })
     * 
     * // Only select the `boardId`
     * const cafeBoardWithBoardIdOnly = await prisma.cafeBoard.findMany({ select: { boardId: true } })
     * 
    **/
    findMany<T extends CafeBoardFindManyArgs>(
      args?: SelectSubset<T, CafeBoardFindManyArgs>
    ): PrismaPromise<Array<CafeBoardGetPayload<T>>>

    /**
     * Create a CafeBoard.
     * @param {CafeBoardCreateArgs} args - Arguments to create a CafeBoard.
     * @example
     * // Create one CafeBoard
     * const CafeBoard = await prisma.cafeBoard.create({
     *   data: {
     *     // ... data to create a CafeBoard
     *   }
     * })
     * 
    **/
    create<T extends CafeBoardCreateArgs>(
      args: SelectSubset<T, CafeBoardCreateArgs>
    ): Prisma__CafeBoardClient<CafeBoardGetPayload<T>>

    /**
     * Create many CafeBoards.
     *     @param {CafeBoardCreateManyArgs} args - Arguments to create many CafeBoards.
     *     @example
     *     // Create many CafeBoards
     *     const cafeBoard = await prisma.cafeBoard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeBoardCreateManyArgs>(
      args?: SelectSubset<T, CafeBoardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeBoard.
     * @param {CafeBoardDeleteArgs} args - Arguments to delete one CafeBoard.
     * @example
     * // Delete one CafeBoard
     * const CafeBoard = await prisma.cafeBoard.delete({
     *   where: {
     *     // ... filter to delete one CafeBoard
     *   }
     * })
     * 
    **/
    delete<T extends CafeBoardDeleteArgs>(
      args: SelectSubset<T, CafeBoardDeleteArgs>
    ): Prisma__CafeBoardClient<CafeBoardGetPayload<T>>

    /**
     * Update one CafeBoard.
     * @param {CafeBoardUpdateArgs} args - Arguments to update one CafeBoard.
     * @example
     * // Update one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeBoardUpdateArgs>(
      args: SelectSubset<T, CafeBoardUpdateArgs>
    ): Prisma__CafeBoardClient<CafeBoardGetPayload<T>>

    /**
     * Delete zero or more CafeBoards.
     * @param {CafeBoardDeleteManyArgs} args - Arguments to filter CafeBoards to delete.
     * @example
     * // Delete a few CafeBoards
     * const { count } = await prisma.cafeBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeBoardDeleteManyArgs>(
      args?: SelectSubset<T, CafeBoardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeBoards
     * const cafeBoard = await prisma.cafeBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeBoardUpdateManyArgs>(
      args: SelectSubset<T, CafeBoardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeBoard.
     * @param {CafeBoardUpsertArgs} args - Arguments to update or create a CafeBoard.
     * @example
     * // Update or create a CafeBoard
     * const cafeBoard = await prisma.cafeBoard.upsert({
     *   create: {
     *     // ... data to create a CafeBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeBoard we want to update
     *   }
     * })
    **/
    upsert<T extends CafeBoardUpsertArgs>(
      args: SelectSubset<T, CafeBoardUpsertArgs>
    ): Prisma__CafeBoardClient<CafeBoardGetPayload<T>>

    /**
     * Count the number of CafeBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardCountArgs} args - Arguments to filter CafeBoards to count.
     * @example
     * // Count the number of CafeBoards
     * const count = await prisma.cafeBoard.count({
     *   where: {
     *     // ... the filter for the CafeBoards we want to count
     *   }
     * })
    **/
    count<T extends CafeBoardCountArgs>(
      args?: Subset<T, CafeBoardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeBoardAggregateArgs>(args: Subset<T, CafeBoardAggregateArgs>): PrismaPromise<GetCafeBoardAggregateType<T>>

    /**
     * Group by CafeBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeBoardGroupByArgs['orderBy'] }
        : { orderBy?: CafeBoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeBoardGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeBoardClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Board<T extends BoardArgs= {}>(args?: Subset<T, BoardArgs>): Prisma__BoardClient<BoardGetPayload<T> | Null>;

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeBoard base type for findUnique actions
   */
  export type CafeBoardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * Filter, which CafeBoard to fetch.
     * 
    **/
    where: CafeBoardWhereUniqueInput
  }

  /**
   * CafeBoard: findUnique
   */
  export interface CafeBoardFindUniqueArgs extends CafeBoardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeBoard findUniqueOrThrow
   */
  export type CafeBoardFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * Filter, which CafeBoard to fetch.
     * 
    **/
    where: CafeBoardWhereUniqueInput
  }


  /**
   * CafeBoard base type for findFirst actions
   */
  export type CafeBoardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * Filter, which CafeBoard to fetch.
     * 
    **/
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeBoards.
     * 
    **/
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeBoards.
     * 
    **/
    distinct?: Enumerable<CafeBoardScalarFieldEnum>
  }

  /**
   * CafeBoard: findFirst
   */
  export interface CafeBoardFindFirstArgs extends CafeBoardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeBoard findFirstOrThrow
   */
  export type CafeBoardFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * Filter, which CafeBoard to fetch.
     * 
    **/
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeBoards.
     * 
    **/
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeBoards.
     * 
    **/
    distinct?: Enumerable<CafeBoardScalarFieldEnum>
  }


  /**
   * CafeBoard findMany
   */
  export type CafeBoardFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * Filter, which CafeBoards to fetch.
     * 
    **/
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeBoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeBoards.
     * 
    **/
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeBoardScalarFieldEnum>
  }


  /**
   * CafeBoard create
   */
  export type CafeBoardCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * The data needed to create a CafeBoard.
     * 
    **/
    data: XOR<CafeBoardCreateInput, CafeBoardUncheckedCreateInput>
  }


  /**
   * CafeBoard createMany
   */
  export type CafeBoardCreateManyArgs = {
    /**
     * The data used to create many CafeBoards.
     * 
    **/
    data: Enumerable<CafeBoardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeBoard update
   */
  export type CafeBoardUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * The data needed to update a CafeBoard.
     * 
    **/
    data: XOR<CafeBoardUpdateInput, CafeBoardUncheckedUpdateInput>
    /**
     * Choose, which CafeBoard to update.
     * 
    **/
    where: CafeBoardWhereUniqueInput
  }


  /**
   * CafeBoard updateMany
   */
  export type CafeBoardUpdateManyArgs = {
    /**
     * The data used to update CafeBoards.
     * 
    **/
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyInput>
    /**
     * Filter which CafeBoards to update
     * 
    **/
    where?: CafeBoardWhereInput
  }


  /**
   * CafeBoard upsert
   */
  export type CafeBoardUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * The filter to search for the CafeBoard to update in case it exists.
     * 
    **/
    where: CafeBoardWhereUniqueInput
    /**
     * In case the CafeBoard found by the `where` argument doesn't exist, create a new CafeBoard with this data.
     * 
    **/
    create: XOR<CafeBoardCreateInput, CafeBoardUncheckedCreateInput>
    /**
     * In case the CafeBoard was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeBoardUpdateInput, CafeBoardUncheckedUpdateInput>
  }


  /**
   * CafeBoard delete
   */
  export type CafeBoardDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
    /**
     * Filter which CafeBoard to delete.
     * 
    **/
    where: CafeBoardWhereUniqueInput
  }


  /**
   * CafeBoard deleteMany
   */
  export type CafeBoardDeleteManyArgs = {
    /**
     * Filter which CafeBoards to delete
     * 
    **/
    where?: CafeBoardWhereInput
  }


  /**
   * CafeBoard without action
   */
  export type CafeBoardArgs = {
    /**
     * Select specific fields to fetch from the CafeBoard
     * 
    **/
    select?: CafeBoardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeBoardInclude | null
  }



  /**
   * Model RegionCategory
   */


  export type AggregateRegionCategory = {
    _count: RegionCategoryCountAggregateOutputType | null
    _avg: RegionCategoryAvgAggregateOutputType | null
    _sum: RegionCategorySumAggregateOutputType | null
    _min: RegionCategoryMinAggregateOutputType | null
    _max: RegionCategoryMaxAggregateOutputType | null
  }

  export type RegionCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionCategorySumAggregateOutputType = {
    id: number | null
  }

  export type RegionCategoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    isDisable: boolean | null
    govermentType: GovermentType | null
  }

  export type RegionCategoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    isDisable: boolean | null
    govermentType: GovermentType | null
  }

  export type RegionCategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    isDisable: number
    govermentType: number
    _all: number
  }


  export type RegionCategoryAvgAggregateInputType = {
    id?: true
  }

  export type RegionCategorySumAggregateInputType = {
    id?: true
  }

  export type RegionCategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    isDisable?: true
    govermentType?: true
  }

  export type RegionCategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    isDisable?: true
    govermentType?: true
  }

  export type RegionCategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    isDisable?: true
    govermentType?: true
    _all?: true
  }

  export type RegionCategoryAggregateArgs = {
    /**
     * Filter which RegionCategory to aggregate.
     * 
    **/
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionCategories
    **/
    _count?: true | RegionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionCategoryMaxAggregateInputType
  }

  export type GetRegionCategoryAggregateType<T extends RegionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionCategory[P]>
      : GetScalarType<T[P], AggregateRegionCategory[P]>
  }




  export type RegionCategoryGroupByArgs = {
    where?: RegionCategoryWhereInput
    orderBy?: Enumerable<RegionCategoryOrderByWithAggregationInput>
    by: Array<RegionCategoryScalarFieldEnum>
    having?: RegionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCategoryCountAggregateInputType | true
    _avg?: RegionCategoryAvgAggregateInputType
    _sum?: RegionCategorySumAggregateInputType
    _min?: RegionCategoryMinAggregateInputType
    _max?: RegionCategoryMaxAggregateInputType
  }


  export type RegionCategoryGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    isDisable: boolean
    govermentType: GovermentType
    _count: RegionCategoryCountAggregateOutputType | null
    _avg: RegionCategoryAvgAggregateOutputType | null
    _sum: RegionCategorySumAggregateOutputType | null
    _min: RegionCategoryMinAggregateOutputType | null
    _max: RegionCategoryMaxAggregateOutputType | null
  }

  type GetRegionCategoryGroupByPayload<T extends RegionCategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RegionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], RegionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type RegionCategorySelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    isDisable?: boolean
    govermentType?: boolean
    CafeInfos?: boolean | CafeInfoFindManyArgs
    AncestorCategories?: boolean | ClosureRegionCategoryFindManyArgs
    DescendantCategories?: boolean | ClosureRegionCategoryFindManyArgs
    _count?: boolean | RegionCategoryCountOutputTypeArgs
  }


  export type RegionCategoryInclude = {
    CafeInfos?: boolean | CafeInfoFindManyArgs
    AncestorCategories?: boolean | ClosureRegionCategoryFindManyArgs
    DescendantCategories?: boolean | ClosureRegionCategoryFindManyArgs
    _count?: boolean | RegionCategoryCountOutputTypeArgs
  } 

  export type RegionCategoryGetPayload<S extends boolean | null | undefined | RegionCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RegionCategory :
    S extends undefined ? never :
    S extends { include: any } & (RegionCategoryArgs | RegionCategoryFindManyArgs)
    ? RegionCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeInfos' ? Array < CafeInfoGetPayload<S['include'][P]>>  :
        P extends 'AncestorCategories' ? Array < ClosureRegionCategoryGetPayload<S['include'][P]>>  :
        P extends 'DescendantCategories' ? Array < ClosureRegionCategoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? RegionCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RegionCategoryArgs | RegionCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeInfos' ? Array < CafeInfoGetPayload<S['select'][P]>>  :
        P extends 'AncestorCategories' ? Array < ClosureRegionCategoryGetPayload<S['select'][P]>>  :
        P extends 'DescendantCategories' ? Array < ClosureRegionCategoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? RegionCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RegionCategory ? RegionCategory[P] : never
  } 
      : RegionCategory


  type RegionCategoryCountArgs = Merge<
    Omit<RegionCategoryFindManyArgs, 'select' | 'include'> & {
      select?: RegionCategoryCountAggregateInputType | true
    }
  >

  export interface RegionCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RegionCategory that matches the filter.
     * @param {RegionCategoryFindUniqueArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegionCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RegionCategory'> extends True ? Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>> : Prisma__RegionCategoryClient<RegionCategoryGetPayload<T> | null, null>

    /**
     * Find one RegionCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegionCategoryFindUniqueOrThrowArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RegionCategoryFindUniqueOrThrowArgs>
    ): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>>

    /**
     * Find the first RegionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryFindFirstArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegionCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RegionCategory'> extends True ? Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>> : Prisma__RegionCategoryClient<RegionCategoryGetPayload<T> | null, null>

    /**
     * Find the first RegionCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryFindFirstOrThrowArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RegionCategoryFindFirstOrThrowArgs>
    ): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>>

    /**
     * Find zero or more RegionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionCategories
     * const regionCategories = await prisma.regionCategory.findMany()
     * 
     * // Get first 10 RegionCategories
     * const regionCategories = await prisma.regionCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionCategoryWithIdOnly = await prisma.regionCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionCategoryFindManyArgs>(
      args?: SelectSubset<T, RegionCategoryFindManyArgs>
    ): PrismaPromise<Array<RegionCategoryGetPayload<T>>>

    /**
     * Create a RegionCategory.
     * @param {RegionCategoryCreateArgs} args - Arguments to create a RegionCategory.
     * @example
     * // Create one RegionCategory
     * const RegionCategory = await prisma.regionCategory.create({
     *   data: {
     *     // ... data to create a RegionCategory
     *   }
     * })
     * 
    **/
    create<T extends RegionCategoryCreateArgs>(
      args: SelectSubset<T, RegionCategoryCreateArgs>
    ): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>>

    /**
     * Create many RegionCategories.
     *     @param {RegionCategoryCreateManyArgs} args - Arguments to create many RegionCategories.
     *     @example
     *     // Create many RegionCategories
     *     const regionCategory = await prisma.regionCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCategoryCreateManyArgs>(
      args?: SelectSubset<T, RegionCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RegionCategory.
     * @param {RegionCategoryDeleteArgs} args - Arguments to delete one RegionCategory.
     * @example
     * // Delete one RegionCategory
     * const RegionCategory = await prisma.regionCategory.delete({
     *   where: {
     *     // ... filter to delete one RegionCategory
     *   }
     * })
     * 
    **/
    delete<T extends RegionCategoryDeleteArgs>(
      args: SelectSubset<T, RegionCategoryDeleteArgs>
    ): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>>

    /**
     * Update one RegionCategory.
     * @param {RegionCategoryUpdateArgs} args - Arguments to update one RegionCategory.
     * @example
     * // Update one RegionCategory
     * const regionCategory = await prisma.regionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionCategoryUpdateArgs>(
      args: SelectSubset<T, RegionCategoryUpdateArgs>
    ): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>>

    /**
     * Delete zero or more RegionCategories.
     * @param {RegionCategoryDeleteManyArgs} args - Arguments to filter RegionCategories to delete.
     * @example
     * // Delete a few RegionCategories
     * const { count } = await prisma.regionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionCategoryDeleteManyArgs>(
      args?: SelectSubset<T, RegionCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionCategories
     * const regionCategory = await prisma.regionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionCategoryUpdateManyArgs>(
      args: SelectSubset<T, RegionCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RegionCategory.
     * @param {RegionCategoryUpsertArgs} args - Arguments to update or create a RegionCategory.
     * @example
     * // Update or create a RegionCategory
     * const regionCategory = await prisma.regionCategory.upsert({
     *   create: {
     *     // ... data to create a RegionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionCategory we want to update
     *   }
     * })
    **/
    upsert<T extends RegionCategoryUpsertArgs>(
      args: SelectSubset<T, RegionCategoryUpsertArgs>
    ): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T>>

    /**
     * Count the number of RegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryCountArgs} args - Arguments to filter RegionCategories to count.
     * @example
     * // Count the number of RegionCategories
     * const count = await prisma.regionCategory.count({
     *   where: {
     *     // ... the filter for the RegionCategories we want to count
     *   }
     * })
    **/
    count<T extends RegionCategoryCountArgs>(
      args?: Subset<T, RegionCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionCategoryAggregateArgs>(args: Subset<T, RegionCategoryAggregateArgs>): PrismaPromise<GetRegionCategoryAggregateType<T>>

    /**
     * Group by RegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: RegionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegionCategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeInfos<T extends CafeInfoFindManyArgs= {}>(args?: Subset<T, CafeInfoFindManyArgs>): PrismaPromise<Array<CafeInfoGetPayload<T>>| Null>;

    AncestorCategories<T extends ClosureRegionCategoryFindManyArgs= {}>(args?: Subset<T, ClosureRegionCategoryFindManyArgs>): PrismaPromise<Array<ClosureRegionCategoryGetPayload<T>>| Null>;

    DescendantCategories<T extends ClosureRegionCategoryFindManyArgs= {}>(args?: Subset<T, ClosureRegionCategoryFindManyArgs>): PrismaPromise<Array<ClosureRegionCategoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RegionCategory base type for findUnique actions
   */
  export type RegionCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * Filter, which RegionCategory to fetch.
     * 
    **/
    where: RegionCategoryWhereUniqueInput
  }

  /**
   * RegionCategory: findUnique
   */
  export interface RegionCategoryFindUniqueArgs extends RegionCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RegionCategory findUniqueOrThrow
   */
  export type RegionCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * Filter, which RegionCategory to fetch.
     * 
    **/
    where: RegionCategoryWhereUniqueInput
  }


  /**
   * RegionCategory base type for findFirst actions
   */
  export type RegionCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * Filter, which RegionCategory to fetch.
     * 
    **/
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionCategories.
     * 
    **/
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionCategories.
     * 
    **/
    distinct?: Enumerable<RegionCategoryScalarFieldEnum>
  }

  /**
   * RegionCategory: findFirst
   */
  export interface RegionCategoryFindFirstArgs extends RegionCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RegionCategory findFirstOrThrow
   */
  export type RegionCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * Filter, which RegionCategory to fetch.
     * 
    **/
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionCategories.
     * 
    **/
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionCategories.
     * 
    **/
    distinct?: Enumerable<RegionCategoryScalarFieldEnum>
  }


  /**
   * RegionCategory findMany
   */
  export type RegionCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * Filter, which RegionCategories to fetch.
     * 
    **/
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionCategories.
     * 
    **/
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RegionCategoryScalarFieldEnum>
  }


  /**
   * RegionCategory create
   */
  export type RegionCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * The data needed to create a RegionCategory.
     * 
    **/
    data: XOR<RegionCategoryCreateInput, RegionCategoryUncheckedCreateInput>
  }


  /**
   * RegionCategory createMany
   */
  export type RegionCategoryCreateManyArgs = {
    /**
     * The data used to create many RegionCategories.
     * 
    **/
    data: Enumerable<RegionCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RegionCategory update
   */
  export type RegionCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * The data needed to update a RegionCategory.
     * 
    **/
    data: XOR<RegionCategoryUpdateInput, RegionCategoryUncheckedUpdateInput>
    /**
     * Choose, which RegionCategory to update.
     * 
    **/
    where: RegionCategoryWhereUniqueInput
  }


  /**
   * RegionCategory updateMany
   */
  export type RegionCategoryUpdateManyArgs = {
    /**
     * The data used to update RegionCategories.
     * 
    **/
    data: XOR<RegionCategoryUpdateManyMutationInput, RegionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which RegionCategories to update
     * 
    **/
    where?: RegionCategoryWhereInput
  }


  /**
   * RegionCategory upsert
   */
  export type RegionCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * The filter to search for the RegionCategory to update in case it exists.
     * 
    **/
    where: RegionCategoryWhereUniqueInput
    /**
     * In case the RegionCategory found by the `where` argument doesn't exist, create a new RegionCategory with this data.
     * 
    **/
    create: XOR<RegionCategoryCreateInput, RegionCategoryUncheckedCreateInput>
    /**
     * In case the RegionCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RegionCategoryUpdateInput, RegionCategoryUncheckedUpdateInput>
  }


  /**
   * RegionCategory delete
   */
  export type RegionCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
    /**
     * Filter which RegionCategory to delete.
     * 
    **/
    where: RegionCategoryWhereUniqueInput
  }


  /**
   * RegionCategory deleteMany
   */
  export type RegionCategoryDeleteManyArgs = {
    /**
     * Filter which RegionCategories to delete
     * 
    **/
    where?: RegionCategoryWhereInput
  }


  /**
   * RegionCategory without action
   */
  export type RegionCategoryArgs = {
    /**
     * Select specific fields to fetch from the RegionCategory
     * 
    **/
    select?: RegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionCategoryInclude | null
  }



  /**
   * Model ClosureRegionCategory
   */


  export type AggregateClosureRegionCategory = {
    _count: ClosureRegionCategoryCountAggregateOutputType | null
    _avg: ClosureRegionCategoryAvgAggregateOutputType | null
    _sum: ClosureRegionCategorySumAggregateOutputType | null
    _min: ClosureRegionCategoryMinAggregateOutputType | null
    _max: ClosureRegionCategoryMaxAggregateOutputType | null
  }

  export type ClosureRegionCategoryAvgAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategorySumAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategoryMinAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategoryMaxAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategoryCountAggregateOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _all: number
  }


  export type ClosureRegionCategoryAvgAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategorySumAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategoryMinAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategoryMaxAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategoryCountAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
    _all?: true
  }

  export type ClosureRegionCategoryAggregateArgs = {
    /**
     * Filter which ClosureRegionCategory to aggregate.
     * 
    **/
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureRegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClosureRegionCategories
    **/
    _count?: true | ClosureRegionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClosureRegionCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClosureRegionCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClosureRegionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClosureRegionCategoryMaxAggregateInputType
  }

  export type GetClosureRegionCategoryAggregateType<T extends ClosureRegionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateClosureRegionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClosureRegionCategory[P]>
      : GetScalarType<T[P], AggregateClosureRegionCategory[P]>
  }




  export type ClosureRegionCategoryGroupByArgs = {
    where?: ClosureRegionCategoryWhereInput
    orderBy?: Enumerable<ClosureRegionCategoryOrderByWithAggregationInput>
    by: Array<ClosureRegionCategoryScalarFieldEnum>
    having?: ClosureRegionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClosureRegionCategoryCountAggregateInputType | true
    _avg?: ClosureRegionCategoryAvgAggregateInputType
    _sum?: ClosureRegionCategorySumAggregateInputType
    _min?: ClosureRegionCategoryMinAggregateInputType
    _max?: ClosureRegionCategoryMaxAggregateInputType
  }


  export type ClosureRegionCategoryGroupByOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _count: ClosureRegionCategoryCountAggregateOutputType | null
    _avg: ClosureRegionCategoryAvgAggregateOutputType | null
    _sum: ClosureRegionCategorySumAggregateOutputType | null
    _min: ClosureRegionCategoryMinAggregateOutputType | null
    _max: ClosureRegionCategoryMaxAggregateOutputType | null
  }

  type GetClosureRegionCategoryGroupByPayload<T extends ClosureRegionCategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClosureRegionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClosureRegionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClosureRegionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ClosureRegionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ClosureRegionCategorySelect = {
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | RegionCategoryArgs
    DescendantCategory?: boolean | RegionCategoryArgs
  }


  export type ClosureRegionCategoryInclude = {
    AncestorCategory?: boolean | RegionCategoryArgs
    DescendantCategory?: boolean | RegionCategoryArgs
  } 

  export type ClosureRegionCategoryGetPayload<S extends boolean | null | undefined | ClosureRegionCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClosureRegionCategory :
    S extends undefined ? never :
    S extends { include: any } & (ClosureRegionCategoryArgs | ClosureRegionCategoryFindManyArgs)
    ? ClosureRegionCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'AncestorCategory' ? RegionCategoryGetPayload<S['include'][P]> :
        P extends 'DescendantCategory' ? RegionCategoryGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ClosureRegionCategoryArgs | ClosureRegionCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'AncestorCategory' ? RegionCategoryGetPayload<S['select'][P]> :
        P extends 'DescendantCategory' ? RegionCategoryGetPayload<S['select'][P]> :  P extends keyof ClosureRegionCategory ? ClosureRegionCategory[P] : never
  } 
      : ClosureRegionCategory


  type ClosureRegionCategoryCountArgs = Merge<
    Omit<ClosureRegionCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ClosureRegionCategoryCountAggregateInputType | true
    }
  >

  export interface ClosureRegionCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ClosureRegionCategory that matches the filter.
     * @param {ClosureRegionCategoryFindUniqueArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClosureRegionCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClosureRegionCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClosureRegionCategory'> extends True ? Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>> : Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T> | null, null>

    /**
     * Find one ClosureRegionCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClosureRegionCategoryFindUniqueOrThrowArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClosureRegionCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClosureRegionCategoryFindUniqueOrThrowArgs>
    ): Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>>

    /**
     * Find the first ClosureRegionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryFindFirstArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClosureRegionCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClosureRegionCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClosureRegionCategory'> extends True ? Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>> : Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T> | null, null>

    /**
     * Find the first ClosureRegionCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryFindFirstOrThrowArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClosureRegionCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClosureRegionCategoryFindFirstOrThrowArgs>
    ): Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>>

    /**
     * Find zero or more ClosureRegionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClosureRegionCategories
     * const closureRegionCategories = await prisma.closureRegionCategory.findMany()
     * 
     * // Get first 10 ClosureRegionCategories
     * const closureRegionCategories = await prisma.closureRegionCategory.findMany({ take: 10 })
     * 
     * // Only select the `ancestor`
     * const closureRegionCategoryWithAncestorOnly = await prisma.closureRegionCategory.findMany({ select: { ancestor: true } })
     * 
    **/
    findMany<T extends ClosureRegionCategoryFindManyArgs>(
      args?: SelectSubset<T, ClosureRegionCategoryFindManyArgs>
    ): PrismaPromise<Array<ClosureRegionCategoryGetPayload<T>>>

    /**
     * Create a ClosureRegionCategory.
     * @param {ClosureRegionCategoryCreateArgs} args - Arguments to create a ClosureRegionCategory.
     * @example
     * // Create one ClosureRegionCategory
     * const ClosureRegionCategory = await prisma.closureRegionCategory.create({
     *   data: {
     *     // ... data to create a ClosureRegionCategory
     *   }
     * })
     * 
    **/
    create<T extends ClosureRegionCategoryCreateArgs>(
      args: SelectSubset<T, ClosureRegionCategoryCreateArgs>
    ): Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>>

    /**
     * Create many ClosureRegionCategories.
     *     @param {ClosureRegionCategoryCreateManyArgs} args - Arguments to create many ClosureRegionCategories.
     *     @example
     *     // Create many ClosureRegionCategories
     *     const closureRegionCategory = await prisma.closureRegionCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClosureRegionCategoryCreateManyArgs>(
      args?: SelectSubset<T, ClosureRegionCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ClosureRegionCategory.
     * @param {ClosureRegionCategoryDeleteArgs} args - Arguments to delete one ClosureRegionCategory.
     * @example
     * // Delete one ClosureRegionCategory
     * const ClosureRegionCategory = await prisma.closureRegionCategory.delete({
     *   where: {
     *     // ... filter to delete one ClosureRegionCategory
     *   }
     * })
     * 
    **/
    delete<T extends ClosureRegionCategoryDeleteArgs>(
      args: SelectSubset<T, ClosureRegionCategoryDeleteArgs>
    ): Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>>

    /**
     * Update one ClosureRegionCategory.
     * @param {ClosureRegionCategoryUpdateArgs} args - Arguments to update one ClosureRegionCategory.
     * @example
     * // Update one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClosureRegionCategoryUpdateArgs>(
      args: SelectSubset<T, ClosureRegionCategoryUpdateArgs>
    ): Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>>

    /**
     * Delete zero or more ClosureRegionCategories.
     * @param {ClosureRegionCategoryDeleteManyArgs} args - Arguments to filter ClosureRegionCategories to delete.
     * @example
     * // Delete a few ClosureRegionCategories
     * const { count } = await prisma.closureRegionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClosureRegionCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ClosureRegionCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClosureRegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClosureRegionCategories
     * const closureRegionCategory = await prisma.closureRegionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClosureRegionCategoryUpdateManyArgs>(
      args: SelectSubset<T, ClosureRegionCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ClosureRegionCategory.
     * @param {ClosureRegionCategoryUpsertArgs} args - Arguments to update or create a ClosureRegionCategory.
     * @example
     * // Update or create a ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.upsert({
     *   create: {
     *     // ... data to create a ClosureRegionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClosureRegionCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ClosureRegionCategoryUpsertArgs>(
      args: SelectSubset<T, ClosureRegionCategoryUpsertArgs>
    ): Prisma__ClosureRegionCategoryClient<ClosureRegionCategoryGetPayload<T>>

    /**
     * Count the number of ClosureRegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryCountArgs} args - Arguments to filter ClosureRegionCategories to count.
     * @example
     * // Count the number of ClosureRegionCategories
     * const count = await prisma.closureRegionCategory.count({
     *   where: {
     *     // ... the filter for the ClosureRegionCategories we want to count
     *   }
     * })
    **/
    count<T extends ClosureRegionCategoryCountArgs>(
      args?: Subset<T, ClosureRegionCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClosureRegionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClosureRegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClosureRegionCategoryAggregateArgs>(args: Subset<T, ClosureRegionCategoryAggregateArgs>): PrismaPromise<GetClosureRegionCategoryAggregateType<T>>

    /**
     * Group by ClosureRegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClosureRegionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClosureRegionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ClosureRegionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClosureRegionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosureRegionCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClosureRegionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClosureRegionCategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AncestorCategory<T extends RegionCategoryArgs= {}>(args?: Subset<T, RegionCategoryArgs>): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T> | Null>;

    DescendantCategory<T extends RegionCategoryArgs= {}>(args?: Subset<T, RegionCategoryArgs>): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClosureRegionCategory base type for findUnique actions
   */
  export type ClosureRegionCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     * 
    **/
    where: ClosureRegionCategoryWhereUniqueInput
  }

  /**
   * ClosureRegionCategory: findUnique
   */
  export interface ClosureRegionCategoryFindUniqueArgs extends ClosureRegionCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClosureRegionCategory findUniqueOrThrow
   */
  export type ClosureRegionCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     * 
    **/
    where: ClosureRegionCategoryWhereUniqueInput
  }


  /**
   * ClosureRegionCategory base type for findFirst actions
   */
  export type ClosureRegionCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     * 
    **/
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureRegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureRegionCategories.
     * 
    **/
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureRegionCategories.
     * 
    **/
    distinct?: Enumerable<ClosureRegionCategoryScalarFieldEnum>
  }

  /**
   * ClosureRegionCategory: findFirst
   */
  export interface ClosureRegionCategoryFindFirstArgs extends ClosureRegionCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClosureRegionCategory findFirstOrThrow
   */
  export type ClosureRegionCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     * 
    **/
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureRegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureRegionCategories.
     * 
    **/
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureRegionCategories.
     * 
    **/
    distinct?: Enumerable<ClosureRegionCategoryScalarFieldEnum>
  }


  /**
   * ClosureRegionCategory findMany
   */
  export type ClosureRegionCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * Filter, which ClosureRegionCategories to fetch.
     * 
    **/
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureRegionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClosureRegionCategories.
     * 
    **/
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClosureRegionCategoryScalarFieldEnum>
  }


  /**
   * ClosureRegionCategory create
   */
  export type ClosureRegionCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * The data needed to create a ClosureRegionCategory.
     * 
    **/
    data: XOR<ClosureRegionCategoryCreateInput, ClosureRegionCategoryUncheckedCreateInput>
  }


  /**
   * ClosureRegionCategory createMany
   */
  export type ClosureRegionCategoryCreateManyArgs = {
    /**
     * The data used to create many ClosureRegionCategories.
     * 
    **/
    data: Enumerable<ClosureRegionCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ClosureRegionCategory update
   */
  export type ClosureRegionCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * The data needed to update a ClosureRegionCategory.
     * 
    **/
    data: XOR<ClosureRegionCategoryUpdateInput, ClosureRegionCategoryUncheckedUpdateInput>
    /**
     * Choose, which ClosureRegionCategory to update.
     * 
    **/
    where: ClosureRegionCategoryWhereUniqueInput
  }


  /**
   * ClosureRegionCategory updateMany
   */
  export type ClosureRegionCategoryUpdateManyArgs = {
    /**
     * The data used to update ClosureRegionCategories.
     * 
    **/
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ClosureRegionCategories to update
     * 
    **/
    where?: ClosureRegionCategoryWhereInput
  }


  /**
   * ClosureRegionCategory upsert
   */
  export type ClosureRegionCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * The filter to search for the ClosureRegionCategory to update in case it exists.
     * 
    **/
    where: ClosureRegionCategoryWhereUniqueInput
    /**
     * In case the ClosureRegionCategory found by the `where` argument doesn't exist, create a new ClosureRegionCategory with this data.
     * 
    **/
    create: XOR<ClosureRegionCategoryCreateInput, ClosureRegionCategoryUncheckedCreateInput>
    /**
     * In case the ClosureRegionCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClosureRegionCategoryUpdateInput, ClosureRegionCategoryUncheckedUpdateInput>
  }


  /**
   * ClosureRegionCategory delete
   */
  export type ClosureRegionCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
    /**
     * Filter which ClosureRegionCategory to delete.
     * 
    **/
    where: ClosureRegionCategoryWhereUniqueInput
  }


  /**
   * ClosureRegionCategory deleteMany
   */
  export type ClosureRegionCategoryDeleteManyArgs = {
    /**
     * Filter which ClosureRegionCategories to delete
     * 
    **/
    where?: ClosureRegionCategoryWhereInput
  }


  /**
   * ClosureRegionCategory without action
   */
  export type ClosureRegionCategoryArgs = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     * 
    **/
    select?: ClosureRegionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureRegionCategoryInclude | null
  }



  /**
   * Model CafeInfo
   */


  export type AggregateCafeInfo = {
    _count: CafeInfoCountAggregateOutputType | null
    _avg: CafeInfoAvgAggregateOutputType | null
    _sum: CafeInfoSumAggregateOutputType | null
    _min: CafeInfoMinAggregateOutputType | null
    _max: CafeInfoMaxAggregateOutputType | null
  }

  export type CafeInfoAvgAggregateOutputType = {
    id: number | null
    regionCategoryId: number | null
  }

  export type CafeInfoSumAggregateOutputType = {
    id: number | null
    regionCategoryId: number | null
  }

  export type CafeInfoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDisable: boolean | null
    name: string | null
    code: string | null
    regionCategoryId: number | null
    address: string | null
    directions: string | null
    businessNumber: string | null
    ceoName: string | null
  }

  export type CafeInfoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDisable: boolean | null
    name: string | null
    code: string | null
    regionCategoryId: number | null
    address: string | null
    directions: string | null
    businessNumber: string | null
    ceoName: string | null
  }

  export type CafeInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    isDisable: number
    name: number
    code: number
    regionCategoryId: number
    address: number
    directions: number
    businessNumber: number
    ceoName: number
    _all: number
  }


  export type CafeInfoAvgAggregateInputType = {
    id?: true
    regionCategoryId?: true
  }

  export type CafeInfoSumAggregateInputType = {
    id?: true
    regionCategoryId?: true
  }

  export type CafeInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDisable?: true
    name?: true
    code?: true
    regionCategoryId?: true
    address?: true
    directions?: true
    businessNumber?: true
    ceoName?: true
  }

  export type CafeInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDisable?: true
    name?: true
    code?: true
    regionCategoryId?: true
    address?: true
    directions?: true
    businessNumber?: true
    ceoName?: true
  }

  export type CafeInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDisable?: true
    name?: true
    code?: true
    regionCategoryId?: true
    address?: true
    directions?: true
    businessNumber?: true
    ceoName?: true
    _all?: true
  }

  export type CafeInfoAggregateArgs = {
    /**
     * Filter which CafeInfo to aggregate.
     * 
    **/
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeInfos
    **/
    _count?: true | CafeInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeInfoMaxAggregateInputType
  }

  export type GetCafeInfoAggregateType<T extends CafeInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeInfo[P]>
      : GetScalarType<T[P], AggregateCafeInfo[P]>
  }




  export type CafeInfoGroupByArgs = {
    where?: CafeInfoWhereInput
    orderBy?: Enumerable<CafeInfoOrderByWithAggregationInput>
    by: Array<CafeInfoScalarFieldEnum>
    having?: CafeInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeInfoCountAggregateInputType | true
    _avg?: CafeInfoAvgAggregateInputType
    _sum?: CafeInfoSumAggregateInputType
    _min?: CafeInfoMinAggregateInputType
    _max?: CafeInfoMaxAggregateInputType
  }


  export type CafeInfoGroupByOutputType = {
    id: number
    createdAt: Date
    isDisable: boolean
    name: string
    code: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    _count: CafeInfoCountAggregateOutputType | null
    _avg: CafeInfoAvgAggregateOutputType | null
    _sum: CafeInfoSumAggregateOutputType | null
    _min: CafeInfoMinAggregateOutputType | null
    _max: CafeInfoMaxAggregateOutputType | null
  }

  type GetCafeInfoGroupByPayload<T extends CafeInfoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeInfoGroupByOutputType[P]>
            : GetScalarType<T[P], CafeInfoGroupByOutputType[P]>
        }
      >
    >


  export type CafeInfoSelect = {
    id?: boolean
    createdAt?: boolean
    isDisable?: boolean
    name?: boolean
    code?: boolean
    regionCategoryId?: boolean
    RegionCategory?: boolean | RegionCategoryArgs
    address?: boolean
    directions?: boolean
    businessNumber?: boolean
    ceoName?: boolean
    CafeVirtualLinks?: boolean | CafeVirtualLinkFindManyArgs
    CafeThumbnailImages?: boolean | CafeThumbnailImageFindManyArgs
    CafeVirtualImages?: boolean | CafeVirtualImageFindManyArgs
    CafeRealImages?: boolean | CafeRealImageFindManyArgs
    CafeCouponGroupPartners?: boolean | CafeCouponGoupPartnerFindManyArgs
    CafeBoards?: boolean | CafeBoardFindManyArgs
    MetaViewerInfos?: boolean | MetaViewerInfoFindManyArgs
    Products?: boolean | ProductFindManyArgs
    _count?: boolean | CafeInfoCountOutputTypeArgs
  }


  export type CafeInfoInclude = {
    RegionCategory?: boolean | RegionCategoryArgs
    CafeVirtualLinks?: boolean | CafeVirtualLinkFindManyArgs
    CafeThumbnailImages?: boolean | CafeThumbnailImageFindManyArgs
    CafeVirtualImages?: boolean | CafeVirtualImageFindManyArgs
    CafeRealImages?: boolean | CafeRealImageFindManyArgs
    CafeCouponGroupPartners?: boolean | CafeCouponGoupPartnerFindManyArgs
    CafeBoards?: boolean | CafeBoardFindManyArgs
    MetaViewerInfos?: boolean | MetaViewerInfoFindManyArgs
    Products?: boolean | ProductFindManyArgs
    _count?: boolean | CafeInfoCountOutputTypeArgs
  } 

  export type CafeInfoGetPayload<S extends boolean | null | undefined | CafeInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeInfo :
    S extends undefined ? never :
    S extends { include: any } & (CafeInfoArgs | CafeInfoFindManyArgs)
    ? CafeInfo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'RegionCategory' ? RegionCategoryGetPayload<S['include'][P]> :
        P extends 'CafeVirtualLinks' ? Array < CafeVirtualLinkGetPayload<S['include'][P]>>  :
        P extends 'CafeThumbnailImages' ? Array < CafeThumbnailImageGetPayload<S['include'][P]>>  :
        P extends 'CafeVirtualImages' ? Array < CafeVirtualImageGetPayload<S['include'][P]>>  :
        P extends 'CafeRealImages' ? Array < CafeRealImageGetPayload<S['include'][P]>>  :
        P extends 'CafeCouponGroupPartners' ? Array < CafeCouponGoupPartnerGetPayload<S['include'][P]>>  :
        P extends 'CafeBoards' ? Array < CafeBoardGetPayload<S['include'][P]>>  :
        P extends 'MetaViewerInfos' ? Array < MetaViewerInfoGetPayload<S['include'][P]>>  :
        P extends 'Products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? CafeInfoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeInfoArgs | CafeInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'RegionCategory' ? RegionCategoryGetPayload<S['select'][P]> :
        P extends 'CafeVirtualLinks' ? Array < CafeVirtualLinkGetPayload<S['select'][P]>>  :
        P extends 'CafeThumbnailImages' ? Array < CafeThumbnailImageGetPayload<S['select'][P]>>  :
        P extends 'CafeVirtualImages' ? Array < CafeVirtualImageGetPayload<S['select'][P]>>  :
        P extends 'CafeRealImages' ? Array < CafeRealImageGetPayload<S['select'][P]>>  :
        P extends 'CafeCouponGroupPartners' ? Array < CafeCouponGoupPartnerGetPayload<S['select'][P]>>  :
        P extends 'CafeBoards' ? Array < CafeBoardGetPayload<S['select'][P]>>  :
        P extends 'MetaViewerInfos' ? Array < MetaViewerInfoGetPayload<S['select'][P]>>  :
        P extends 'Products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? CafeInfoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CafeInfo ? CafeInfo[P] : never
  } 
      : CafeInfo


  type CafeInfoCountArgs = Merge<
    Omit<CafeInfoFindManyArgs, 'select' | 'include'> & {
      select?: CafeInfoCountAggregateInputType | true
    }
  >

  export interface CafeInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeInfo that matches the filter.
     * @param {CafeInfoFindUniqueArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeInfo'> extends True ? Prisma__CafeInfoClient<CafeInfoGetPayload<T>> : Prisma__CafeInfoClient<CafeInfoGetPayload<T> | null, null>

    /**
     * Find one CafeInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeInfoFindUniqueOrThrowArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeInfoFindUniqueOrThrowArgs>
    ): Prisma__CafeInfoClient<CafeInfoGetPayload<T>>

    /**
     * Find the first CafeInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoFindFirstArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeInfo'> extends True ? Prisma__CafeInfoClient<CafeInfoGetPayload<T>> : Prisma__CafeInfoClient<CafeInfoGetPayload<T> | null, null>

    /**
     * Find the first CafeInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoFindFirstOrThrowArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeInfoFindFirstOrThrowArgs>
    ): Prisma__CafeInfoClient<CafeInfoGetPayload<T>>

    /**
     * Find zero or more CafeInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeInfos
     * const cafeInfos = await prisma.cafeInfo.findMany()
     * 
     * // Get first 10 CafeInfos
     * const cafeInfos = await prisma.cafeInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeInfoWithIdOnly = await prisma.cafeInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeInfoFindManyArgs>(
      args?: SelectSubset<T, CafeInfoFindManyArgs>
    ): PrismaPromise<Array<CafeInfoGetPayload<T>>>

    /**
     * Create a CafeInfo.
     * @param {CafeInfoCreateArgs} args - Arguments to create a CafeInfo.
     * @example
     * // Create one CafeInfo
     * const CafeInfo = await prisma.cafeInfo.create({
     *   data: {
     *     // ... data to create a CafeInfo
     *   }
     * })
     * 
    **/
    create<T extends CafeInfoCreateArgs>(
      args: SelectSubset<T, CafeInfoCreateArgs>
    ): Prisma__CafeInfoClient<CafeInfoGetPayload<T>>

    /**
     * Create many CafeInfos.
     *     @param {CafeInfoCreateManyArgs} args - Arguments to create many CafeInfos.
     *     @example
     *     // Create many CafeInfos
     *     const cafeInfo = await prisma.cafeInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeInfoCreateManyArgs>(
      args?: SelectSubset<T, CafeInfoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeInfo.
     * @param {CafeInfoDeleteArgs} args - Arguments to delete one CafeInfo.
     * @example
     * // Delete one CafeInfo
     * const CafeInfo = await prisma.cafeInfo.delete({
     *   where: {
     *     // ... filter to delete one CafeInfo
     *   }
     * })
     * 
    **/
    delete<T extends CafeInfoDeleteArgs>(
      args: SelectSubset<T, CafeInfoDeleteArgs>
    ): Prisma__CafeInfoClient<CafeInfoGetPayload<T>>

    /**
     * Update one CafeInfo.
     * @param {CafeInfoUpdateArgs} args - Arguments to update one CafeInfo.
     * @example
     * // Update one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeInfoUpdateArgs>(
      args: SelectSubset<T, CafeInfoUpdateArgs>
    ): Prisma__CafeInfoClient<CafeInfoGetPayload<T>>

    /**
     * Delete zero or more CafeInfos.
     * @param {CafeInfoDeleteManyArgs} args - Arguments to filter CafeInfos to delete.
     * @example
     * // Delete a few CafeInfos
     * const { count } = await prisma.cafeInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeInfoDeleteManyArgs>(
      args?: SelectSubset<T, CafeInfoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeInfos
     * const cafeInfo = await prisma.cafeInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeInfoUpdateManyArgs>(
      args: SelectSubset<T, CafeInfoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeInfo.
     * @param {CafeInfoUpsertArgs} args - Arguments to update or create a CafeInfo.
     * @example
     * // Update or create a CafeInfo
     * const cafeInfo = await prisma.cafeInfo.upsert({
     *   create: {
     *     // ... data to create a CafeInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeInfo we want to update
     *   }
     * })
    **/
    upsert<T extends CafeInfoUpsertArgs>(
      args: SelectSubset<T, CafeInfoUpsertArgs>
    ): Prisma__CafeInfoClient<CafeInfoGetPayload<T>>

    /**
     * Count the number of CafeInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoCountArgs} args - Arguments to filter CafeInfos to count.
     * @example
     * // Count the number of CafeInfos
     * const count = await prisma.cafeInfo.count({
     *   where: {
     *     // ... the filter for the CafeInfos we want to count
     *   }
     * })
    **/
    count<T extends CafeInfoCountArgs>(
      args?: Subset<T, CafeInfoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeInfoAggregateArgs>(args: Subset<T, CafeInfoAggregateArgs>): PrismaPromise<GetCafeInfoAggregateType<T>>

    /**
     * Group by CafeInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeInfoGroupByArgs['orderBy'] }
        : { orderBy?: CafeInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeInfoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeInfoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RegionCategory<T extends RegionCategoryArgs= {}>(args?: Subset<T, RegionCategoryArgs>): Prisma__RegionCategoryClient<RegionCategoryGetPayload<T> | Null>;

    CafeVirtualLinks<T extends CafeVirtualLinkFindManyArgs= {}>(args?: Subset<T, CafeVirtualLinkFindManyArgs>): PrismaPromise<Array<CafeVirtualLinkGetPayload<T>>| Null>;

    CafeThumbnailImages<T extends CafeThumbnailImageFindManyArgs= {}>(args?: Subset<T, CafeThumbnailImageFindManyArgs>): PrismaPromise<Array<CafeThumbnailImageGetPayload<T>>| Null>;

    CafeVirtualImages<T extends CafeVirtualImageFindManyArgs= {}>(args?: Subset<T, CafeVirtualImageFindManyArgs>): PrismaPromise<Array<CafeVirtualImageGetPayload<T>>| Null>;

    CafeRealImages<T extends CafeRealImageFindManyArgs= {}>(args?: Subset<T, CafeRealImageFindManyArgs>): PrismaPromise<Array<CafeRealImageGetPayload<T>>| Null>;

    CafeCouponGroupPartners<T extends CafeCouponGoupPartnerFindManyArgs= {}>(args?: Subset<T, CafeCouponGoupPartnerFindManyArgs>): PrismaPromise<Array<CafeCouponGoupPartnerGetPayload<T>>| Null>;

    CafeBoards<T extends CafeBoardFindManyArgs= {}>(args?: Subset<T, CafeBoardFindManyArgs>): PrismaPromise<Array<CafeBoardGetPayload<T>>| Null>;

    MetaViewerInfos<T extends MetaViewerInfoFindManyArgs= {}>(args?: Subset<T, MetaViewerInfoFindManyArgs>): PrismaPromise<Array<MetaViewerInfoGetPayload<T>>| Null>;

    Products<T extends ProductFindManyArgs= {}>(args?: Subset<T, ProductFindManyArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeInfo base type for findUnique actions
   */
  export type CafeInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * Filter, which CafeInfo to fetch.
     * 
    **/
    where: CafeInfoWhereUniqueInput
  }

  /**
   * CafeInfo: findUnique
   */
  export interface CafeInfoFindUniqueArgs extends CafeInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeInfo findUniqueOrThrow
   */
  export type CafeInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * Filter, which CafeInfo to fetch.
     * 
    **/
    where: CafeInfoWhereUniqueInput
  }


  /**
   * CafeInfo base type for findFirst actions
   */
  export type CafeInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * Filter, which CafeInfo to fetch.
     * 
    **/
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeInfos.
     * 
    **/
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeInfos.
     * 
    **/
    distinct?: Enumerable<CafeInfoScalarFieldEnum>
  }

  /**
   * CafeInfo: findFirst
   */
  export interface CafeInfoFindFirstArgs extends CafeInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeInfo findFirstOrThrow
   */
  export type CafeInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * Filter, which CafeInfo to fetch.
     * 
    **/
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeInfos.
     * 
    **/
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeInfos.
     * 
    **/
    distinct?: Enumerable<CafeInfoScalarFieldEnum>
  }


  /**
   * CafeInfo findMany
   */
  export type CafeInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * Filter, which CafeInfos to fetch.
     * 
    **/
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeInfos.
     * 
    **/
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeInfoScalarFieldEnum>
  }


  /**
   * CafeInfo create
   */
  export type CafeInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * The data needed to create a CafeInfo.
     * 
    **/
    data: XOR<CafeInfoCreateInput, CafeInfoUncheckedCreateInput>
  }


  /**
   * CafeInfo createMany
   */
  export type CafeInfoCreateManyArgs = {
    /**
     * The data used to create many CafeInfos.
     * 
    **/
    data: Enumerable<CafeInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeInfo update
   */
  export type CafeInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * The data needed to update a CafeInfo.
     * 
    **/
    data: XOR<CafeInfoUpdateInput, CafeInfoUncheckedUpdateInput>
    /**
     * Choose, which CafeInfo to update.
     * 
    **/
    where: CafeInfoWhereUniqueInput
  }


  /**
   * CafeInfo updateMany
   */
  export type CafeInfoUpdateManyArgs = {
    /**
     * The data used to update CafeInfos.
     * 
    **/
    data: XOR<CafeInfoUpdateManyMutationInput, CafeInfoUncheckedUpdateManyInput>
    /**
     * Filter which CafeInfos to update
     * 
    **/
    where?: CafeInfoWhereInput
  }


  /**
   * CafeInfo upsert
   */
  export type CafeInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * The filter to search for the CafeInfo to update in case it exists.
     * 
    **/
    where: CafeInfoWhereUniqueInput
    /**
     * In case the CafeInfo found by the `where` argument doesn't exist, create a new CafeInfo with this data.
     * 
    **/
    create: XOR<CafeInfoCreateInput, CafeInfoUncheckedCreateInput>
    /**
     * In case the CafeInfo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeInfoUpdateInput, CafeInfoUncheckedUpdateInput>
  }


  /**
   * CafeInfo delete
   */
  export type CafeInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
    /**
     * Filter which CafeInfo to delete.
     * 
    **/
    where: CafeInfoWhereUniqueInput
  }


  /**
   * CafeInfo deleteMany
   */
  export type CafeInfoDeleteManyArgs = {
    /**
     * Filter which CafeInfos to delete
     * 
    **/
    where?: CafeInfoWhereInput
  }


  /**
   * CafeInfo without action
   */
  export type CafeInfoArgs = {
    /**
     * Select specific fields to fetch from the CafeInfo
     * 
    **/
    select?: CafeInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeInfoInclude | null
  }



  /**
   * Model CafeThumbnailImage
   */


  export type AggregateCafeThumbnailImage = {
    _count: CafeThumbnailImageCountAggregateOutputType | null
    _avg: CafeThumbnailImageAvgAggregateOutputType | null
    _sum: CafeThumbnailImageSumAggregateOutputType | null
    _min: CafeThumbnailImageMinAggregateOutputType | null
    _max: CafeThumbnailImageMaxAggregateOutputType | null
  }

  export type CafeThumbnailImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    thumbnailUrl: number
    width: number
    height: number
    size: number
    priority: number
    isDisable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeThumbnailImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeThumbnailImageAggregateArgs = {
    /**
     * Filter which CafeThumbnailImage to aggregate.
     * 
    **/
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeThumbnailImages
    **/
    _count?: true | CafeThumbnailImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeThumbnailImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeThumbnailImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeThumbnailImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeThumbnailImageMaxAggregateInputType
  }

  export type GetCafeThumbnailImageAggregateType<T extends CafeThumbnailImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeThumbnailImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeThumbnailImage[P]>
      : GetScalarType<T[P], AggregateCafeThumbnailImage[P]>
  }




  export type CafeThumbnailImageGroupByArgs = {
    where?: CafeThumbnailImageWhereInput
    orderBy?: Enumerable<CafeThumbnailImageOrderByWithAggregationInput>
    by: Array<CafeThumbnailImageScalarFieldEnum>
    having?: CafeThumbnailImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeThumbnailImageCountAggregateInputType | true
    _avg?: CafeThumbnailImageAvgAggregateInputType
    _sum?: CafeThumbnailImageSumAggregateInputType
    _min?: CafeThumbnailImageMinAggregateInputType
    _max?: CafeThumbnailImageMaxAggregateInputType
  }


  export type CafeThumbnailImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority: number
    isDisable: boolean
    cafeInfoId: number
    _count: CafeThumbnailImageCountAggregateOutputType | null
    _avg: CafeThumbnailImageAvgAggregateOutputType | null
    _sum: CafeThumbnailImageSumAggregateOutputType | null
    _min: CafeThumbnailImageMinAggregateOutputType | null
    _max: CafeThumbnailImageMaxAggregateOutputType | null
  }

  type GetCafeThumbnailImageGroupByPayload<T extends CafeThumbnailImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeThumbnailImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeThumbnailImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeThumbnailImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeThumbnailImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeThumbnailImageSelect = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
  }


  export type CafeThumbnailImageInclude = {
    CafeInfo?: boolean | CafeInfoArgs
  } 

  export type CafeThumbnailImageGetPayload<S extends boolean | null | undefined | CafeThumbnailImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeThumbnailImage :
    S extends undefined ? never :
    S extends { include: any } & (CafeThumbnailImageArgs | CafeThumbnailImageFindManyArgs)
    ? CafeThumbnailImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeThumbnailImageArgs | CafeThumbnailImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :  P extends keyof CafeThumbnailImage ? CafeThumbnailImage[P] : never
  } 
      : CafeThumbnailImage


  type CafeThumbnailImageCountArgs = Merge<
    Omit<CafeThumbnailImageFindManyArgs, 'select' | 'include'> & {
      select?: CafeThumbnailImageCountAggregateInputType | true
    }
  >

  export interface CafeThumbnailImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeThumbnailImage that matches the filter.
     * @param {CafeThumbnailImageFindUniqueArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeThumbnailImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeThumbnailImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeThumbnailImage'> extends True ? Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>> : Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T> | null, null>

    /**
     * Find one CafeThumbnailImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeThumbnailImageFindUniqueOrThrowArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeThumbnailImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeThumbnailImageFindUniqueOrThrowArgs>
    ): Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>>

    /**
     * Find the first CafeThumbnailImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageFindFirstArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeThumbnailImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeThumbnailImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeThumbnailImage'> extends True ? Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>> : Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T> | null, null>

    /**
     * Find the first CafeThumbnailImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageFindFirstOrThrowArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeThumbnailImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeThumbnailImageFindFirstOrThrowArgs>
    ): Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>>

    /**
     * Find zero or more CafeThumbnailImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeThumbnailImages
     * const cafeThumbnailImages = await prisma.cafeThumbnailImage.findMany()
     * 
     * // Get first 10 CafeThumbnailImages
     * const cafeThumbnailImages = await prisma.cafeThumbnailImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeThumbnailImageWithIdOnly = await prisma.cafeThumbnailImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeThumbnailImageFindManyArgs>(
      args?: SelectSubset<T, CafeThumbnailImageFindManyArgs>
    ): PrismaPromise<Array<CafeThumbnailImageGetPayload<T>>>

    /**
     * Create a CafeThumbnailImage.
     * @param {CafeThumbnailImageCreateArgs} args - Arguments to create a CafeThumbnailImage.
     * @example
     * // Create one CafeThumbnailImage
     * const CafeThumbnailImage = await prisma.cafeThumbnailImage.create({
     *   data: {
     *     // ... data to create a CafeThumbnailImage
     *   }
     * })
     * 
    **/
    create<T extends CafeThumbnailImageCreateArgs>(
      args: SelectSubset<T, CafeThumbnailImageCreateArgs>
    ): Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>>

    /**
     * Create many CafeThumbnailImages.
     *     @param {CafeThumbnailImageCreateManyArgs} args - Arguments to create many CafeThumbnailImages.
     *     @example
     *     // Create many CafeThumbnailImages
     *     const cafeThumbnailImage = await prisma.cafeThumbnailImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeThumbnailImageCreateManyArgs>(
      args?: SelectSubset<T, CafeThumbnailImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeThumbnailImage.
     * @param {CafeThumbnailImageDeleteArgs} args - Arguments to delete one CafeThumbnailImage.
     * @example
     * // Delete one CafeThumbnailImage
     * const CafeThumbnailImage = await prisma.cafeThumbnailImage.delete({
     *   where: {
     *     // ... filter to delete one CafeThumbnailImage
     *   }
     * })
     * 
    **/
    delete<T extends CafeThumbnailImageDeleteArgs>(
      args: SelectSubset<T, CafeThumbnailImageDeleteArgs>
    ): Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>>

    /**
     * Update one CafeThumbnailImage.
     * @param {CafeThumbnailImageUpdateArgs} args - Arguments to update one CafeThumbnailImage.
     * @example
     * // Update one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeThumbnailImageUpdateArgs>(
      args: SelectSubset<T, CafeThumbnailImageUpdateArgs>
    ): Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>>

    /**
     * Delete zero or more CafeThumbnailImages.
     * @param {CafeThumbnailImageDeleteManyArgs} args - Arguments to filter CafeThumbnailImages to delete.
     * @example
     * // Delete a few CafeThumbnailImages
     * const { count } = await prisma.cafeThumbnailImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeThumbnailImageDeleteManyArgs>(
      args?: SelectSubset<T, CafeThumbnailImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeThumbnailImages
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeThumbnailImageUpdateManyArgs>(
      args: SelectSubset<T, CafeThumbnailImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeThumbnailImage.
     * @param {CafeThumbnailImageUpsertArgs} args - Arguments to update or create a CafeThumbnailImage.
     * @example
     * // Update or create a CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.upsert({
     *   create: {
     *     // ... data to create a CafeThumbnailImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeThumbnailImage we want to update
     *   }
     * })
    **/
    upsert<T extends CafeThumbnailImageUpsertArgs>(
      args: SelectSubset<T, CafeThumbnailImageUpsertArgs>
    ): Prisma__CafeThumbnailImageClient<CafeThumbnailImageGetPayload<T>>

    /**
     * Count the number of CafeThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageCountArgs} args - Arguments to filter CafeThumbnailImages to count.
     * @example
     * // Count the number of CafeThumbnailImages
     * const count = await prisma.cafeThumbnailImage.count({
     *   where: {
     *     // ... the filter for the CafeThumbnailImages we want to count
     *   }
     * })
    **/
    count<T extends CafeThumbnailImageCountArgs>(
      args?: Subset<T, CafeThumbnailImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeThumbnailImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeThumbnailImageAggregateArgs>(args: Subset<T, CafeThumbnailImageAggregateArgs>): PrismaPromise<GetCafeThumbnailImageAggregateType<T>>

    /**
     * Group by CafeThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeThumbnailImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeThumbnailImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeThumbnailImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeThumbnailImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeThumbnailImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeThumbnailImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeThumbnailImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeThumbnailImage base type for findUnique actions
   */
  export type CafeThumbnailImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     * 
    **/
    where: CafeThumbnailImageWhereUniqueInput
  }

  /**
   * CafeThumbnailImage: findUnique
   */
  export interface CafeThumbnailImageFindUniqueArgs extends CafeThumbnailImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeThumbnailImage findUniqueOrThrow
   */
  export type CafeThumbnailImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     * 
    **/
    where: CafeThumbnailImageWhereUniqueInput
  }


  /**
   * CafeThumbnailImage base type for findFirst actions
   */
  export type CafeThumbnailImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     * 
    **/
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeThumbnailImages.
     * 
    **/
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeThumbnailImages.
     * 
    **/
    distinct?: Enumerable<CafeThumbnailImageScalarFieldEnum>
  }

  /**
   * CafeThumbnailImage: findFirst
   */
  export interface CafeThumbnailImageFindFirstArgs extends CafeThumbnailImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeThumbnailImage findFirstOrThrow
   */
  export type CafeThumbnailImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     * 
    **/
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeThumbnailImages.
     * 
    **/
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeThumbnailImages.
     * 
    **/
    distinct?: Enumerable<CafeThumbnailImageScalarFieldEnum>
  }


  /**
   * CafeThumbnailImage findMany
   */
  export type CafeThumbnailImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * Filter, which CafeThumbnailImages to fetch.
     * 
    **/
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeThumbnailImages.
     * 
    **/
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeThumbnailImageScalarFieldEnum>
  }


  /**
   * CafeThumbnailImage create
   */
  export type CafeThumbnailImageCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * The data needed to create a CafeThumbnailImage.
     * 
    **/
    data: XOR<CafeThumbnailImageCreateInput, CafeThumbnailImageUncheckedCreateInput>
  }


  /**
   * CafeThumbnailImage createMany
   */
  export type CafeThumbnailImageCreateManyArgs = {
    /**
     * The data used to create many CafeThumbnailImages.
     * 
    **/
    data: Enumerable<CafeThumbnailImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeThumbnailImage update
   */
  export type CafeThumbnailImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * The data needed to update a CafeThumbnailImage.
     * 
    **/
    data: XOR<CafeThumbnailImageUpdateInput, CafeThumbnailImageUncheckedUpdateInput>
    /**
     * Choose, which CafeThumbnailImage to update.
     * 
    **/
    where: CafeThumbnailImageWhereUniqueInput
  }


  /**
   * CafeThumbnailImage updateMany
   */
  export type CafeThumbnailImageUpdateManyArgs = {
    /**
     * The data used to update CafeThumbnailImages.
     * 
    **/
    data: XOR<CafeThumbnailImageUpdateManyMutationInput, CafeThumbnailImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeThumbnailImages to update
     * 
    **/
    where?: CafeThumbnailImageWhereInput
  }


  /**
   * CafeThumbnailImage upsert
   */
  export type CafeThumbnailImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * The filter to search for the CafeThumbnailImage to update in case it exists.
     * 
    **/
    where: CafeThumbnailImageWhereUniqueInput
    /**
     * In case the CafeThumbnailImage found by the `where` argument doesn't exist, create a new CafeThumbnailImage with this data.
     * 
    **/
    create: XOR<CafeThumbnailImageCreateInput, CafeThumbnailImageUncheckedCreateInput>
    /**
     * In case the CafeThumbnailImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeThumbnailImageUpdateInput, CafeThumbnailImageUncheckedUpdateInput>
  }


  /**
   * CafeThumbnailImage delete
   */
  export type CafeThumbnailImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
    /**
     * Filter which CafeThumbnailImage to delete.
     * 
    **/
    where: CafeThumbnailImageWhereUniqueInput
  }


  /**
   * CafeThumbnailImage deleteMany
   */
  export type CafeThumbnailImageDeleteManyArgs = {
    /**
     * Filter which CafeThumbnailImages to delete
     * 
    **/
    where?: CafeThumbnailImageWhereInput
  }


  /**
   * CafeThumbnailImage without action
   */
  export type CafeThumbnailImageArgs = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     * 
    **/
    select?: CafeThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeThumbnailImageInclude | null
  }



  /**
   * Model CafeVirtualImage
   */


  export type AggregateCafeVirtualImage = {
    _count: CafeVirtualImageCountAggregateOutputType | null
    _avg: CafeVirtualImageAvgAggregateOutputType | null
    _sum: CafeVirtualImageSumAggregateOutputType | null
    _min: CafeVirtualImageMinAggregateOutputType | null
    _max: CafeVirtualImageMaxAggregateOutputType | null
  }

  export type CafeVirtualImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    width: number
    height: number
    size: number
    priority: number
    isDisable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeVirtualImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeVirtualImageAggregateArgs = {
    /**
     * Filter which CafeVirtualImage to aggregate.
     * 
    **/
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeVirtualImages
    **/
    _count?: true | CafeVirtualImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeVirtualImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeVirtualImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeVirtualImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeVirtualImageMaxAggregateInputType
  }

  export type GetCafeVirtualImageAggregateType<T extends CafeVirtualImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeVirtualImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeVirtualImage[P]>
      : GetScalarType<T[P], AggregateCafeVirtualImage[P]>
  }




  export type CafeVirtualImageGroupByArgs = {
    where?: CafeVirtualImageWhereInput
    orderBy?: Enumerable<CafeVirtualImageOrderByWithAggregationInput>
    by: Array<CafeVirtualImageScalarFieldEnum>
    having?: CafeVirtualImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeVirtualImageCountAggregateInputType | true
    _avg?: CafeVirtualImageAvgAggregateInputType
    _sum?: CafeVirtualImageSumAggregateInputType
    _min?: CafeVirtualImageMinAggregateInputType
    _max?: CafeVirtualImageMaxAggregateInputType
  }


  export type CafeVirtualImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    width: number
    height: number
    size: number
    priority: number
    isDisable: boolean
    cafeInfoId: number
    _count: CafeVirtualImageCountAggregateOutputType | null
    _avg: CafeVirtualImageAvgAggregateOutputType | null
    _sum: CafeVirtualImageSumAggregateOutputType | null
    _min: CafeVirtualImageMinAggregateOutputType | null
    _max: CafeVirtualImageMaxAggregateOutputType | null
  }

  type GetCafeVirtualImageGroupByPayload<T extends CafeVirtualImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeVirtualImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeVirtualImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeVirtualImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeVirtualImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeVirtualImageSelect = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
  }


  export type CafeVirtualImageInclude = {
    CafeInfo?: boolean | CafeInfoArgs
  } 

  export type CafeVirtualImageGetPayload<S extends boolean | null | undefined | CafeVirtualImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeVirtualImage :
    S extends undefined ? never :
    S extends { include: any } & (CafeVirtualImageArgs | CafeVirtualImageFindManyArgs)
    ? CafeVirtualImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeVirtualImageArgs | CafeVirtualImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :  P extends keyof CafeVirtualImage ? CafeVirtualImage[P] : never
  } 
      : CafeVirtualImage


  type CafeVirtualImageCountArgs = Merge<
    Omit<CafeVirtualImageFindManyArgs, 'select' | 'include'> & {
      select?: CafeVirtualImageCountAggregateInputType | true
    }
  >

  export interface CafeVirtualImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeVirtualImage that matches the filter.
     * @param {CafeVirtualImageFindUniqueArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeVirtualImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeVirtualImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeVirtualImage'> extends True ? Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>> : Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T> | null, null>

    /**
     * Find one CafeVirtualImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeVirtualImageFindUniqueOrThrowArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeVirtualImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeVirtualImageFindUniqueOrThrowArgs>
    ): Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>>

    /**
     * Find the first CafeVirtualImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageFindFirstArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeVirtualImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeVirtualImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeVirtualImage'> extends True ? Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>> : Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T> | null, null>

    /**
     * Find the first CafeVirtualImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageFindFirstOrThrowArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeVirtualImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeVirtualImageFindFirstOrThrowArgs>
    ): Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>>

    /**
     * Find zero or more CafeVirtualImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeVirtualImages
     * const cafeVirtualImages = await prisma.cafeVirtualImage.findMany()
     * 
     * // Get first 10 CafeVirtualImages
     * const cafeVirtualImages = await prisma.cafeVirtualImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeVirtualImageWithIdOnly = await prisma.cafeVirtualImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeVirtualImageFindManyArgs>(
      args?: SelectSubset<T, CafeVirtualImageFindManyArgs>
    ): PrismaPromise<Array<CafeVirtualImageGetPayload<T>>>

    /**
     * Create a CafeVirtualImage.
     * @param {CafeVirtualImageCreateArgs} args - Arguments to create a CafeVirtualImage.
     * @example
     * // Create one CafeVirtualImage
     * const CafeVirtualImage = await prisma.cafeVirtualImage.create({
     *   data: {
     *     // ... data to create a CafeVirtualImage
     *   }
     * })
     * 
    **/
    create<T extends CafeVirtualImageCreateArgs>(
      args: SelectSubset<T, CafeVirtualImageCreateArgs>
    ): Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>>

    /**
     * Create many CafeVirtualImages.
     *     @param {CafeVirtualImageCreateManyArgs} args - Arguments to create many CafeVirtualImages.
     *     @example
     *     // Create many CafeVirtualImages
     *     const cafeVirtualImage = await prisma.cafeVirtualImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeVirtualImageCreateManyArgs>(
      args?: SelectSubset<T, CafeVirtualImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeVirtualImage.
     * @param {CafeVirtualImageDeleteArgs} args - Arguments to delete one CafeVirtualImage.
     * @example
     * // Delete one CafeVirtualImage
     * const CafeVirtualImage = await prisma.cafeVirtualImage.delete({
     *   where: {
     *     // ... filter to delete one CafeVirtualImage
     *   }
     * })
     * 
    **/
    delete<T extends CafeVirtualImageDeleteArgs>(
      args: SelectSubset<T, CafeVirtualImageDeleteArgs>
    ): Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>>

    /**
     * Update one CafeVirtualImage.
     * @param {CafeVirtualImageUpdateArgs} args - Arguments to update one CafeVirtualImage.
     * @example
     * // Update one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeVirtualImageUpdateArgs>(
      args: SelectSubset<T, CafeVirtualImageUpdateArgs>
    ): Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>>

    /**
     * Delete zero or more CafeVirtualImages.
     * @param {CafeVirtualImageDeleteManyArgs} args - Arguments to filter CafeVirtualImages to delete.
     * @example
     * // Delete a few CafeVirtualImages
     * const { count } = await prisma.cafeVirtualImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeVirtualImageDeleteManyArgs>(
      args?: SelectSubset<T, CafeVirtualImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeVirtualImages
     * const cafeVirtualImage = await prisma.cafeVirtualImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeVirtualImageUpdateManyArgs>(
      args: SelectSubset<T, CafeVirtualImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeVirtualImage.
     * @param {CafeVirtualImageUpsertArgs} args - Arguments to update or create a CafeVirtualImage.
     * @example
     * // Update or create a CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.upsert({
     *   create: {
     *     // ... data to create a CafeVirtualImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeVirtualImage we want to update
     *   }
     * })
    **/
    upsert<T extends CafeVirtualImageUpsertArgs>(
      args: SelectSubset<T, CafeVirtualImageUpsertArgs>
    ): Prisma__CafeVirtualImageClient<CafeVirtualImageGetPayload<T>>

    /**
     * Count the number of CafeVirtualImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageCountArgs} args - Arguments to filter CafeVirtualImages to count.
     * @example
     * // Count the number of CafeVirtualImages
     * const count = await prisma.cafeVirtualImage.count({
     *   where: {
     *     // ... the filter for the CafeVirtualImages we want to count
     *   }
     * })
    **/
    count<T extends CafeVirtualImageCountArgs>(
      args?: Subset<T, CafeVirtualImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeVirtualImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeVirtualImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeVirtualImageAggregateArgs>(args: Subset<T, CafeVirtualImageAggregateArgs>): PrismaPromise<GetCafeVirtualImageAggregateType<T>>

    /**
     * Group by CafeVirtualImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeVirtualImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeVirtualImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeVirtualImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeVirtualImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeVirtualImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeVirtualImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeVirtualImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeVirtualImage base type for findUnique actions
   */
  export type CafeVirtualImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     * 
    **/
    where: CafeVirtualImageWhereUniqueInput
  }

  /**
   * CafeVirtualImage: findUnique
   */
  export interface CafeVirtualImageFindUniqueArgs extends CafeVirtualImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeVirtualImage findUniqueOrThrow
   */
  export type CafeVirtualImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     * 
    **/
    where: CafeVirtualImageWhereUniqueInput
  }


  /**
   * CafeVirtualImage base type for findFirst actions
   */
  export type CafeVirtualImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     * 
    **/
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualImages.
     * 
    **/
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualImages.
     * 
    **/
    distinct?: Enumerable<CafeVirtualImageScalarFieldEnum>
  }

  /**
   * CafeVirtualImage: findFirst
   */
  export interface CafeVirtualImageFindFirstArgs extends CafeVirtualImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeVirtualImage findFirstOrThrow
   */
  export type CafeVirtualImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     * 
    **/
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualImages.
     * 
    **/
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualImages.
     * 
    **/
    distinct?: Enumerable<CafeVirtualImageScalarFieldEnum>
  }


  /**
   * CafeVirtualImage findMany
   */
  export type CafeVirtualImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * Filter, which CafeVirtualImages to fetch.
     * 
    **/
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeVirtualImages.
     * 
    **/
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeVirtualImageScalarFieldEnum>
  }


  /**
   * CafeVirtualImage create
   */
  export type CafeVirtualImageCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * The data needed to create a CafeVirtualImage.
     * 
    **/
    data: XOR<CafeVirtualImageCreateInput, CafeVirtualImageUncheckedCreateInput>
  }


  /**
   * CafeVirtualImage createMany
   */
  export type CafeVirtualImageCreateManyArgs = {
    /**
     * The data used to create many CafeVirtualImages.
     * 
    **/
    data: Enumerable<CafeVirtualImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeVirtualImage update
   */
  export type CafeVirtualImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * The data needed to update a CafeVirtualImage.
     * 
    **/
    data: XOR<CafeVirtualImageUpdateInput, CafeVirtualImageUncheckedUpdateInput>
    /**
     * Choose, which CafeVirtualImage to update.
     * 
    **/
    where: CafeVirtualImageWhereUniqueInput
  }


  /**
   * CafeVirtualImage updateMany
   */
  export type CafeVirtualImageUpdateManyArgs = {
    /**
     * The data used to update CafeVirtualImages.
     * 
    **/
    data: XOR<CafeVirtualImageUpdateManyMutationInput, CafeVirtualImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualImages to update
     * 
    **/
    where?: CafeVirtualImageWhereInput
  }


  /**
   * CafeVirtualImage upsert
   */
  export type CafeVirtualImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * The filter to search for the CafeVirtualImage to update in case it exists.
     * 
    **/
    where: CafeVirtualImageWhereUniqueInput
    /**
     * In case the CafeVirtualImage found by the `where` argument doesn't exist, create a new CafeVirtualImage with this data.
     * 
    **/
    create: XOR<CafeVirtualImageCreateInput, CafeVirtualImageUncheckedCreateInput>
    /**
     * In case the CafeVirtualImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeVirtualImageUpdateInput, CafeVirtualImageUncheckedUpdateInput>
  }


  /**
   * CafeVirtualImage delete
   */
  export type CafeVirtualImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
    /**
     * Filter which CafeVirtualImage to delete.
     * 
    **/
    where: CafeVirtualImageWhereUniqueInput
  }


  /**
   * CafeVirtualImage deleteMany
   */
  export type CafeVirtualImageDeleteManyArgs = {
    /**
     * Filter which CafeVirtualImages to delete
     * 
    **/
    where?: CafeVirtualImageWhereInput
  }


  /**
   * CafeVirtualImage without action
   */
  export type CafeVirtualImageArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     * 
    **/
    select?: CafeVirtualImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualImageInclude | null
  }



  /**
   * Model CafeRealImage
   */


  export type AggregateCafeRealImage = {
    _count: CafeRealImageCountAggregateOutputType | null
    _avg: CafeRealImageAvgAggregateOutputType | null
    _sum: CafeRealImageSumAggregateOutputType | null
    _min: CafeRealImageMinAggregateOutputType | null
    _max: CafeRealImageMaxAggregateOutputType | null
  }

  export type CafeRealImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeRealImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeRealImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeRealImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeRealImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    width: number
    height: number
    size: number
    priority: number
    isDisable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeRealImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeRealImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeRealImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeRealImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeRealImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeRealImageAggregateArgs = {
    /**
     * Filter which CafeRealImage to aggregate.
     * 
    **/
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeRealImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeRealImages
    **/
    _count?: true | CafeRealImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeRealImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeRealImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeRealImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeRealImageMaxAggregateInputType
  }

  export type GetCafeRealImageAggregateType<T extends CafeRealImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeRealImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeRealImage[P]>
      : GetScalarType<T[P], AggregateCafeRealImage[P]>
  }




  export type CafeRealImageGroupByArgs = {
    where?: CafeRealImageWhereInput
    orderBy?: Enumerable<CafeRealImageOrderByWithAggregationInput>
    by: Array<CafeRealImageScalarFieldEnum>
    having?: CafeRealImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeRealImageCountAggregateInputType | true
    _avg?: CafeRealImageAvgAggregateInputType
    _sum?: CafeRealImageSumAggregateInputType
    _min?: CafeRealImageMinAggregateInputType
    _max?: CafeRealImageMaxAggregateInputType
  }


  export type CafeRealImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    width: number
    height: number
    size: number
    priority: number
    isDisable: boolean
    cafeInfoId: number
    _count: CafeRealImageCountAggregateOutputType | null
    _avg: CafeRealImageAvgAggregateOutputType | null
    _sum: CafeRealImageSumAggregateOutputType | null
    _min: CafeRealImageMinAggregateOutputType | null
    _max: CafeRealImageMaxAggregateOutputType | null
  }

  type GetCafeRealImageGroupByPayload<T extends CafeRealImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeRealImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeRealImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeRealImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeRealImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeRealImageSelect = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
  }


  export type CafeRealImageInclude = {
    CafeInfo?: boolean | CafeInfoArgs
  } 

  export type CafeRealImageGetPayload<S extends boolean | null | undefined | CafeRealImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeRealImage :
    S extends undefined ? never :
    S extends { include: any } & (CafeRealImageArgs | CafeRealImageFindManyArgs)
    ? CafeRealImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeRealImageArgs | CafeRealImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :  P extends keyof CafeRealImage ? CafeRealImage[P] : never
  } 
      : CafeRealImage


  type CafeRealImageCountArgs = Merge<
    Omit<CafeRealImageFindManyArgs, 'select' | 'include'> & {
      select?: CafeRealImageCountAggregateInputType | true
    }
  >

  export interface CafeRealImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeRealImage that matches the filter.
     * @param {CafeRealImageFindUniqueArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeRealImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeRealImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeRealImage'> extends True ? Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>> : Prisma__CafeRealImageClient<CafeRealImageGetPayload<T> | null, null>

    /**
     * Find one CafeRealImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeRealImageFindUniqueOrThrowArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeRealImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeRealImageFindUniqueOrThrowArgs>
    ): Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>>

    /**
     * Find the first CafeRealImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageFindFirstArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeRealImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeRealImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeRealImage'> extends True ? Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>> : Prisma__CafeRealImageClient<CafeRealImageGetPayload<T> | null, null>

    /**
     * Find the first CafeRealImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageFindFirstOrThrowArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeRealImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeRealImageFindFirstOrThrowArgs>
    ): Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>>

    /**
     * Find zero or more CafeRealImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeRealImages
     * const cafeRealImages = await prisma.cafeRealImage.findMany()
     * 
     * // Get first 10 CafeRealImages
     * const cafeRealImages = await prisma.cafeRealImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeRealImageWithIdOnly = await prisma.cafeRealImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeRealImageFindManyArgs>(
      args?: SelectSubset<T, CafeRealImageFindManyArgs>
    ): PrismaPromise<Array<CafeRealImageGetPayload<T>>>

    /**
     * Create a CafeRealImage.
     * @param {CafeRealImageCreateArgs} args - Arguments to create a CafeRealImage.
     * @example
     * // Create one CafeRealImage
     * const CafeRealImage = await prisma.cafeRealImage.create({
     *   data: {
     *     // ... data to create a CafeRealImage
     *   }
     * })
     * 
    **/
    create<T extends CafeRealImageCreateArgs>(
      args: SelectSubset<T, CafeRealImageCreateArgs>
    ): Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>>

    /**
     * Create many CafeRealImages.
     *     @param {CafeRealImageCreateManyArgs} args - Arguments to create many CafeRealImages.
     *     @example
     *     // Create many CafeRealImages
     *     const cafeRealImage = await prisma.cafeRealImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeRealImageCreateManyArgs>(
      args?: SelectSubset<T, CafeRealImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeRealImage.
     * @param {CafeRealImageDeleteArgs} args - Arguments to delete one CafeRealImage.
     * @example
     * // Delete one CafeRealImage
     * const CafeRealImage = await prisma.cafeRealImage.delete({
     *   where: {
     *     // ... filter to delete one CafeRealImage
     *   }
     * })
     * 
    **/
    delete<T extends CafeRealImageDeleteArgs>(
      args: SelectSubset<T, CafeRealImageDeleteArgs>
    ): Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>>

    /**
     * Update one CafeRealImage.
     * @param {CafeRealImageUpdateArgs} args - Arguments to update one CafeRealImage.
     * @example
     * // Update one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeRealImageUpdateArgs>(
      args: SelectSubset<T, CafeRealImageUpdateArgs>
    ): Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>>

    /**
     * Delete zero or more CafeRealImages.
     * @param {CafeRealImageDeleteManyArgs} args - Arguments to filter CafeRealImages to delete.
     * @example
     * // Delete a few CafeRealImages
     * const { count } = await prisma.cafeRealImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeRealImageDeleteManyArgs>(
      args?: SelectSubset<T, CafeRealImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeRealImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeRealImages
     * const cafeRealImage = await prisma.cafeRealImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeRealImageUpdateManyArgs>(
      args: SelectSubset<T, CafeRealImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeRealImage.
     * @param {CafeRealImageUpsertArgs} args - Arguments to update or create a CafeRealImage.
     * @example
     * // Update or create a CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.upsert({
     *   create: {
     *     // ... data to create a CafeRealImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeRealImage we want to update
     *   }
     * })
    **/
    upsert<T extends CafeRealImageUpsertArgs>(
      args: SelectSubset<T, CafeRealImageUpsertArgs>
    ): Prisma__CafeRealImageClient<CafeRealImageGetPayload<T>>

    /**
     * Count the number of CafeRealImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageCountArgs} args - Arguments to filter CafeRealImages to count.
     * @example
     * // Count the number of CafeRealImages
     * const count = await prisma.cafeRealImage.count({
     *   where: {
     *     // ... the filter for the CafeRealImages we want to count
     *   }
     * })
    **/
    count<T extends CafeRealImageCountArgs>(
      args?: Subset<T, CafeRealImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeRealImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeRealImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeRealImageAggregateArgs>(args: Subset<T, CafeRealImageAggregateArgs>): PrismaPromise<GetCafeRealImageAggregateType<T>>

    /**
     * Group by CafeRealImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeRealImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeRealImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeRealImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeRealImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeRealImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeRealImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeRealImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeRealImage base type for findUnique actions
   */
  export type CafeRealImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * Filter, which CafeRealImage to fetch.
     * 
    **/
    where: CafeRealImageWhereUniqueInput
  }

  /**
   * CafeRealImage: findUnique
   */
  export interface CafeRealImageFindUniqueArgs extends CafeRealImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeRealImage findUniqueOrThrow
   */
  export type CafeRealImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * Filter, which CafeRealImage to fetch.
     * 
    **/
    where: CafeRealImageWhereUniqueInput
  }


  /**
   * CafeRealImage base type for findFirst actions
   */
  export type CafeRealImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * Filter, which CafeRealImage to fetch.
     * 
    **/
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeRealImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeRealImages.
     * 
    **/
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeRealImages.
     * 
    **/
    distinct?: Enumerable<CafeRealImageScalarFieldEnum>
  }

  /**
   * CafeRealImage: findFirst
   */
  export interface CafeRealImageFindFirstArgs extends CafeRealImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeRealImage findFirstOrThrow
   */
  export type CafeRealImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * Filter, which CafeRealImage to fetch.
     * 
    **/
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeRealImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeRealImages.
     * 
    **/
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeRealImages.
     * 
    **/
    distinct?: Enumerable<CafeRealImageScalarFieldEnum>
  }


  /**
   * CafeRealImage findMany
   */
  export type CafeRealImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * Filter, which CafeRealImages to fetch.
     * 
    **/
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeRealImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeRealImages.
     * 
    **/
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeRealImageScalarFieldEnum>
  }


  /**
   * CafeRealImage create
   */
  export type CafeRealImageCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * The data needed to create a CafeRealImage.
     * 
    **/
    data: XOR<CafeRealImageCreateInput, CafeRealImageUncheckedCreateInput>
  }


  /**
   * CafeRealImage createMany
   */
  export type CafeRealImageCreateManyArgs = {
    /**
     * The data used to create many CafeRealImages.
     * 
    **/
    data: Enumerable<CafeRealImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeRealImage update
   */
  export type CafeRealImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * The data needed to update a CafeRealImage.
     * 
    **/
    data: XOR<CafeRealImageUpdateInput, CafeRealImageUncheckedUpdateInput>
    /**
     * Choose, which CafeRealImage to update.
     * 
    **/
    where: CafeRealImageWhereUniqueInput
  }


  /**
   * CafeRealImage updateMany
   */
  export type CafeRealImageUpdateManyArgs = {
    /**
     * The data used to update CafeRealImages.
     * 
    **/
    data: XOR<CafeRealImageUpdateManyMutationInput, CafeRealImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeRealImages to update
     * 
    **/
    where?: CafeRealImageWhereInput
  }


  /**
   * CafeRealImage upsert
   */
  export type CafeRealImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * The filter to search for the CafeRealImage to update in case it exists.
     * 
    **/
    where: CafeRealImageWhereUniqueInput
    /**
     * In case the CafeRealImage found by the `where` argument doesn't exist, create a new CafeRealImage with this data.
     * 
    **/
    create: XOR<CafeRealImageCreateInput, CafeRealImageUncheckedCreateInput>
    /**
     * In case the CafeRealImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeRealImageUpdateInput, CafeRealImageUncheckedUpdateInput>
  }


  /**
   * CafeRealImage delete
   */
  export type CafeRealImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
    /**
     * Filter which CafeRealImage to delete.
     * 
    **/
    where: CafeRealImageWhereUniqueInput
  }


  /**
   * CafeRealImage deleteMany
   */
  export type CafeRealImageDeleteManyArgs = {
    /**
     * Filter which CafeRealImages to delete
     * 
    **/
    where?: CafeRealImageWhereInput
  }


  /**
   * CafeRealImage without action
   */
  export type CafeRealImageArgs = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     * 
    **/
    select?: CafeRealImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeRealImageInclude | null
  }



  /**
   * Model CafeVirtualLink
   */


  export type AggregateCafeVirtualLink = {
    _count: CafeVirtualLinkCountAggregateOutputType | null
    _avg: CafeVirtualLinkAvgAggregateOutputType | null
    _sum: CafeVirtualLinkSumAggregateOutputType | null
    _min: CafeVirtualLinkMinAggregateOutputType | null
    _max: CafeVirtualLinkMaxAggregateOutputType | null
  }

  export type CafeVirtualLinkAvgAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkSumAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    url: string | null
    type: string | null
    isDisable: boolean | null
    isAvaliable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    url: string | null
    type: string | null
    isDisable: boolean | null
    isAvaliable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    url: number
    type: number
    isDisable: number
    isAvaliable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeVirtualLinkAvgAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkSumAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    url?: true
    type?: true
    isDisable?: true
    isAvaliable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    url?: true
    type?: true
    isDisable?: true
    isAvaliable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    url?: true
    type?: true
    isDisable?: true
    isAvaliable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeVirtualLinkAggregateArgs = {
    /**
     * Filter which CafeVirtualLink to aggregate.
     * 
    **/
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeVirtualLinks
    **/
    _count?: true | CafeVirtualLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeVirtualLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeVirtualLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeVirtualLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeVirtualLinkMaxAggregateInputType
  }

  export type GetCafeVirtualLinkAggregateType<T extends CafeVirtualLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeVirtualLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeVirtualLink[P]>
      : GetScalarType<T[P], AggregateCafeVirtualLink[P]>
  }




  export type CafeVirtualLinkGroupByArgs = {
    where?: CafeVirtualLinkWhereInput
    orderBy?: Enumerable<CafeVirtualLinkOrderByWithAggregationInput>
    by: Array<CafeVirtualLinkScalarFieldEnum>
    having?: CafeVirtualLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeVirtualLinkCountAggregateInputType | true
    _avg?: CafeVirtualLinkAvgAggregateInputType
    _sum?: CafeVirtualLinkSumAggregateInputType
    _min?: CafeVirtualLinkMinAggregateInputType
    _max?: CafeVirtualLinkMaxAggregateInputType
  }


  export type CafeVirtualLinkGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    url: string
    type: string
    isDisable: boolean
    isAvaliable: boolean
    cafeInfoId: number
    _count: CafeVirtualLinkCountAggregateOutputType | null
    _avg: CafeVirtualLinkAvgAggregateOutputType | null
    _sum: CafeVirtualLinkSumAggregateOutputType | null
    _min: CafeVirtualLinkMinAggregateOutputType | null
    _max: CafeVirtualLinkMaxAggregateOutputType | null
  }

  type GetCafeVirtualLinkGroupByPayload<T extends CafeVirtualLinkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeVirtualLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeVirtualLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeVirtualLinkGroupByOutputType[P]>
            : GetScalarType<T[P], CafeVirtualLinkGroupByOutputType[P]>
        }
      >
    >


  export type CafeVirtualLinkSelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
    CafeVirtualLinkThumbnailImage?: boolean | CafeVirtualLinkThumbnailImageArgs
  }


  export type CafeVirtualLinkInclude = {
    CafeInfo?: boolean | CafeInfoArgs
    CafeVirtualLinkThumbnailImage?: boolean | CafeVirtualLinkThumbnailImageArgs
  } 

  export type CafeVirtualLinkGetPayload<S extends boolean | null | undefined | CafeVirtualLinkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeVirtualLink :
    S extends undefined ? never :
    S extends { include: any } & (CafeVirtualLinkArgs | CafeVirtualLinkFindManyArgs)
    ? CafeVirtualLink  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :
        P extends 'CafeVirtualLinkThumbnailImage' ? CafeVirtualLinkThumbnailImageGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CafeVirtualLinkArgs | CafeVirtualLinkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :
        P extends 'CafeVirtualLinkThumbnailImage' ? CafeVirtualLinkThumbnailImageGetPayload<S['select'][P]> | null :  P extends keyof CafeVirtualLink ? CafeVirtualLink[P] : never
  } 
      : CafeVirtualLink


  type CafeVirtualLinkCountArgs = Merge<
    Omit<CafeVirtualLinkFindManyArgs, 'select' | 'include'> & {
      select?: CafeVirtualLinkCountAggregateInputType | true
    }
  >

  export interface CafeVirtualLinkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeVirtualLink that matches the filter.
     * @param {CafeVirtualLinkFindUniqueArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeVirtualLinkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeVirtualLinkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeVirtualLink'> extends True ? Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>> : Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T> | null, null>

    /**
     * Find one CafeVirtualLink that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeVirtualLinkFindUniqueOrThrowArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeVirtualLinkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeVirtualLinkFindUniqueOrThrowArgs>
    ): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>>

    /**
     * Find the first CafeVirtualLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkFindFirstArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeVirtualLinkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeVirtualLinkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeVirtualLink'> extends True ? Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>> : Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T> | null, null>

    /**
     * Find the first CafeVirtualLink that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkFindFirstOrThrowArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeVirtualLinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeVirtualLinkFindFirstOrThrowArgs>
    ): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>>

    /**
     * Find zero or more CafeVirtualLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeVirtualLinks
     * const cafeVirtualLinks = await prisma.cafeVirtualLink.findMany()
     * 
     * // Get first 10 CafeVirtualLinks
     * const cafeVirtualLinks = await prisma.cafeVirtualLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeVirtualLinkWithIdOnly = await prisma.cafeVirtualLink.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeVirtualLinkFindManyArgs>(
      args?: SelectSubset<T, CafeVirtualLinkFindManyArgs>
    ): PrismaPromise<Array<CafeVirtualLinkGetPayload<T>>>

    /**
     * Create a CafeVirtualLink.
     * @param {CafeVirtualLinkCreateArgs} args - Arguments to create a CafeVirtualLink.
     * @example
     * // Create one CafeVirtualLink
     * const CafeVirtualLink = await prisma.cafeVirtualLink.create({
     *   data: {
     *     // ... data to create a CafeVirtualLink
     *   }
     * })
     * 
    **/
    create<T extends CafeVirtualLinkCreateArgs>(
      args: SelectSubset<T, CafeVirtualLinkCreateArgs>
    ): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>>

    /**
     * Create many CafeVirtualLinks.
     *     @param {CafeVirtualLinkCreateManyArgs} args - Arguments to create many CafeVirtualLinks.
     *     @example
     *     // Create many CafeVirtualLinks
     *     const cafeVirtualLink = await prisma.cafeVirtualLink.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeVirtualLinkCreateManyArgs>(
      args?: SelectSubset<T, CafeVirtualLinkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeVirtualLink.
     * @param {CafeVirtualLinkDeleteArgs} args - Arguments to delete one CafeVirtualLink.
     * @example
     * // Delete one CafeVirtualLink
     * const CafeVirtualLink = await prisma.cafeVirtualLink.delete({
     *   where: {
     *     // ... filter to delete one CafeVirtualLink
     *   }
     * })
     * 
    **/
    delete<T extends CafeVirtualLinkDeleteArgs>(
      args: SelectSubset<T, CafeVirtualLinkDeleteArgs>
    ): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>>

    /**
     * Update one CafeVirtualLink.
     * @param {CafeVirtualLinkUpdateArgs} args - Arguments to update one CafeVirtualLink.
     * @example
     * // Update one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeVirtualLinkUpdateArgs>(
      args: SelectSubset<T, CafeVirtualLinkUpdateArgs>
    ): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>>

    /**
     * Delete zero or more CafeVirtualLinks.
     * @param {CafeVirtualLinkDeleteManyArgs} args - Arguments to filter CafeVirtualLinks to delete.
     * @example
     * // Delete a few CafeVirtualLinks
     * const { count } = await prisma.cafeVirtualLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeVirtualLinkDeleteManyArgs>(
      args?: SelectSubset<T, CafeVirtualLinkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeVirtualLinks
     * const cafeVirtualLink = await prisma.cafeVirtualLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeVirtualLinkUpdateManyArgs>(
      args: SelectSubset<T, CafeVirtualLinkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeVirtualLink.
     * @param {CafeVirtualLinkUpsertArgs} args - Arguments to update or create a CafeVirtualLink.
     * @example
     * // Update or create a CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.upsert({
     *   create: {
     *     // ... data to create a CafeVirtualLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeVirtualLink we want to update
     *   }
     * })
    **/
    upsert<T extends CafeVirtualLinkUpsertArgs>(
      args: SelectSubset<T, CafeVirtualLinkUpsertArgs>
    ): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T>>

    /**
     * Count the number of CafeVirtualLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkCountArgs} args - Arguments to filter CafeVirtualLinks to count.
     * @example
     * // Count the number of CafeVirtualLinks
     * const count = await prisma.cafeVirtualLink.count({
     *   where: {
     *     // ... the filter for the CafeVirtualLinks we want to count
     *   }
     * })
    **/
    count<T extends CafeVirtualLinkCountArgs>(
      args?: Subset<T, CafeVirtualLinkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeVirtualLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeVirtualLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeVirtualLinkAggregateArgs>(args: Subset<T, CafeVirtualLinkAggregateArgs>): PrismaPromise<GetCafeVirtualLinkAggregateType<T>>

    /**
     * Group by CafeVirtualLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeVirtualLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeVirtualLinkGroupByArgs['orderBy'] }
        : { orderBy?: CafeVirtualLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeVirtualLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeVirtualLinkGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeVirtualLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeVirtualLinkClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    CafeVirtualLinkThumbnailImage<T extends CafeVirtualLinkThumbnailImageArgs= {}>(args?: Subset<T, CafeVirtualLinkThumbnailImageArgs>): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeVirtualLink base type for findUnique actions
   */
  export type CafeVirtualLinkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     * 
    **/
    where: CafeVirtualLinkWhereUniqueInput
  }

  /**
   * CafeVirtualLink: findUnique
   */
  export interface CafeVirtualLinkFindUniqueArgs extends CafeVirtualLinkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeVirtualLink findUniqueOrThrow
   */
  export type CafeVirtualLinkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     * 
    **/
    where: CafeVirtualLinkWhereUniqueInput
  }


  /**
   * CafeVirtualLink base type for findFirst actions
   */
  export type CafeVirtualLinkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     * 
    **/
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinks.
     * 
    **/
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinks.
     * 
    **/
    distinct?: Enumerable<CafeVirtualLinkScalarFieldEnum>
  }

  /**
   * CafeVirtualLink: findFirst
   */
  export interface CafeVirtualLinkFindFirstArgs extends CafeVirtualLinkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeVirtualLink findFirstOrThrow
   */
  export type CafeVirtualLinkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     * 
    **/
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinks.
     * 
    **/
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinks.
     * 
    **/
    distinct?: Enumerable<CafeVirtualLinkScalarFieldEnum>
  }


  /**
   * CafeVirtualLink findMany
   */
  export type CafeVirtualLinkFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * Filter, which CafeVirtualLinks to fetch.
     * 
    **/
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeVirtualLinks.
     * 
    **/
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeVirtualLinkScalarFieldEnum>
  }


  /**
   * CafeVirtualLink create
   */
  export type CafeVirtualLinkCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * The data needed to create a CafeVirtualLink.
     * 
    **/
    data: XOR<CafeVirtualLinkCreateInput, CafeVirtualLinkUncheckedCreateInput>
  }


  /**
   * CafeVirtualLink createMany
   */
  export type CafeVirtualLinkCreateManyArgs = {
    /**
     * The data used to create many CafeVirtualLinks.
     * 
    **/
    data: Enumerable<CafeVirtualLinkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeVirtualLink update
   */
  export type CafeVirtualLinkUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * The data needed to update a CafeVirtualLink.
     * 
    **/
    data: XOR<CafeVirtualLinkUpdateInput, CafeVirtualLinkUncheckedUpdateInput>
    /**
     * Choose, which CafeVirtualLink to update.
     * 
    **/
    where: CafeVirtualLinkWhereUniqueInput
  }


  /**
   * CafeVirtualLink updateMany
   */
  export type CafeVirtualLinkUpdateManyArgs = {
    /**
     * The data used to update CafeVirtualLinks.
     * 
    **/
    data: XOR<CafeVirtualLinkUpdateManyMutationInput, CafeVirtualLinkUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualLinks to update
     * 
    **/
    where?: CafeVirtualLinkWhereInput
  }


  /**
   * CafeVirtualLink upsert
   */
  export type CafeVirtualLinkUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * The filter to search for the CafeVirtualLink to update in case it exists.
     * 
    **/
    where: CafeVirtualLinkWhereUniqueInput
    /**
     * In case the CafeVirtualLink found by the `where` argument doesn't exist, create a new CafeVirtualLink with this data.
     * 
    **/
    create: XOR<CafeVirtualLinkCreateInput, CafeVirtualLinkUncheckedCreateInput>
    /**
     * In case the CafeVirtualLink was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeVirtualLinkUpdateInput, CafeVirtualLinkUncheckedUpdateInput>
  }


  /**
   * CafeVirtualLink delete
   */
  export type CafeVirtualLinkDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
    /**
     * Filter which CafeVirtualLink to delete.
     * 
    **/
    where: CafeVirtualLinkWhereUniqueInput
  }


  /**
   * CafeVirtualLink deleteMany
   */
  export type CafeVirtualLinkDeleteManyArgs = {
    /**
     * Filter which CafeVirtualLinks to delete
     * 
    **/
    where?: CafeVirtualLinkWhereInput
  }


  /**
   * CafeVirtualLink without action
   */
  export type CafeVirtualLinkArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     * 
    **/
    select?: CafeVirtualLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkInclude | null
  }



  /**
   * Model CafeVirtualLinkThumbnailImage
   */


  export type AggregateCafeVirtualLinkThumbnailImage = {
    _count: CafeVirtualLinkThumbnailImageCountAggregateOutputType | null
    _avg: CafeVirtualLinkThumbnailImageAvgAggregateOutputType | null
    _sum: CafeVirtualLinkThumbnailImageSumAggregateOutputType | null
    _min: CafeVirtualLinkThumbnailImageMinAggregateOutputType | null
    _max: CafeVirtualLinkThumbnailImageMaxAggregateOutputType | null
  }

  export type CafeVirtualLinkThumbnailImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
    _all: number
  }


  export type CafeVirtualLinkThumbnailImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
    _all?: true
  }

  export type CafeVirtualLinkThumbnailImageAggregateArgs = {
    /**
     * Filter which CafeVirtualLinkThumbnailImage to aggregate.
     * 
    **/
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeVirtualLinkThumbnailImages
    **/
    _count?: true | CafeVirtualLinkThumbnailImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeVirtualLinkThumbnailImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeVirtualLinkThumbnailImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeVirtualLinkThumbnailImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeVirtualLinkThumbnailImageMaxAggregateInputType
  }

  export type GetCafeVirtualLinkThumbnailImageAggregateType<T extends CafeVirtualLinkThumbnailImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeVirtualLinkThumbnailImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeVirtualLinkThumbnailImage[P]>
      : GetScalarType<T[P], AggregateCafeVirtualLinkThumbnailImage[P]>
  }




  export type CafeVirtualLinkThumbnailImageGroupByArgs = {
    where?: CafeVirtualLinkThumbnailImageWhereInput
    orderBy?: Enumerable<CafeVirtualLinkThumbnailImageOrderByWithAggregationInput>
    by: Array<CafeVirtualLinkThumbnailImageScalarFieldEnum>
    having?: CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeVirtualLinkThumbnailImageCountAggregateInputType | true
    _avg?: CafeVirtualLinkThumbnailImageAvgAggregateInputType
    _sum?: CafeVirtualLinkThumbnailImageSumAggregateInputType
    _min?: CafeVirtualLinkThumbnailImageMinAggregateInputType
    _max?: CafeVirtualLinkThumbnailImageMaxAggregateInputType
  }


  export type CafeVirtualLinkThumbnailImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
    _count: CafeVirtualLinkThumbnailImageCountAggregateOutputType | null
    _avg: CafeVirtualLinkThumbnailImageAvgAggregateOutputType | null
    _sum: CafeVirtualLinkThumbnailImageSumAggregateOutputType | null
    _min: CafeVirtualLinkThumbnailImageMinAggregateOutputType | null
    _max: CafeVirtualLinkThumbnailImageMaxAggregateOutputType | null
  }

  type GetCafeVirtualLinkThumbnailImageGroupByPayload<T extends CafeVirtualLinkThumbnailImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeVirtualLinkThumbnailImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeVirtualLinkThumbnailImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeVirtualLinkThumbnailImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeVirtualLinkThumbnailImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeVirtualLinkThumbnailImageSelect = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    cafeVirtualLinkId?: boolean
    CafeVirtualLink?: boolean | CafeVirtualLinkArgs
  }


  export type CafeVirtualLinkThumbnailImageInclude = {
    CafeVirtualLink?: boolean | CafeVirtualLinkArgs
  } 

  export type CafeVirtualLinkThumbnailImageGetPayload<S extends boolean | null | undefined | CafeVirtualLinkThumbnailImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeVirtualLinkThumbnailImage :
    S extends undefined ? never :
    S extends { include: any } & (CafeVirtualLinkThumbnailImageArgs | CafeVirtualLinkThumbnailImageFindManyArgs)
    ? CafeVirtualLinkThumbnailImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeVirtualLink' ? CafeVirtualLinkGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeVirtualLinkThumbnailImageArgs | CafeVirtualLinkThumbnailImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeVirtualLink' ? CafeVirtualLinkGetPayload<S['select'][P]> :  P extends keyof CafeVirtualLinkThumbnailImage ? CafeVirtualLinkThumbnailImage[P] : never
  } 
      : CafeVirtualLinkThumbnailImage


  type CafeVirtualLinkThumbnailImageCountArgs = Merge<
    Omit<CafeVirtualLinkThumbnailImageFindManyArgs, 'select' | 'include'> & {
      select?: CafeVirtualLinkThumbnailImageCountAggregateInputType | true
    }
  >

  export interface CafeVirtualLinkThumbnailImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeVirtualLinkThumbnailImage that matches the filter.
     * @param {CafeVirtualLinkThumbnailImageFindUniqueArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeVirtualLinkThumbnailImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeVirtualLinkThumbnailImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeVirtualLinkThumbnailImage'> extends True ? Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>> : Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T> | null, null>

    /**
     * Find one CafeVirtualLinkThumbnailImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs>
    ): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>>

    /**
     * Find the first CafeVirtualLinkThumbnailImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageFindFirstArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeVirtualLinkThumbnailImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeVirtualLinkThumbnailImage'> extends True ? Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>> : Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T> | null, null>

    /**
     * Find the first CafeVirtualLinkThumbnailImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs>
    ): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>>

    /**
     * Find zero or more CafeVirtualLinkThumbnailImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImages = await prisma.cafeVirtualLinkThumbnailImage.findMany()
     * 
     * // Get first 10 CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImages = await prisma.cafeVirtualLinkThumbnailImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeVirtualLinkThumbnailImageWithIdOnly = await prisma.cafeVirtualLinkThumbnailImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeVirtualLinkThumbnailImageFindManyArgs>(
      args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindManyArgs>
    ): PrismaPromise<Array<CafeVirtualLinkThumbnailImageGetPayload<T>>>

    /**
     * Create a CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageCreateArgs} args - Arguments to create a CafeVirtualLinkThumbnailImage.
     * @example
     * // Create one CafeVirtualLinkThumbnailImage
     * const CafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.create({
     *   data: {
     *     // ... data to create a CafeVirtualLinkThumbnailImage
     *   }
     * })
     * 
    **/
    create<T extends CafeVirtualLinkThumbnailImageCreateArgs>(
      args: SelectSubset<T, CafeVirtualLinkThumbnailImageCreateArgs>
    ): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>>

    /**
     * Create many CafeVirtualLinkThumbnailImages.
     *     @param {CafeVirtualLinkThumbnailImageCreateManyArgs} args - Arguments to create many CafeVirtualLinkThumbnailImages.
     *     @example
     *     // Create many CafeVirtualLinkThumbnailImages
     *     const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeVirtualLinkThumbnailImageCreateManyArgs>(
      args?: SelectSubset<T, CafeVirtualLinkThumbnailImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageDeleteArgs} args - Arguments to delete one CafeVirtualLinkThumbnailImage.
     * @example
     * // Delete one CafeVirtualLinkThumbnailImage
     * const CafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.delete({
     *   where: {
     *     // ... filter to delete one CafeVirtualLinkThumbnailImage
     *   }
     * })
     * 
    **/
    delete<T extends CafeVirtualLinkThumbnailImageDeleteArgs>(
      args: SelectSubset<T, CafeVirtualLinkThumbnailImageDeleteArgs>
    ): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>>

    /**
     * Update one CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageUpdateArgs} args - Arguments to update one CafeVirtualLinkThumbnailImage.
     * @example
     * // Update one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeVirtualLinkThumbnailImageUpdateArgs>(
      args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpdateArgs>
    ): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>>

    /**
     * Delete zero or more CafeVirtualLinkThumbnailImages.
     * @param {CafeVirtualLinkThumbnailImageDeleteManyArgs} args - Arguments to filter CafeVirtualLinkThumbnailImages to delete.
     * @example
     * // Delete a few CafeVirtualLinkThumbnailImages
     * const { count } = await prisma.cafeVirtualLinkThumbnailImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeVirtualLinkThumbnailImageDeleteManyArgs>(
      args?: SelectSubset<T, CafeVirtualLinkThumbnailImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualLinkThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeVirtualLinkThumbnailImageUpdateManyArgs>(
      args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageUpsertArgs} args - Arguments to update or create a CafeVirtualLinkThumbnailImage.
     * @example
     * // Update or create a CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.upsert({
     *   create: {
     *     // ... data to create a CafeVirtualLinkThumbnailImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeVirtualLinkThumbnailImage we want to update
     *   }
     * })
    **/
    upsert<T extends CafeVirtualLinkThumbnailImageUpsertArgs>(
      args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpsertArgs>
    ): Prisma__CafeVirtualLinkThumbnailImageClient<CafeVirtualLinkThumbnailImageGetPayload<T>>

    /**
     * Count the number of CafeVirtualLinkThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageCountArgs} args - Arguments to filter CafeVirtualLinkThumbnailImages to count.
     * @example
     * // Count the number of CafeVirtualLinkThumbnailImages
     * const count = await prisma.cafeVirtualLinkThumbnailImage.count({
     *   where: {
     *     // ... the filter for the CafeVirtualLinkThumbnailImages we want to count
     *   }
     * })
    **/
    count<T extends CafeVirtualLinkThumbnailImageCountArgs>(
      args?: Subset<T, CafeVirtualLinkThumbnailImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeVirtualLinkThumbnailImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeVirtualLinkThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeVirtualLinkThumbnailImageAggregateArgs>(args: Subset<T, CafeVirtualLinkThumbnailImageAggregateArgs>): PrismaPromise<GetCafeVirtualLinkThumbnailImageAggregateType<T>>

    /**
     * Group by CafeVirtualLinkThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeVirtualLinkThumbnailImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeVirtualLinkThumbnailImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeVirtualLinkThumbnailImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeVirtualLinkThumbnailImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeVirtualLinkThumbnailImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeVirtualLinkThumbnailImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeVirtualLinkThumbnailImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeVirtualLink<T extends CafeVirtualLinkArgs= {}>(args?: Subset<T, CafeVirtualLinkArgs>): Prisma__CafeVirtualLinkClient<CafeVirtualLinkGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeVirtualLinkThumbnailImage base type for findUnique actions
   */
  export type CafeVirtualLinkThumbnailImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     * 
    **/
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  /**
   * CafeVirtualLinkThumbnailImage: findUnique
   */
  export interface CafeVirtualLinkThumbnailImageFindUniqueArgs extends CafeVirtualLinkThumbnailImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeVirtualLinkThumbnailImage findUniqueOrThrow
   */
  export type CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     * 
    **/
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }


  /**
   * CafeVirtualLinkThumbnailImage base type for findFirst actions
   */
  export type CafeVirtualLinkThumbnailImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     * 
    **/
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinkThumbnailImages.
     * 
    **/
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinkThumbnailImages.
     * 
    **/
    distinct?: Enumerable<CafeVirtualLinkThumbnailImageScalarFieldEnum>
  }

  /**
   * CafeVirtualLinkThumbnailImage: findFirst
   */
  export interface CafeVirtualLinkThumbnailImageFindFirstArgs extends CafeVirtualLinkThumbnailImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeVirtualLinkThumbnailImage findFirstOrThrow
   */
  export type CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     * 
    **/
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinkThumbnailImages.
     * 
    **/
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinkThumbnailImages.
     * 
    **/
    distinct?: Enumerable<CafeVirtualLinkThumbnailImageScalarFieldEnum>
  }


  /**
   * CafeVirtualLinkThumbnailImage findMany
   */
  export type CafeVirtualLinkThumbnailImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImages to fetch.
     * 
    **/
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeVirtualLinkThumbnailImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeVirtualLinkThumbnailImages.
     * 
    **/
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeVirtualLinkThumbnailImageScalarFieldEnum>
  }


  /**
   * CafeVirtualLinkThumbnailImage create
   */
  export type CafeVirtualLinkThumbnailImageCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * The data needed to create a CafeVirtualLinkThumbnailImage.
     * 
    **/
    data: XOR<CafeVirtualLinkThumbnailImageCreateInput, CafeVirtualLinkThumbnailImageUncheckedCreateInput>
  }


  /**
   * CafeVirtualLinkThumbnailImage createMany
   */
  export type CafeVirtualLinkThumbnailImageCreateManyArgs = {
    /**
     * The data used to create many CafeVirtualLinkThumbnailImages.
     * 
    **/
    data: Enumerable<CafeVirtualLinkThumbnailImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeVirtualLinkThumbnailImage update
   */
  export type CafeVirtualLinkThumbnailImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * The data needed to update a CafeVirtualLinkThumbnailImage.
     * 
    **/
    data: XOR<CafeVirtualLinkThumbnailImageUpdateInput, CafeVirtualLinkThumbnailImageUncheckedUpdateInput>
    /**
     * Choose, which CafeVirtualLinkThumbnailImage to update.
     * 
    **/
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }


  /**
   * CafeVirtualLinkThumbnailImage updateMany
   */
  export type CafeVirtualLinkThumbnailImageUpdateManyArgs = {
    /**
     * The data used to update CafeVirtualLinkThumbnailImages.
     * 
    **/
    data: XOR<CafeVirtualLinkThumbnailImageUpdateManyMutationInput, CafeVirtualLinkThumbnailImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualLinkThumbnailImages to update
     * 
    **/
    where?: CafeVirtualLinkThumbnailImageWhereInput
  }


  /**
   * CafeVirtualLinkThumbnailImage upsert
   */
  export type CafeVirtualLinkThumbnailImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * The filter to search for the CafeVirtualLinkThumbnailImage to update in case it exists.
     * 
    **/
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * In case the CafeVirtualLinkThumbnailImage found by the `where` argument doesn't exist, create a new CafeVirtualLinkThumbnailImage with this data.
     * 
    **/
    create: XOR<CafeVirtualLinkThumbnailImageCreateInput, CafeVirtualLinkThumbnailImageUncheckedCreateInput>
    /**
     * In case the CafeVirtualLinkThumbnailImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeVirtualLinkThumbnailImageUpdateInput, CafeVirtualLinkThumbnailImageUncheckedUpdateInput>
  }


  /**
   * CafeVirtualLinkThumbnailImage delete
   */
  export type CafeVirtualLinkThumbnailImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
    /**
     * Filter which CafeVirtualLinkThumbnailImage to delete.
     * 
    **/
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }


  /**
   * CafeVirtualLinkThumbnailImage deleteMany
   */
  export type CafeVirtualLinkThumbnailImageDeleteManyArgs = {
    /**
     * Filter which CafeVirtualLinkThumbnailImages to delete
     * 
    **/
    where?: CafeVirtualLinkThumbnailImageWhereInput
  }


  /**
   * CafeVirtualLinkThumbnailImage without action
   */
  export type CafeVirtualLinkThumbnailImageArgs = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     * 
    **/
    select?: CafeVirtualLinkThumbnailImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeVirtualLinkThumbnailImageInclude | null
  }



  /**
   * Model CafeCouponGroup
   */


  export type AggregateCafeCouponGroup = {
    _count: CafeCouponGroupCountAggregateOutputType | null
    _avg: CafeCouponGroupAvgAggregateOutputType | null
    _sum: CafeCouponGroupSumAggregateOutputType | null
    _min: CafeCouponGroupMinAggregateOutputType | null
    _max: CafeCouponGroupMaxAggregateOutputType | null
  }

  export type CafeCouponGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type CafeCouponGroupSumAggregateOutputType = {
    id: number | null
  }

  export type CafeCouponGroupMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    name: string | null
    tag: string | null
    description: string | null
    isDisable: boolean | null
    startDay: Date | null
    endDay: Date | null
    issuanceStartDay: Date | null
    issuanceEndDay: Date | null
  }

  export type CafeCouponGroupMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    name: string | null
    tag: string | null
    description: string | null
    isDisable: boolean | null
    startDay: Date | null
    endDay: Date | null
    issuanceStartDay: Date | null
    issuanceEndDay: Date | null
  }

  export type CafeCouponGroupCountAggregateOutputType = {
    id: number
    createdAt: number
    code: number
    name: number
    tag: number
    description: number
    isDisable: number
    startDay: number
    endDay: number
    issuanceStartDay: number
    issuanceEndDay: number
    _all: number
  }


  export type CafeCouponGroupAvgAggregateInputType = {
    id?: true
  }

  export type CafeCouponGroupSumAggregateInputType = {
    id?: true
  }

  export type CafeCouponGroupMinAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    name?: true
    tag?: true
    description?: true
    isDisable?: true
    startDay?: true
    endDay?: true
    issuanceStartDay?: true
    issuanceEndDay?: true
  }

  export type CafeCouponGroupMaxAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    name?: true
    tag?: true
    description?: true
    isDisable?: true
    startDay?: true
    endDay?: true
    issuanceStartDay?: true
    issuanceEndDay?: true
  }

  export type CafeCouponGroupCountAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    name?: true
    tag?: true
    description?: true
    isDisable?: true
    startDay?: true
    endDay?: true
    issuanceStartDay?: true
    issuanceEndDay?: true
    _all?: true
  }

  export type CafeCouponGroupAggregateArgs = {
    /**
     * Filter which CafeCouponGroup to aggregate.
     * 
    **/
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponGroups
    **/
    _count?: true | CafeCouponGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponGroupMaxAggregateInputType
  }

  export type GetCafeCouponGroupAggregateType<T extends CafeCouponGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponGroup[P]>
      : GetScalarType<T[P], AggregateCafeCouponGroup[P]>
  }




  export type CafeCouponGroupGroupByArgs = {
    where?: CafeCouponGroupWhereInput
    orderBy?: Enumerable<CafeCouponGroupOrderByWithAggregationInput>
    by: Array<CafeCouponGroupScalarFieldEnum>
    having?: CafeCouponGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponGroupCountAggregateInputType | true
    _avg?: CafeCouponGroupAvgAggregateInputType
    _sum?: CafeCouponGroupSumAggregateInputType
    _min?: CafeCouponGroupMinAggregateInputType
    _max?: CafeCouponGroupMaxAggregateInputType
  }


  export type CafeCouponGroupGroupByOutputType = {
    id: number
    createdAt: Date
    code: string
    name: string
    tag: string
    description: string
    isDisable: boolean
    startDay: Date
    endDay: Date
    issuanceStartDay: Date
    issuanceEndDay: Date
    _count: CafeCouponGroupCountAggregateOutputType | null
    _avg: CafeCouponGroupAvgAggregateOutputType | null
    _sum: CafeCouponGroupSumAggregateOutputType | null
    _min: CafeCouponGroupMinAggregateOutputType | null
    _max: CafeCouponGroupMaxAggregateOutputType | null
  }

  type GetCafeCouponGroupGroupByPayload<T extends CafeCouponGroupGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeCouponGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponGroupGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponGroupSelect = {
    id?: boolean
    createdAt?: boolean
    code?: boolean
    name?: boolean
    tag?: boolean
    description?: boolean
    isDisable?: boolean
    startDay?: boolean
    endDay?: boolean
    issuanceStartDay?: boolean
    issuanceEndDay?: boolean
    CafeCoupons?: boolean | CafeCouponFindManyArgs
    CafeCouponGoupPartners?: boolean | CafeCouponGoupPartnerFindManyArgs
    _count?: boolean | CafeCouponGroupCountOutputTypeArgs
  }


  export type CafeCouponGroupInclude = {
    CafeCoupons?: boolean | CafeCouponFindManyArgs
    CafeCouponGoupPartners?: boolean | CafeCouponGoupPartnerFindManyArgs
    _count?: boolean | CafeCouponGroupCountOutputTypeArgs
  } 

  export type CafeCouponGroupGetPayload<S extends boolean | null | undefined | CafeCouponGroupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCouponGroup :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponGroupArgs | CafeCouponGroupFindManyArgs)
    ? CafeCouponGroup  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeCoupons' ? Array < CafeCouponGetPayload<S['include'][P]>>  :
        P extends 'CafeCouponGoupPartners' ? Array < CafeCouponGoupPartnerGetPayload<S['include'][P]>>  :
        P extends '_count' ? CafeCouponGroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeCouponGroupArgs | CafeCouponGroupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeCoupons' ? Array < CafeCouponGetPayload<S['select'][P]>>  :
        P extends 'CafeCouponGoupPartners' ? Array < CafeCouponGoupPartnerGetPayload<S['select'][P]>>  :
        P extends '_count' ? CafeCouponGroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CafeCouponGroup ? CafeCouponGroup[P] : never
  } 
      : CafeCouponGroup


  type CafeCouponGroupCountArgs = Merge<
    Omit<CafeCouponGroupFindManyArgs, 'select' | 'include'> & {
      select?: CafeCouponGroupCountAggregateInputType | true
    }
  >

  export interface CafeCouponGroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeCouponGroup that matches the filter.
     * @param {CafeCouponGroupFindUniqueArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeCouponGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeCouponGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeCouponGroup'> extends True ? Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>> : Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T> | null, null>

    /**
     * Find one CafeCouponGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeCouponGroupFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeCouponGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponGroupFindUniqueOrThrowArgs>
    ): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>>

    /**
     * Find the first CafeCouponGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupFindFirstArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeCouponGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeCouponGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeCouponGroup'> extends True ? Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>> : Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T> | null, null>

    /**
     * Find the first CafeCouponGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupFindFirstOrThrowArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeCouponGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponGroupFindFirstOrThrowArgs>
    ): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>>

    /**
     * Find zero or more CafeCouponGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponGroups
     * const cafeCouponGroups = await prisma.cafeCouponGroup.findMany()
     * 
     * // Get first 10 CafeCouponGroups
     * const cafeCouponGroups = await prisma.cafeCouponGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeCouponGroupWithIdOnly = await prisma.cafeCouponGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeCouponGroupFindManyArgs>(
      args?: SelectSubset<T, CafeCouponGroupFindManyArgs>
    ): PrismaPromise<Array<CafeCouponGroupGetPayload<T>>>

    /**
     * Create a CafeCouponGroup.
     * @param {CafeCouponGroupCreateArgs} args - Arguments to create a CafeCouponGroup.
     * @example
     * // Create one CafeCouponGroup
     * const CafeCouponGroup = await prisma.cafeCouponGroup.create({
     *   data: {
     *     // ... data to create a CafeCouponGroup
     *   }
     * })
     * 
    **/
    create<T extends CafeCouponGroupCreateArgs>(
      args: SelectSubset<T, CafeCouponGroupCreateArgs>
    ): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>>

    /**
     * Create many CafeCouponGroups.
     *     @param {CafeCouponGroupCreateManyArgs} args - Arguments to create many CafeCouponGroups.
     *     @example
     *     // Create many CafeCouponGroups
     *     const cafeCouponGroup = await prisma.cafeCouponGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeCouponGroupCreateManyArgs>(
      args?: SelectSubset<T, CafeCouponGroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeCouponGroup.
     * @param {CafeCouponGroupDeleteArgs} args - Arguments to delete one CafeCouponGroup.
     * @example
     * // Delete one CafeCouponGroup
     * const CafeCouponGroup = await prisma.cafeCouponGroup.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponGroup
     *   }
     * })
     * 
    **/
    delete<T extends CafeCouponGroupDeleteArgs>(
      args: SelectSubset<T, CafeCouponGroupDeleteArgs>
    ): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>>

    /**
     * Update one CafeCouponGroup.
     * @param {CafeCouponGroupUpdateArgs} args - Arguments to update one CafeCouponGroup.
     * @example
     * // Update one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeCouponGroupUpdateArgs>(
      args: SelectSubset<T, CafeCouponGroupUpdateArgs>
    ): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>>

    /**
     * Delete zero or more CafeCouponGroups.
     * @param {CafeCouponGroupDeleteManyArgs} args - Arguments to filter CafeCouponGroups to delete.
     * @example
     * // Delete a few CafeCouponGroups
     * const { count } = await prisma.cafeCouponGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeCouponGroupDeleteManyArgs>(
      args?: SelectSubset<T, CafeCouponGroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponGroups
     * const cafeCouponGroup = await prisma.cafeCouponGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeCouponGroupUpdateManyArgs>(
      args: SelectSubset<T, CafeCouponGroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeCouponGroup.
     * @param {CafeCouponGroupUpsertArgs} args - Arguments to update or create a CafeCouponGroup.
     * @example
     * // Update or create a CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.upsert({
     *   create: {
     *     // ... data to create a CafeCouponGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponGroup we want to update
     *   }
     * })
    **/
    upsert<T extends CafeCouponGroupUpsertArgs>(
      args: SelectSubset<T, CafeCouponGroupUpsertArgs>
    ): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T>>

    /**
     * Count the number of CafeCouponGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupCountArgs} args - Arguments to filter CafeCouponGroups to count.
     * @example
     * // Count the number of CafeCouponGroups
     * const count = await prisma.cafeCouponGroup.count({
     *   where: {
     *     // ... the filter for the CafeCouponGroups we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponGroupCountArgs>(
      args?: Subset<T, CafeCouponGroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponGroupAggregateArgs>(args: Subset<T, CafeCouponGroupAggregateArgs>): PrismaPromise<GetCafeCouponGroupAggregateType<T>>

    /**
     * Group by CafeCouponGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponGroupGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponGroupGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeCouponGroupClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeCoupons<T extends CafeCouponFindManyArgs= {}>(args?: Subset<T, CafeCouponFindManyArgs>): PrismaPromise<Array<CafeCouponGetPayload<T>>| Null>;

    CafeCouponGoupPartners<T extends CafeCouponGoupPartnerFindManyArgs= {}>(args?: Subset<T, CafeCouponGoupPartnerFindManyArgs>): PrismaPromise<Array<CafeCouponGoupPartnerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeCouponGroup base type for findUnique actions
   */
  export type CafeCouponGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     * 
    **/
    where: CafeCouponGroupWhereUniqueInput
  }

  /**
   * CafeCouponGroup: findUnique
   */
  export interface CafeCouponGroupFindUniqueArgs extends CafeCouponGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponGroup findUniqueOrThrow
   */
  export type CafeCouponGroupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     * 
    **/
    where: CafeCouponGroupWhereUniqueInput
  }


  /**
   * CafeCouponGroup base type for findFirst actions
   */
  export type CafeCouponGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     * 
    **/
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGroups.
     * 
    **/
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGroups.
     * 
    **/
    distinct?: Enumerable<CafeCouponGroupScalarFieldEnum>
  }

  /**
   * CafeCouponGroup: findFirst
   */
  export interface CafeCouponGroupFindFirstArgs extends CafeCouponGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponGroup findFirstOrThrow
   */
  export type CafeCouponGroupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     * 
    **/
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGroups.
     * 
    **/
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGroups.
     * 
    **/
    distinct?: Enumerable<CafeCouponGroupScalarFieldEnum>
  }


  /**
   * CafeCouponGroup findMany
   */
  export type CafeCouponGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * Filter, which CafeCouponGroups to fetch.
     * 
    **/
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponGroups.
     * 
    **/
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeCouponGroupScalarFieldEnum>
  }


  /**
   * CafeCouponGroup create
   */
  export type CafeCouponGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * The data needed to create a CafeCouponGroup.
     * 
    **/
    data: XOR<CafeCouponGroupCreateInput, CafeCouponGroupUncheckedCreateInput>
  }


  /**
   * CafeCouponGroup createMany
   */
  export type CafeCouponGroupCreateManyArgs = {
    /**
     * The data used to create many CafeCouponGroups.
     * 
    **/
    data: Enumerable<CafeCouponGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeCouponGroup update
   */
  export type CafeCouponGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * The data needed to update a CafeCouponGroup.
     * 
    **/
    data: XOR<CafeCouponGroupUpdateInput, CafeCouponGroupUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponGroup to update.
     * 
    **/
    where: CafeCouponGroupWhereUniqueInput
  }


  /**
   * CafeCouponGroup updateMany
   */
  export type CafeCouponGroupUpdateManyArgs = {
    /**
     * The data used to update CafeCouponGroups.
     * 
    **/
    data: XOR<CafeCouponGroupUpdateManyMutationInput, CafeCouponGroupUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponGroups to update
     * 
    **/
    where?: CafeCouponGroupWhereInput
  }


  /**
   * CafeCouponGroup upsert
   */
  export type CafeCouponGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * The filter to search for the CafeCouponGroup to update in case it exists.
     * 
    **/
    where: CafeCouponGroupWhereUniqueInput
    /**
     * In case the CafeCouponGroup found by the `where` argument doesn't exist, create a new CafeCouponGroup with this data.
     * 
    **/
    create: XOR<CafeCouponGroupCreateInput, CafeCouponGroupUncheckedCreateInput>
    /**
     * In case the CafeCouponGroup was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeCouponGroupUpdateInput, CafeCouponGroupUncheckedUpdateInput>
  }


  /**
   * CafeCouponGroup delete
   */
  export type CafeCouponGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
    /**
     * Filter which CafeCouponGroup to delete.
     * 
    **/
    where: CafeCouponGroupWhereUniqueInput
  }


  /**
   * CafeCouponGroup deleteMany
   */
  export type CafeCouponGroupDeleteManyArgs = {
    /**
     * Filter which CafeCouponGroups to delete
     * 
    **/
    where?: CafeCouponGroupWhereInput
  }


  /**
   * CafeCouponGroup without action
   */
  export type CafeCouponGroupArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     * 
    **/
    select?: CafeCouponGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGroupInclude | null
  }



  /**
   * Model CafeCouponGoupPartner
   */


  export type AggregateCafeCouponGoupPartner = {
    _count: CafeCouponGoupPartnerCountAggregateOutputType | null
    _avg: CafeCouponGoupPartnerAvgAggregateOutputType | null
    _sum: CafeCouponGoupPartnerSumAggregateOutputType | null
    _min: CafeCouponGoupPartnerMinAggregateOutputType | null
    _max: CafeCouponGoupPartnerMaxAggregateOutputType | null
  }

  export type CafeCouponGoupPartnerAvgAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerSumAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerMinAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerMaxAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerCountAggregateOutputType = {
    cafeCouponGroupId: number
    cafeInfoId: number
    _all: number
  }


  export type CafeCouponGoupPartnerAvgAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerSumAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerMinAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerMaxAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerCountAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeCouponGoupPartnerAggregateArgs = {
    /**
     * Filter which CafeCouponGoupPartner to aggregate.
     * 
    **/
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGoupPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponGoupPartners
    **/
    _count?: true | CafeCouponGoupPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponGoupPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponGoupPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponGoupPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponGoupPartnerMaxAggregateInputType
  }

  export type GetCafeCouponGoupPartnerAggregateType<T extends CafeCouponGoupPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponGoupPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponGoupPartner[P]>
      : GetScalarType<T[P], AggregateCafeCouponGoupPartner[P]>
  }




  export type CafeCouponGoupPartnerGroupByArgs = {
    where?: CafeCouponGoupPartnerWhereInput
    orderBy?: Enumerable<CafeCouponGoupPartnerOrderByWithAggregationInput>
    by: Array<CafeCouponGoupPartnerScalarFieldEnum>
    having?: CafeCouponGoupPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponGoupPartnerCountAggregateInputType | true
    _avg?: CafeCouponGoupPartnerAvgAggregateInputType
    _sum?: CafeCouponGoupPartnerSumAggregateInputType
    _min?: CafeCouponGoupPartnerMinAggregateInputType
    _max?: CafeCouponGoupPartnerMaxAggregateInputType
  }


  export type CafeCouponGoupPartnerGroupByOutputType = {
    cafeCouponGroupId: number
    cafeInfoId: number
    _count: CafeCouponGoupPartnerCountAggregateOutputType | null
    _avg: CafeCouponGoupPartnerAvgAggregateOutputType | null
    _sum: CafeCouponGoupPartnerSumAggregateOutputType | null
    _min: CafeCouponGoupPartnerMinAggregateOutputType | null
    _max: CafeCouponGoupPartnerMaxAggregateOutputType | null
  }

  type GetCafeCouponGoupPartnerGroupByPayload<T extends CafeCouponGoupPartnerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeCouponGoupPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponGoupPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponGoupPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponGoupPartnerGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponGoupPartnerSelect = {
    cafeCouponGroupId?: boolean
    CafeCouponGroup?: boolean | CafeCouponGroupArgs
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
  }


  export type CafeCouponGoupPartnerInclude = {
    CafeCouponGroup?: boolean | CafeCouponGroupArgs
    CafeInfo?: boolean | CafeInfoArgs
  } 

  export type CafeCouponGoupPartnerGetPayload<S extends boolean | null | undefined | CafeCouponGoupPartnerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCouponGoupPartner :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponGoupPartnerArgs | CafeCouponGoupPartnerFindManyArgs)
    ? CafeCouponGoupPartner  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeCouponGroup' ? CafeCouponGroupGetPayload<S['include'][P]> :
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeCouponGoupPartnerArgs | CafeCouponGoupPartnerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeCouponGroup' ? CafeCouponGroupGetPayload<S['select'][P]> :
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :  P extends keyof CafeCouponGoupPartner ? CafeCouponGoupPartner[P] : never
  } 
      : CafeCouponGoupPartner


  type CafeCouponGoupPartnerCountArgs = Merge<
    Omit<CafeCouponGoupPartnerFindManyArgs, 'select' | 'include'> & {
      select?: CafeCouponGoupPartnerCountAggregateInputType | true
    }
  >

  export interface CafeCouponGoupPartnerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeCouponGoupPartner that matches the filter.
     * @param {CafeCouponGoupPartnerFindUniqueArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeCouponGoupPartnerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeCouponGoupPartnerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeCouponGoupPartner'> extends True ? Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>> : Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T> | null, null>

    /**
     * Find one CafeCouponGoupPartner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeCouponGoupPartnerFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeCouponGoupPartnerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponGoupPartnerFindUniqueOrThrowArgs>
    ): Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>>

    /**
     * Find the first CafeCouponGoupPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerFindFirstArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeCouponGoupPartnerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeCouponGoupPartnerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeCouponGoupPartner'> extends True ? Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>> : Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T> | null, null>

    /**
     * Find the first CafeCouponGoupPartner that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerFindFirstOrThrowArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeCouponGoupPartnerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponGoupPartnerFindFirstOrThrowArgs>
    ): Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>>

    /**
     * Find zero or more CafeCouponGoupPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponGoupPartners
     * const cafeCouponGoupPartners = await prisma.cafeCouponGoupPartner.findMany()
     * 
     * // Get first 10 CafeCouponGoupPartners
     * const cafeCouponGoupPartners = await prisma.cafeCouponGoupPartner.findMany({ take: 10 })
     * 
     * // Only select the `cafeCouponGroupId`
     * const cafeCouponGoupPartnerWithCafeCouponGroupIdOnly = await prisma.cafeCouponGoupPartner.findMany({ select: { cafeCouponGroupId: true } })
     * 
    **/
    findMany<T extends CafeCouponGoupPartnerFindManyArgs>(
      args?: SelectSubset<T, CafeCouponGoupPartnerFindManyArgs>
    ): PrismaPromise<Array<CafeCouponGoupPartnerGetPayload<T>>>

    /**
     * Create a CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerCreateArgs} args - Arguments to create a CafeCouponGoupPartner.
     * @example
     * // Create one CafeCouponGoupPartner
     * const CafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.create({
     *   data: {
     *     // ... data to create a CafeCouponGoupPartner
     *   }
     * })
     * 
    **/
    create<T extends CafeCouponGoupPartnerCreateArgs>(
      args: SelectSubset<T, CafeCouponGoupPartnerCreateArgs>
    ): Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>>

    /**
     * Create many CafeCouponGoupPartners.
     *     @param {CafeCouponGoupPartnerCreateManyArgs} args - Arguments to create many CafeCouponGoupPartners.
     *     @example
     *     // Create many CafeCouponGoupPartners
     *     const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeCouponGoupPartnerCreateManyArgs>(
      args?: SelectSubset<T, CafeCouponGoupPartnerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerDeleteArgs} args - Arguments to delete one CafeCouponGoupPartner.
     * @example
     * // Delete one CafeCouponGoupPartner
     * const CafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponGoupPartner
     *   }
     * })
     * 
    **/
    delete<T extends CafeCouponGoupPartnerDeleteArgs>(
      args: SelectSubset<T, CafeCouponGoupPartnerDeleteArgs>
    ): Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>>

    /**
     * Update one CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerUpdateArgs} args - Arguments to update one CafeCouponGoupPartner.
     * @example
     * // Update one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeCouponGoupPartnerUpdateArgs>(
      args: SelectSubset<T, CafeCouponGoupPartnerUpdateArgs>
    ): Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>>

    /**
     * Delete zero or more CafeCouponGoupPartners.
     * @param {CafeCouponGoupPartnerDeleteManyArgs} args - Arguments to filter CafeCouponGoupPartners to delete.
     * @example
     * // Delete a few CafeCouponGoupPartners
     * const { count } = await prisma.cafeCouponGoupPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeCouponGoupPartnerDeleteManyArgs>(
      args?: SelectSubset<T, CafeCouponGoupPartnerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponGoupPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponGoupPartners
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeCouponGoupPartnerUpdateManyArgs>(
      args: SelectSubset<T, CafeCouponGoupPartnerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerUpsertArgs} args - Arguments to update or create a CafeCouponGoupPartner.
     * @example
     * // Update or create a CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.upsert({
     *   create: {
     *     // ... data to create a CafeCouponGoupPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponGoupPartner we want to update
     *   }
     * })
    **/
    upsert<T extends CafeCouponGoupPartnerUpsertArgs>(
      args: SelectSubset<T, CafeCouponGoupPartnerUpsertArgs>
    ): Prisma__CafeCouponGoupPartnerClient<CafeCouponGoupPartnerGetPayload<T>>

    /**
     * Count the number of CafeCouponGoupPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerCountArgs} args - Arguments to filter CafeCouponGoupPartners to count.
     * @example
     * // Count the number of CafeCouponGoupPartners
     * const count = await prisma.cafeCouponGoupPartner.count({
     *   where: {
     *     // ... the filter for the CafeCouponGoupPartners we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponGoupPartnerCountArgs>(
      args?: Subset<T, CafeCouponGoupPartnerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponGoupPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponGoupPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponGoupPartnerAggregateArgs>(args: Subset<T, CafeCouponGoupPartnerAggregateArgs>): PrismaPromise<GetCafeCouponGoupPartnerAggregateType<T>>

    /**
     * Group by CafeCouponGoupPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponGoupPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponGoupPartnerGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponGoupPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponGoupPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponGoupPartnerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponGoupPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeCouponGoupPartnerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeCouponGroup<T extends CafeCouponGroupArgs= {}>(args?: Subset<T, CafeCouponGroupArgs>): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T> | Null>;

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeCouponGoupPartner base type for findUnique actions
   */
  export type CafeCouponGoupPartnerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     * 
    **/
    where: CafeCouponGoupPartnerWhereUniqueInput
  }

  /**
   * CafeCouponGoupPartner: findUnique
   */
  export interface CafeCouponGoupPartnerFindUniqueArgs extends CafeCouponGoupPartnerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponGoupPartner findUniqueOrThrow
   */
  export type CafeCouponGoupPartnerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     * 
    **/
    where: CafeCouponGoupPartnerWhereUniqueInput
  }


  /**
   * CafeCouponGoupPartner base type for findFirst actions
   */
  export type CafeCouponGoupPartnerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     * 
    **/
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGoupPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGoupPartners.
     * 
    **/
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGoupPartners.
     * 
    **/
    distinct?: Enumerable<CafeCouponGoupPartnerScalarFieldEnum>
  }

  /**
   * CafeCouponGoupPartner: findFirst
   */
  export interface CafeCouponGoupPartnerFindFirstArgs extends CafeCouponGoupPartnerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponGoupPartner findFirstOrThrow
   */
  export type CafeCouponGoupPartnerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     * 
    **/
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGoupPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGoupPartners.
     * 
    **/
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGoupPartners.
     * 
    **/
    distinct?: Enumerable<CafeCouponGoupPartnerScalarFieldEnum>
  }


  /**
   * CafeCouponGoupPartner findMany
   */
  export type CafeCouponGoupPartnerFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * Filter, which CafeCouponGoupPartners to fetch.
     * 
    **/
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponGoupPartnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponGoupPartners.
     * 
    **/
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeCouponGoupPartnerScalarFieldEnum>
  }


  /**
   * CafeCouponGoupPartner create
   */
  export type CafeCouponGoupPartnerCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * The data needed to create a CafeCouponGoupPartner.
     * 
    **/
    data: XOR<CafeCouponGoupPartnerCreateInput, CafeCouponGoupPartnerUncheckedCreateInput>
  }


  /**
   * CafeCouponGoupPartner createMany
   */
  export type CafeCouponGoupPartnerCreateManyArgs = {
    /**
     * The data used to create many CafeCouponGoupPartners.
     * 
    **/
    data: Enumerable<CafeCouponGoupPartnerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeCouponGoupPartner update
   */
  export type CafeCouponGoupPartnerUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * The data needed to update a CafeCouponGoupPartner.
     * 
    **/
    data: XOR<CafeCouponGoupPartnerUpdateInput, CafeCouponGoupPartnerUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponGoupPartner to update.
     * 
    **/
    where: CafeCouponGoupPartnerWhereUniqueInput
  }


  /**
   * CafeCouponGoupPartner updateMany
   */
  export type CafeCouponGoupPartnerUpdateManyArgs = {
    /**
     * The data used to update CafeCouponGoupPartners.
     * 
    **/
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponGoupPartners to update
     * 
    **/
    where?: CafeCouponGoupPartnerWhereInput
  }


  /**
   * CafeCouponGoupPartner upsert
   */
  export type CafeCouponGoupPartnerUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * The filter to search for the CafeCouponGoupPartner to update in case it exists.
     * 
    **/
    where: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * In case the CafeCouponGoupPartner found by the `where` argument doesn't exist, create a new CafeCouponGoupPartner with this data.
     * 
    **/
    create: XOR<CafeCouponGoupPartnerCreateInput, CafeCouponGoupPartnerUncheckedCreateInput>
    /**
     * In case the CafeCouponGoupPartner was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeCouponGoupPartnerUpdateInput, CafeCouponGoupPartnerUncheckedUpdateInput>
  }


  /**
   * CafeCouponGoupPartner delete
   */
  export type CafeCouponGoupPartnerDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
    /**
     * Filter which CafeCouponGoupPartner to delete.
     * 
    **/
    where: CafeCouponGoupPartnerWhereUniqueInput
  }


  /**
   * CafeCouponGoupPartner deleteMany
   */
  export type CafeCouponGoupPartnerDeleteManyArgs = {
    /**
     * Filter which CafeCouponGoupPartners to delete
     * 
    **/
    where?: CafeCouponGoupPartnerWhereInput
  }


  /**
   * CafeCouponGoupPartner without action
   */
  export type CafeCouponGoupPartnerArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     * 
    **/
    select?: CafeCouponGoupPartnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponGoupPartnerInclude | null
  }



  /**
   * Model ProxyUser
   */


  export type AggregateProxyUser = {
    _count: ProxyUserCountAggregateOutputType | null
    _avg: ProxyUserAvgAggregateOutputType | null
    _sum: ProxyUserSumAggregateOutputType | null
    _min: ProxyUserMinAggregateOutputType | null
    _max: ProxyUserMaxAggregateOutputType | null
  }

  export type ProxyUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProxyUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProxyUserMinAggregateOutputType = {
    id: number | null
    memberId: string | null
    createdAt: Date | null
    proxyUserType: ProxyUserType | null
    name: string | null
    token: string | null
    userId: number | null
  }

  export type ProxyUserMaxAggregateOutputType = {
    id: number | null
    memberId: string | null
    createdAt: Date | null
    proxyUserType: ProxyUserType | null
    name: string | null
    token: string | null
    userId: number | null
  }

  export type ProxyUserCountAggregateOutputType = {
    id: number
    memberId: number
    createdAt: number
    proxyUserType: number
    name: number
    token: number
    userId: number
    _all: number
  }


  export type ProxyUserAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProxyUserSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProxyUserMinAggregateInputType = {
    id?: true
    memberId?: true
    createdAt?: true
    proxyUserType?: true
    name?: true
    token?: true
    userId?: true
  }

  export type ProxyUserMaxAggregateInputType = {
    id?: true
    memberId?: true
    createdAt?: true
    proxyUserType?: true
    name?: true
    token?: true
    userId?: true
  }

  export type ProxyUserCountAggregateInputType = {
    id?: true
    memberId?: true
    createdAt?: true
    proxyUserType?: true
    name?: true
    token?: true
    userId?: true
    _all?: true
  }

  export type ProxyUserAggregateArgs = {
    /**
     * Filter which ProxyUser to aggregate.
     * 
    **/
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ProxyUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxyUsers
    **/
    _count?: true | ProxyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxyUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxyUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyUserMaxAggregateInputType
  }

  export type GetProxyUserAggregateType<T extends ProxyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateProxyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxyUser[P]>
      : GetScalarType<T[P], AggregateProxyUser[P]>
  }




  export type ProxyUserGroupByArgs = {
    where?: ProxyUserWhereInput
    orderBy?: Enumerable<ProxyUserOrderByWithAggregationInput>
    by: Array<ProxyUserScalarFieldEnum>
    having?: ProxyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyUserCountAggregateInputType | true
    _avg?: ProxyUserAvgAggregateInputType
    _sum?: ProxyUserSumAggregateInputType
    _min?: ProxyUserMinAggregateInputType
    _max?: ProxyUserMaxAggregateInputType
  }


  export type ProxyUserGroupByOutputType = {
    id: number
    memberId: string
    createdAt: Date
    proxyUserType: ProxyUserType
    name: string
    token: string
    userId: number | null
    _count: ProxyUserCountAggregateOutputType | null
    _avg: ProxyUserAvgAggregateOutputType | null
    _sum: ProxyUserSumAggregateOutputType | null
    _min: ProxyUserMinAggregateOutputType | null
    _max: ProxyUserMaxAggregateOutputType | null
  }

  type GetProxyUserGroupByPayload<T extends ProxyUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProxyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyUserGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyUserGroupByOutputType[P]>
        }
      >
    >


  export type ProxyUserSelect = {
    id?: boolean
    memberId?: boolean
    createdAt?: boolean
    proxyUserType?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    User?: boolean | UserArgs
    CafeCoupons?: boolean | CafeCouponFindManyArgs
    WishlistProducts?: boolean | WishlistProductFindManyArgs
    _count?: boolean | ProxyUserCountOutputTypeArgs
  }


  export type ProxyUserInclude = {
    User?: boolean | UserArgs
    CafeCoupons?: boolean | CafeCouponFindManyArgs
    WishlistProducts?: boolean | WishlistProductFindManyArgs
    _count?: boolean | ProxyUserCountOutputTypeArgs
  } 

  export type ProxyUserGetPayload<S extends boolean | null | undefined | ProxyUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProxyUser :
    S extends undefined ? never :
    S extends { include: any } & (ProxyUserArgs | ProxyUserFindManyArgs)
    ? ProxyUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends 'CafeCoupons' ? Array < CafeCouponGetPayload<S['include'][P]>>  :
        P extends 'WishlistProducts' ? Array < WishlistProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProxyUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProxyUserArgs | ProxyUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends 'CafeCoupons' ? Array < CafeCouponGetPayload<S['select'][P]>>  :
        P extends 'WishlistProducts' ? Array < WishlistProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProxyUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProxyUser ? ProxyUser[P] : never
  } 
      : ProxyUser


  type ProxyUserCountArgs = Merge<
    Omit<ProxyUserFindManyArgs, 'select' | 'include'> & {
      select?: ProxyUserCountAggregateInputType | true
    }
  >

  export interface ProxyUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ProxyUser that matches the filter.
     * @param {ProxyUserFindUniqueArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProxyUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProxyUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProxyUser'> extends True ? Prisma__ProxyUserClient<ProxyUserGetPayload<T>> : Prisma__ProxyUserClient<ProxyUserGetPayload<T> | null, null>

    /**
     * Find one ProxyUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProxyUserFindUniqueOrThrowArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProxyUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProxyUserFindUniqueOrThrowArgs>
    ): Prisma__ProxyUserClient<ProxyUserGetPayload<T>>

    /**
     * Find the first ProxyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserFindFirstArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProxyUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProxyUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProxyUser'> extends True ? Prisma__ProxyUserClient<ProxyUserGetPayload<T>> : Prisma__ProxyUserClient<ProxyUserGetPayload<T> | null, null>

    /**
     * Find the first ProxyUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserFindFirstOrThrowArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProxyUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProxyUserFindFirstOrThrowArgs>
    ): Prisma__ProxyUserClient<ProxyUserGetPayload<T>>

    /**
     * Find zero or more ProxyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxyUsers
     * const proxyUsers = await prisma.proxyUser.findMany()
     * 
     * // Get first 10 ProxyUsers
     * const proxyUsers = await prisma.proxyUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyUserWithIdOnly = await prisma.proxyUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProxyUserFindManyArgs>(
      args?: SelectSubset<T, ProxyUserFindManyArgs>
    ): PrismaPromise<Array<ProxyUserGetPayload<T>>>

    /**
     * Create a ProxyUser.
     * @param {ProxyUserCreateArgs} args - Arguments to create a ProxyUser.
     * @example
     * // Create one ProxyUser
     * const ProxyUser = await prisma.proxyUser.create({
     *   data: {
     *     // ... data to create a ProxyUser
     *   }
     * })
     * 
    **/
    create<T extends ProxyUserCreateArgs>(
      args: SelectSubset<T, ProxyUserCreateArgs>
    ): Prisma__ProxyUserClient<ProxyUserGetPayload<T>>

    /**
     * Create many ProxyUsers.
     *     @param {ProxyUserCreateManyArgs} args - Arguments to create many ProxyUsers.
     *     @example
     *     // Create many ProxyUsers
     *     const proxyUser = await prisma.proxyUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProxyUserCreateManyArgs>(
      args?: SelectSubset<T, ProxyUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProxyUser.
     * @param {ProxyUserDeleteArgs} args - Arguments to delete one ProxyUser.
     * @example
     * // Delete one ProxyUser
     * const ProxyUser = await prisma.proxyUser.delete({
     *   where: {
     *     // ... filter to delete one ProxyUser
     *   }
     * })
     * 
    **/
    delete<T extends ProxyUserDeleteArgs>(
      args: SelectSubset<T, ProxyUserDeleteArgs>
    ): Prisma__ProxyUserClient<ProxyUserGetPayload<T>>

    /**
     * Update one ProxyUser.
     * @param {ProxyUserUpdateArgs} args - Arguments to update one ProxyUser.
     * @example
     * // Update one ProxyUser
     * const proxyUser = await prisma.proxyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProxyUserUpdateArgs>(
      args: SelectSubset<T, ProxyUserUpdateArgs>
    ): Prisma__ProxyUserClient<ProxyUserGetPayload<T>>

    /**
     * Delete zero or more ProxyUsers.
     * @param {ProxyUserDeleteManyArgs} args - Arguments to filter ProxyUsers to delete.
     * @example
     * // Delete a few ProxyUsers
     * const { count } = await prisma.proxyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProxyUserDeleteManyArgs>(
      args?: SelectSubset<T, ProxyUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxyUsers
     * const proxyUser = await prisma.proxyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProxyUserUpdateManyArgs>(
      args: SelectSubset<T, ProxyUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProxyUser.
     * @param {ProxyUserUpsertArgs} args - Arguments to update or create a ProxyUser.
     * @example
     * // Update or create a ProxyUser
     * const proxyUser = await prisma.proxyUser.upsert({
     *   create: {
     *     // ... data to create a ProxyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxyUser we want to update
     *   }
     * })
    **/
    upsert<T extends ProxyUserUpsertArgs>(
      args: SelectSubset<T, ProxyUserUpsertArgs>
    ): Prisma__ProxyUserClient<ProxyUserGetPayload<T>>

    /**
     * Count the number of ProxyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserCountArgs} args - Arguments to filter ProxyUsers to count.
     * @example
     * // Count the number of ProxyUsers
     * const count = await prisma.proxyUser.count({
     *   where: {
     *     // ... the filter for the ProxyUsers we want to count
     *   }
     * })
    **/
    count<T extends ProxyUserCountArgs>(
      args?: Subset<T, ProxyUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyUserAggregateArgs>(args: Subset<T, ProxyUserAggregateArgs>): PrismaPromise<GetProxyUserAggregateType<T>>

    /**
     * Group by ProxyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyUserGroupByArgs['orderBy'] }
        : { orderBy?: ProxyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProxyUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    CafeCoupons<T extends CafeCouponFindManyArgs= {}>(args?: Subset<T, CafeCouponFindManyArgs>): PrismaPromise<Array<CafeCouponGetPayload<T>>| Null>;

    WishlistProducts<T extends WishlistProductFindManyArgs= {}>(args?: Subset<T, WishlistProductFindManyArgs>): PrismaPromise<Array<WishlistProductGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProxyUser base type for findUnique actions
   */
  export type ProxyUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * Filter, which ProxyUser to fetch.
     * 
    **/
    where: ProxyUserWhereUniqueInput
  }

  /**
   * ProxyUser: findUnique
   */
  export interface ProxyUserFindUniqueArgs extends ProxyUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProxyUser findUniqueOrThrow
   */
  export type ProxyUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * Filter, which ProxyUser to fetch.
     * 
    **/
    where: ProxyUserWhereUniqueInput
  }


  /**
   * ProxyUser base type for findFirst actions
   */
  export type ProxyUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * Filter, which ProxyUser to fetch.
     * 
    **/
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ProxyUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyUsers.
     * 
    **/
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyUsers.
     * 
    **/
    distinct?: Enumerable<ProxyUserScalarFieldEnum>
  }

  /**
   * ProxyUser: findFirst
   */
  export interface ProxyUserFindFirstArgs extends ProxyUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProxyUser findFirstOrThrow
   */
  export type ProxyUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * Filter, which ProxyUser to fetch.
     * 
    **/
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ProxyUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyUsers.
     * 
    **/
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyUsers.
     * 
    **/
    distinct?: Enumerable<ProxyUserScalarFieldEnum>
  }


  /**
   * ProxyUser findMany
   */
  export type ProxyUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * Filter, which ProxyUsers to fetch.
     * 
    **/
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<ProxyUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxyUsers.
     * 
    **/
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProxyUserScalarFieldEnum>
  }


  /**
   * ProxyUser create
   */
  export type ProxyUserCreateArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * The data needed to create a ProxyUser.
     * 
    **/
    data: XOR<ProxyUserCreateInput, ProxyUserUncheckedCreateInput>
  }


  /**
   * ProxyUser createMany
   */
  export type ProxyUserCreateManyArgs = {
    /**
     * The data used to create many ProxyUsers.
     * 
    **/
    data: Enumerable<ProxyUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProxyUser update
   */
  export type ProxyUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * The data needed to update a ProxyUser.
     * 
    **/
    data: XOR<ProxyUserUpdateInput, ProxyUserUncheckedUpdateInput>
    /**
     * Choose, which ProxyUser to update.
     * 
    **/
    where: ProxyUserWhereUniqueInput
  }


  /**
   * ProxyUser updateMany
   */
  export type ProxyUserUpdateManyArgs = {
    /**
     * The data used to update ProxyUsers.
     * 
    **/
    data: XOR<ProxyUserUpdateManyMutationInput, ProxyUserUncheckedUpdateManyInput>
    /**
     * Filter which ProxyUsers to update
     * 
    **/
    where?: ProxyUserWhereInput
  }


  /**
   * ProxyUser upsert
   */
  export type ProxyUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * The filter to search for the ProxyUser to update in case it exists.
     * 
    **/
    where: ProxyUserWhereUniqueInput
    /**
     * In case the ProxyUser found by the `where` argument doesn't exist, create a new ProxyUser with this data.
     * 
    **/
    create: XOR<ProxyUserCreateInput, ProxyUserUncheckedCreateInput>
    /**
     * In case the ProxyUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProxyUserUpdateInput, ProxyUserUncheckedUpdateInput>
  }


  /**
   * ProxyUser delete
   */
  export type ProxyUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
    /**
     * Filter which ProxyUser to delete.
     * 
    **/
    where: ProxyUserWhereUniqueInput
  }


  /**
   * ProxyUser deleteMany
   */
  export type ProxyUserDeleteManyArgs = {
    /**
     * Filter which ProxyUsers to delete
     * 
    **/
    where?: ProxyUserWhereInput
  }


  /**
   * ProxyUser without action
   */
  export type ProxyUserArgs = {
    /**
     * Select specific fields to fetch from the ProxyUser
     * 
    **/
    select?: ProxyUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProxyUserInclude | null
  }



  /**
   * Model CafeCoupon
   */


  export type AggregateCafeCoupon = {
    _count: CafeCouponCountAggregateOutputType | null
    _avg: CafeCouponAvgAggregateOutputType | null
    _sum: CafeCouponSumAggregateOutputType | null
    _min: CafeCouponMinAggregateOutputType | null
    _max: CafeCouponMaxAggregateOutputType | null
  }

  export type CafeCouponAvgAggregateOutputType = {
    id: number | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponSumAggregateOutputType = {
    id: number | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    content: string | null
    serialNumber: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    content: string | null
    serialNumber: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    content: number
    serialNumber: number
    startDay: number
    endDay: number
    isDisable: number
    proxyUserId: number
    cafeCouponGroupId: number
    _all: number
  }


  export type CafeCouponAvgAggregateInputType = {
    id?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponSumAggregateInputType = {
    id?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    content?: true
    serialNumber?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    content?: true
    serialNumber?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    content?: true
    serialNumber?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
    _all?: true
  }

  export type CafeCouponAggregateArgs = {
    /**
     * Filter which CafeCoupon to aggregate.
     * 
    **/
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCoupons
    **/
    _count?: true | CafeCouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponMaxAggregateInputType
  }

  export type GetCafeCouponAggregateType<T extends CafeCouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCoupon[P]>
      : GetScalarType<T[P], AggregateCafeCoupon[P]>
  }




  export type CafeCouponGroupByArgs = {
    where?: CafeCouponWhereInput
    orderBy?: Enumerable<CafeCouponOrderByWithAggregationInput>
    by: Array<CafeCouponScalarFieldEnum>
    having?: CafeCouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponCountAggregateInputType | true
    _avg?: CafeCouponAvgAggregateInputType
    _sum?: CafeCouponSumAggregateInputType
    _min?: CafeCouponMinAggregateInputType
    _max?: CafeCouponMaxAggregateInputType
  }


  export type CafeCouponGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    content: string
    serialNumber: string
    startDay: Date
    endDay: Date | null
    isDisable: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    _count: CafeCouponCountAggregateOutputType | null
    _avg: CafeCouponAvgAggregateOutputType | null
    _sum: CafeCouponSumAggregateOutputType | null
    _min: CafeCouponMinAggregateOutputType | null
    _max: CafeCouponMaxAggregateOutputType | null
  }

  type GetCafeCouponGroupByPayload<T extends CafeCouponGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeCouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponSelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    content?: boolean
    serialNumber?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    proxyUserId?: boolean
    ProxyUser?: boolean | ProxyUserArgs
    cafeCouponGroupId?: boolean
    CafeCouponGroup?: boolean | CafeCouponGroupArgs
    CafeCouponQRCodes?: boolean | CafeCouponQRCodeFindManyArgs
    CafeCouponHistories?: boolean | CafeCouponHistoryFindManyArgs
    _count?: boolean | CafeCouponCountOutputTypeArgs
  }


  export type CafeCouponInclude = {
    ProxyUser?: boolean | ProxyUserArgs
    CafeCouponGroup?: boolean | CafeCouponGroupArgs
    CafeCouponQRCodes?: boolean | CafeCouponQRCodeFindManyArgs
    CafeCouponHistories?: boolean | CafeCouponHistoryFindManyArgs
    _count?: boolean | CafeCouponCountOutputTypeArgs
  } 

  export type CafeCouponGetPayload<S extends boolean | null | undefined | CafeCouponArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCoupon :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponArgs | CafeCouponFindManyArgs)
    ? CafeCoupon  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ProxyUser' ? ProxyUserGetPayload<S['include'][P]> :
        P extends 'CafeCouponGroup' ? CafeCouponGroupGetPayload<S['include'][P]> :
        P extends 'CafeCouponQRCodes' ? Array < CafeCouponQRCodeGetPayload<S['include'][P]>>  :
        P extends 'CafeCouponHistories' ? Array < CafeCouponHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? CafeCouponCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeCouponArgs | CafeCouponFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ProxyUser' ? ProxyUserGetPayload<S['select'][P]> :
        P extends 'CafeCouponGroup' ? CafeCouponGroupGetPayload<S['select'][P]> :
        P extends 'CafeCouponQRCodes' ? Array < CafeCouponQRCodeGetPayload<S['select'][P]>>  :
        P extends 'CafeCouponHistories' ? Array < CafeCouponHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? CafeCouponCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CafeCoupon ? CafeCoupon[P] : never
  } 
      : CafeCoupon


  type CafeCouponCountArgs = Merge<
    Omit<CafeCouponFindManyArgs, 'select' | 'include'> & {
      select?: CafeCouponCountAggregateInputType | true
    }
  >

  export interface CafeCouponDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeCoupon that matches the filter.
     * @param {CafeCouponFindUniqueArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeCouponFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeCouponFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeCoupon'> extends True ? Prisma__CafeCouponClient<CafeCouponGetPayload<T>> : Prisma__CafeCouponClient<CafeCouponGetPayload<T> | null, null>

    /**
     * Find one CafeCoupon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeCouponFindUniqueOrThrowArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeCouponFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponFindUniqueOrThrowArgs>
    ): Prisma__CafeCouponClient<CafeCouponGetPayload<T>>

    /**
     * Find the first CafeCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponFindFirstArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeCouponFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeCouponFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeCoupon'> extends True ? Prisma__CafeCouponClient<CafeCouponGetPayload<T>> : Prisma__CafeCouponClient<CafeCouponGetPayload<T> | null, null>

    /**
     * Find the first CafeCoupon that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponFindFirstOrThrowArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeCouponFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponFindFirstOrThrowArgs>
    ): Prisma__CafeCouponClient<CafeCouponGetPayload<T>>

    /**
     * Find zero or more CafeCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCoupons
     * const cafeCoupons = await prisma.cafeCoupon.findMany()
     * 
     * // Get first 10 CafeCoupons
     * const cafeCoupons = await prisma.cafeCoupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeCouponWithIdOnly = await prisma.cafeCoupon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeCouponFindManyArgs>(
      args?: SelectSubset<T, CafeCouponFindManyArgs>
    ): PrismaPromise<Array<CafeCouponGetPayload<T>>>

    /**
     * Create a CafeCoupon.
     * @param {CafeCouponCreateArgs} args - Arguments to create a CafeCoupon.
     * @example
     * // Create one CafeCoupon
     * const CafeCoupon = await prisma.cafeCoupon.create({
     *   data: {
     *     // ... data to create a CafeCoupon
     *   }
     * })
     * 
    **/
    create<T extends CafeCouponCreateArgs>(
      args: SelectSubset<T, CafeCouponCreateArgs>
    ): Prisma__CafeCouponClient<CafeCouponGetPayload<T>>

    /**
     * Create many CafeCoupons.
     *     @param {CafeCouponCreateManyArgs} args - Arguments to create many CafeCoupons.
     *     @example
     *     // Create many CafeCoupons
     *     const cafeCoupon = await prisma.cafeCoupon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeCouponCreateManyArgs>(
      args?: SelectSubset<T, CafeCouponCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeCoupon.
     * @param {CafeCouponDeleteArgs} args - Arguments to delete one CafeCoupon.
     * @example
     * // Delete one CafeCoupon
     * const CafeCoupon = await prisma.cafeCoupon.delete({
     *   where: {
     *     // ... filter to delete one CafeCoupon
     *   }
     * })
     * 
    **/
    delete<T extends CafeCouponDeleteArgs>(
      args: SelectSubset<T, CafeCouponDeleteArgs>
    ): Prisma__CafeCouponClient<CafeCouponGetPayload<T>>

    /**
     * Update one CafeCoupon.
     * @param {CafeCouponUpdateArgs} args - Arguments to update one CafeCoupon.
     * @example
     * // Update one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeCouponUpdateArgs>(
      args: SelectSubset<T, CafeCouponUpdateArgs>
    ): Prisma__CafeCouponClient<CafeCouponGetPayload<T>>

    /**
     * Delete zero or more CafeCoupons.
     * @param {CafeCouponDeleteManyArgs} args - Arguments to filter CafeCoupons to delete.
     * @example
     * // Delete a few CafeCoupons
     * const { count } = await prisma.cafeCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeCouponDeleteManyArgs>(
      args?: SelectSubset<T, CafeCouponDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCoupons
     * const cafeCoupon = await prisma.cafeCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeCouponUpdateManyArgs>(
      args: SelectSubset<T, CafeCouponUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeCoupon.
     * @param {CafeCouponUpsertArgs} args - Arguments to update or create a CafeCoupon.
     * @example
     * // Update or create a CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.upsert({
     *   create: {
     *     // ... data to create a CafeCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCoupon we want to update
     *   }
     * })
    **/
    upsert<T extends CafeCouponUpsertArgs>(
      args: SelectSubset<T, CafeCouponUpsertArgs>
    ): Prisma__CafeCouponClient<CafeCouponGetPayload<T>>

    /**
     * Count the number of CafeCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponCountArgs} args - Arguments to filter CafeCoupons to count.
     * @example
     * // Count the number of CafeCoupons
     * const count = await prisma.cafeCoupon.count({
     *   where: {
     *     // ... the filter for the CafeCoupons we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponCountArgs>(
      args?: Subset<T, CafeCouponCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponAggregateArgs>(args: Subset<T, CafeCouponAggregateArgs>): PrismaPromise<GetCafeCouponAggregateType<T>>

    /**
     * Group by CafeCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeCouponClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProxyUser<T extends ProxyUserArgs= {}>(args?: Subset<T, ProxyUserArgs>): Prisma__ProxyUserClient<ProxyUserGetPayload<T> | Null>;

    CafeCouponGroup<T extends CafeCouponGroupArgs= {}>(args?: Subset<T, CafeCouponGroupArgs>): Prisma__CafeCouponGroupClient<CafeCouponGroupGetPayload<T> | Null>;

    CafeCouponQRCodes<T extends CafeCouponQRCodeFindManyArgs= {}>(args?: Subset<T, CafeCouponQRCodeFindManyArgs>): PrismaPromise<Array<CafeCouponQRCodeGetPayload<T>>| Null>;

    CafeCouponHistories<T extends CafeCouponHistoryFindManyArgs= {}>(args?: Subset<T, CafeCouponHistoryFindManyArgs>): PrismaPromise<Array<CafeCouponHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeCoupon base type for findUnique actions
   */
  export type CafeCouponFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * Filter, which CafeCoupon to fetch.
     * 
    **/
    where: CafeCouponWhereUniqueInput
  }

  /**
   * CafeCoupon: findUnique
   */
  export interface CafeCouponFindUniqueArgs extends CafeCouponFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCoupon findUniqueOrThrow
   */
  export type CafeCouponFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * Filter, which CafeCoupon to fetch.
     * 
    **/
    where: CafeCouponWhereUniqueInput
  }


  /**
   * CafeCoupon base type for findFirst actions
   */
  export type CafeCouponFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * Filter, which CafeCoupon to fetch.
     * 
    **/
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCoupons.
     * 
    **/
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCoupons.
     * 
    **/
    distinct?: Enumerable<CafeCouponScalarFieldEnum>
  }

  /**
   * CafeCoupon: findFirst
   */
  export interface CafeCouponFindFirstArgs extends CafeCouponFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCoupon findFirstOrThrow
   */
  export type CafeCouponFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * Filter, which CafeCoupon to fetch.
     * 
    **/
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCoupons.
     * 
    **/
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCoupons.
     * 
    **/
    distinct?: Enumerable<CafeCouponScalarFieldEnum>
  }


  /**
   * CafeCoupon findMany
   */
  export type CafeCouponFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * Filter, which CafeCoupons to fetch.
     * 
    **/
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCoupons.
     * 
    **/
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeCouponScalarFieldEnum>
  }


  /**
   * CafeCoupon create
   */
  export type CafeCouponCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * The data needed to create a CafeCoupon.
     * 
    **/
    data: XOR<CafeCouponCreateInput, CafeCouponUncheckedCreateInput>
  }


  /**
   * CafeCoupon createMany
   */
  export type CafeCouponCreateManyArgs = {
    /**
     * The data used to create many CafeCoupons.
     * 
    **/
    data: Enumerable<CafeCouponCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeCoupon update
   */
  export type CafeCouponUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * The data needed to update a CafeCoupon.
     * 
    **/
    data: XOR<CafeCouponUpdateInput, CafeCouponUncheckedUpdateInput>
    /**
     * Choose, which CafeCoupon to update.
     * 
    **/
    where: CafeCouponWhereUniqueInput
  }


  /**
   * CafeCoupon updateMany
   */
  export type CafeCouponUpdateManyArgs = {
    /**
     * The data used to update CafeCoupons.
     * 
    **/
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyInput>
    /**
     * Filter which CafeCoupons to update
     * 
    **/
    where?: CafeCouponWhereInput
  }


  /**
   * CafeCoupon upsert
   */
  export type CafeCouponUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * The filter to search for the CafeCoupon to update in case it exists.
     * 
    **/
    where: CafeCouponWhereUniqueInput
    /**
     * In case the CafeCoupon found by the `where` argument doesn't exist, create a new CafeCoupon with this data.
     * 
    **/
    create: XOR<CafeCouponCreateInput, CafeCouponUncheckedCreateInput>
    /**
     * In case the CafeCoupon was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeCouponUpdateInput, CafeCouponUncheckedUpdateInput>
  }


  /**
   * CafeCoupon delete
   */
  export type CafeCouponDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
    /**
     * Filter which CafeCoupon to delete.
     * 
    **/
    where: CafeCouponWhereUniqueInput
  }


  /**
   * CafeCoupon deleteMany
   */
  export type CafeCouponDeleteManyArgs = {
    /**
     * Filter which CafeCoupons to delete
     * 
    **/
    where?: CafeCouponWhereInput
  }


  /**
   * CafeCoupon without action
   */
  export type CafeCouponArgs = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     * 
    **/
    select?: CafeCouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponInclude | null
  }



  /**
   * Model CafeCouponHistory
   */


  export type AggregateCafeCouponHistory = {
    _count: CafeCouponHistoryCountAggregateOutputType | null
    _avg: CafeCouponHistoryAvgAggregateOutputType | null
    _sum: CafeCouponHistorySumAggregateOutputType | null
    _min: CafeCouponHistoryMinAggregateOutputType | null
    _max: CafeCouponHistoryMaxAggregateOutputType | null
  }

  export type CafeCouponHistoryAvgAggregateOutputType = {
    id: number | null
    cafeCouponId: number | null
    actorId: number | null
  }

  export type CafeCouponHistorySumAggregateOutputType = {
    id: number | null
    cafeCouponId: number | null
    actorId: number | null
  }

  export type CafeCouponHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    cafeCouponId: number | null
    eventType: CafeCouponEventType | null
    description: string | null
    actorId: number | null
    statusBefore: CafeCouponStatus | null
    statusAfter: CafeCouponStatus | null
  }

  export type CafeCouponHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    cafeCouponId: number | null
    eventType: CafeCouponEventType | null
    description: string | null
    actorId: number | null
    statusBefore: CafeCouponStatus | null
    statusAfter: CafeCouponStatus | null
  }

  export type CafeCouponHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    cafeCouponId: number
    eventType: number
    description: number
    actorId: number
    statusBefore: number
    statusAfter: number
    _all: number
  }


  export type CafeCouponHistoryAvgAggregateInputType = {
    id?: true
    cafeCouponId?: true
    actorId?: true
  }

  export type CafeCouponHistorySumAggregateInputType = {
    id?: true
    cafeCouponId?: true
    actorId?: true
  }

  export type CafeCouponHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    cafeCouponId?: true
    eventType?: true
    description?: true
    actorId?: true
    statusBefore?: true
    statusAfter?: true
  }

  export type CafeCouponHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    cafeCouponId?: true
    eventType?: true
    description?: true
    actorId?: true
    statusBefore?: true
    statusAfter?: true
  }

  export type CafeCouponHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    cafeCouponId?: true
    eventType?: true
    description?: true
    actorId?: true
    statusBefore?: true
    statusAfter?: true
    _all?: true
  }

  export type CafeCouponHistoryAggregateArgs = {
    /**
     * Filter which CafeCouponHistory to aggregate.
     * 
    **/
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponHistories
    **/
    _count?: true | CafeCouponHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponHistoryMaxAggregateInputType
  }

  export type GetCafeCouponHistoryAggregateType<T extends CafeCouponHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponHistory[P]>
      : GetScalarType<T[P], AggregateCafeCouponHistory[P]>
  }




  export type CafeCouponHistoryGroupByArgs = {
    where?: CafeCouponHistoryWhereInput
    orderBy?: Enumerable<CafeCouponHistoryOrderByWithAggregationInput>
    by: Array<CafeCouponHistoryScalarFieldEnum>
    having?: CafeCouponHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponHistoryCountAggregateInputType | true
    _avg?: CafeCouponHistoryAvgAggregateInputType
    _sum?: CafeCouponHistorySumAggregateInputType
    _min?: CafeCouponHistoryMinAggregateInputType
    _max?: CafeCouponHistoryMaxAggregateInputType
  }


  export type CafeCouponHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    cafeCouponId: number
    eventType: CafeCouponEventType
    description: string
    actorId: number
    statusBefore: CafeCouponStatus | null
    statusAfter: CafeCouponStatus | null
    _count: CafeCouponHistoryCountAggregateOutputType | null
    _avg: CafeCouponHistoryAvgAggregateOutputType | null
    _sum: CafeCouponHistorySumAggregateOutputType | null
    _min: CafeCouponHistoryMinAggregateOutputType | null
    _max: CafeCouponHistoryMaxAggregateOutputType | null
  }

  type GetCafeCouponHistoryGroupByPayload<T extends CafeCouponHistoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeCouponHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponHistorySelect = {
    id?: boolean
    createdAt?: boolean
    cafeCouponId?: boolean
    CafeCoupon?: boolean | CafeCouponArgs
    eventType?: boolean
    description?: boolean
    actorId?: boolean
    Actor?: boolean | UserArgs
    statusBefore?: boolean
    statusAfter?: boolean
  }


  export type CafeCouponHistoryInclude = {
    CafeCoupon?: boolean | CafeCouponArgs
    Actor?: boolean | UserArgs
  } 

  export type CafeCouponHistoryGetPayload<S extends boolean | null | undefined | CafeCouponHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCouponHistory :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponHistoryArgs | CafeCouponHistoryFindManyArgs)
    ? CafeCouponHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeCoupon' ? CafeCouponGetPayload<S['include'][P]> :
        P extends 'Actor' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CafeCouponHistoryArgs | CafeCouponHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeCoupon' ? CafeCouponGetPayload<S['select'][P]> :
        P extends 'Actor' ? UserGetPayload<S['select'][P]> :  P extends keyof CafeCouponHistory ? CafeCouponHistory[P] : never
  } 
      : CafeCouponHistory


  type CafeCouponHistoryCountArgs = Merge<
    Omit<CafeCouponHistoryFindManyArgs, 'select' | 'include'> & {
      select?: CafeCouponHistoryCountAggregateInputType | true
    }
  >

  export interface CafeCouponHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeCouponHistory that matches the filter.
     * @param {CafeCouponHistoryFindUniqueArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeCouponHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeCouponHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeCouponHistory'> extends True ? Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>> : Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T> | null, null>

    /**
     * Find one CafeCouponHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeCouponHistoryFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeCouponHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponHistoryFindUniqueOrThrowArgs>
    ): Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>>

    /**
     * Find the first CafeCouponHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryFindFirstArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeCouponHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeCouponHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeCouponHistory'> extends True ? Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>> : Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T> | null, null>

    /**
     * Find the first CafeCouponHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryFindFirstOrThrowArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeCouponHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponHistoryFindFirstOrThrowArgs>
    ): Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>>

    /**
     * Find zero or more CafeCouponHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponHistories
     * const cafeCouponHistories = await prisma.cafeCouponHistory.findMany()
     * 
     * // Get first 10 CafeCouponHistories
     * const cafeCouponHistories = await prisma.cafeCouponHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeCouponHistoryWithIdOnly = await prisma.cafeCouponHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CafeCouponHistoryFindManyArgs>(
      args?: SelectSubset<T, CafeCouponHistoryFindManyArgs>
    ): PrismaPromise<Array<CafeCouponHistoryGetPayload<T>>>

    /**
     * Create a CafeCouponHistory.
     * @param {CafeCouponHistoryCreateArgs} args - Arguments to create a CafeCouponHistory.
     * @example
     * // Create one CafeCouponHistory
     * const CafeCouponHistory = await prisma.cafeCouponHistory.create({
     *   data: {
     *     // ... data to create a CafeCouponHistory
     *   }
     * })
     * 
    **/
    create<T extends CafeCouponHistoryCreateArgs>(
      args: SelectSubset<T, CafeCouponHistoryCreateArgs>
    ): Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>>

    /**
     * Create many CafeCouponHistories.
     *     @param {CafeCouponHistoryCreateManyArgs} args - Arguments to create many CafeCouponHistories.
     *     @example
     *     // Create many CafeCouponHistories
     *     const cafeCouponHistory = await prisma.cafeCouponHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeCouponHistoryCreateManyArgs>(
      args?: SelectSubset<T, CafeCouponHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeCouponHistory.
     * @param {CafeCouponHistoryDeleteArgs} args - Arguments to delete one CafeCouponHistory.
     * @example
     * // Delete one CafeCouponHistory
     * const CafeCouponHistory = await prisma.cafeCouponHistory.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponHistory
     *   }
     * })
     * 
    **/
    delete<T extends CafeCouponHistoryDeleteArgs>(
      args: SelectSubset<T, CafeCouponHistoryDeleteArgs>
    ): Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>>

    /**
     * Update one CafeCouponHistory.
     * @param {CafeCouponHistoryUpdateArgs} args - Arguments to update one CafeCouponHistory.
     * @example
     * // Update one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeCouponHistoryUpdateArgs>(
      args: SelectSubset<T, CafeCouponHistoryUpdateArgs>
    ): Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>>

    /**
     * Delete zero or more CafeCouponHistories.
     * @param {CafeCouponHistoryDeleteManyArgs} args - Arguments to filter CafeCouponHistories to delete.
     * @example
     * // Delete a few CafeCouponHistories
     * const { count } = await prisma.cafeCouponHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeCouponHistoryDeleteManyArgs>(
      args?: SelectSubset<T, CafeCouponHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponHistories
     * const cafeCouponHistory = await prisma.cafeCouponHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeCouponHistoryUpdateManyArgs>(
      args: SelectSubset<T, CafeCouponHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeCouponHistory.
     * @param {CafeCouponHistoryUpsertArgs} args - Arguments to update or create a CafeCouponHistory.
     * @example
     * // Update or create a CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.upsert({
     *   create: {
     *     // ... data to create a CafeCouponHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponHistory we want to update
     *   }
     * })
    **/
    upsert<T extends CafeCouponHistoryUpsertArgs>(
      args: SelectSubset<T, CafeCouponHistoryUpsertArgs>
    ): Prisma__CafeCouponHistoryClient<CafeCouponHistoryGetPayload<T>>

    /**
     * Count the number of CafeCouponHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryCountArgs} args - Arguments to filter CafeCouponHistories to count.
     * @example
     * // Count the number of CafeCouponHistories
     * const count = await prisma.cafeCouponHistory.count({
     *   where: {
     *     // ... the filter for the CafeCouponHistories we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponHistoryCountArgs>(
      args?: Subset<T, CafeCouponHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponHistoryAggregateArgs>(args: Subset<T, CafeCouponHistoryAggregateArgs>): PrismaPromise<GetCafeCouponHistoryAggregateType<T>>

    /**
     * Group by CafeCouponHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponHistoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeCouponHistoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeCoupon<T extends CafeCouponArgs= {}>(args?: Subset<T, CafeCouponArgs>): Prisma__CafeCouponClient<CafeCouponGetPayload<T> | Null>;

    Actor<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeCouponHistory base type for findUnique actions
   */
  export type CafeCouponHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     * 
    **/
    where: CafeCouponHistoryWhereUniqueInput
  }

  /**
   * CafeCouponHistory: findUnique
   */
  export interface CafeCouponHistoryFindUniqueArgs extends CafeCouponHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponHistory findUniqueOrThrow
   */
  export type CafeCouponHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     * 
    **/
    where: CafeCouponHistoryWhereUniqueInput
  }


  /**
   * CafeCouponHistory base type for findFirst actions
   */
  export type CafeCouponHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     * 
    **/
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponHistories.
     * 
    **/
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponHistories.
     * 
    **/
    distinct?: Enumerable<CafeCouponHistoryScalarFieldEnum>
  }

  /**
   * CafeCouponHistory: findFirst
   */
  export interface CafeCouponHistoryFindFirstArgs extends CafeCouponHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponHistory findFirstOrThrow
   */
  export type CafeCouponHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     * 
    **/
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponHistories.
     * 
    **/
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponHistories.
     * 
    **/
    distinct?: Enumerable<CafeCouponHistoryScalarFieldEnum>
  }


  /**
   * CafeCouponHistory findMany
   */
  export type CafeCouponHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * Filter, which CafeCouponHistories to fetch.
     * 
    **/
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponHistories.
     * 
    **/
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeCouponHistoryScalarFieldEnum>
  }


  /**
   * CafeCouponHistory create
   */
  export type CafeCouponHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * The data needed to create a CafeCouponHistory.
     * 
    **/
    data: XOR<CafeCouponHistoryCreateInput, CafeCouponHistoryUncheckedCreateInput>
  }


  /**
   * CafeCouponHistory createMany
   */
  export type CafeCouponHistoryCreateManyArgs = {
    /**
     * The data used to create many CafeCouponHistories.
     * 
    **/
    data: Enumerable<CafeCouponHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeCouponHistory update
   */
  export type CafeCouponHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * The data needed to update a CafeCouponHistory.
     * 
    **/
    data: XOR<CafeCouponHistoryUpdateInput, CafeCouponHistoryUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponHistory to update.
     * 
    **/
    where: CafeCouponHistoryWhereUniqueInput
  }


  /**
   * CafeCouponHistory updateMany
   */
  export type CafeCouponHistoryUpdateManyArgs = {
    /**
     * The data used to update CafeCouponHistories.
     * 
    **/
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponHistories to update
     * 
    **/
    where?: CafeCouponHistoryWhereInput
  }


  /**
   * CafeCouponHistory upsert
   */
  export type CafeCouponHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * The filter to search for the CafeCouponHistory to update in case it exists.
     * 
    **/
    where: CafeCouponHistoryWhereUniqueInput
    /**
     * In case the CafeCouponHistory found by the `where` argument doesn't exist, create a new CafeCouponHistory with this data.
     * 
    **/
    create: XOR<CafeCouponHistoryCreateInput, CafeCouponHistoryUncheckedCreateInput>
    /**
     * In case the CafeCouponHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeCouponHistoryUpdateInput, CafeCouponHistoryUncheckedUpdateInput>
  }


  /**
   * CafeCouponHistory delete
   */
  export type CafeCouponHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
    /**
     * Filter which CafeCouponHistory to delete.
     * 
    **/
    where: CafeCouponHistoryWhereUniqueInput
  }


  /**
   * CafeCouponHistory deleteMany
   */
  export type CafeCouponHistoryDeleteManyArgs = {
    /**
     * Filter which CafeCouponHistories to delete
     * 
    **/
    where?: CafeCouponHistoryWhereInput
  }


  /**
   * CafeCouponHistory without action
   */
  export type CafeCouponHistoryArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     * 
    **/
    select?: CafeCouponHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponHistoryInclude | null
  }



  /**
   * Model CafeCouponQRCode
   */


  export type AggregateCafeCouponQRCode = {
    _count: CafeCouponQRCodeCountAggregateOutputType | null
    _avg: CafeCouponQRCodeAvgAggregateOutputType | null
    _sum: CafeCouponQRCodeSumAggregateOutputType | null
    _min: CafeCouponQRCodeMinAggregateOutputType | null
    _max: CafeCouponQRCodeMaxAggregateOutputType | null
  }

  export type CafeCouponQRCodeAvgAggregateOutputType = {
    cafeCouponId: number | null
    size: number | null
  }

  export type CafeCouponQRCodeSumAggregateOutputType = {
    cafeCouponId: number | null
    size: number | null
  }

  export type CafeCouponQRCodeMinAggregateOutputType = {
    serialNumber: string | null
    createdAt: Date | null
    isDisable: boolean | null
    cafeCouponId: number | null
    size: number | null
    base64Data: string | null
  }

  export type CafeCouponQRCodeMaxAggregateOutputType = {
    serialNumber: string | null
    createdAt: Date | null
    isDisable: boolean | null
    cafeCouponId: number | null
    size: number | null
    base64Data: string | null
  }

  export type CafeCouponQRCodeCountAggregateOutputType = {
    serialNumber: number
    createdAt: number
    isDisable: number
    cafeCouponId: number
    size: number
    base64Data: number
    _all: number
  }


  export type CafeCouponQRCodeAvgAggregateInputType = {
    cafeCouponId?: true
    size?: true
  }

  export type CafeCouponQRCodeSumAggregateInputType = {
    cafeCouponId?: true
    size?: true
  }

  export type CafeCouponQRCodeMinAggregateInputType = {
    serialNumber?: true
    createdAt?: true
    isDisable?: true
    cafeCouponId?: true
    size?: true
    base64Data?: true
  }

  export type CafeCouponQRCodeMaxAggregateInputType = {
    serialNumber?: true
    createdAt?: true
    isDisable?: true
    cafeCouponId?: true
    size?: true
    base64Data?: true
  }

  export type CafeCouponQRCodeCountAggregateInputType = {
    serialNumber?: true
    createdAt?: true
    isDisable?: true
    cafeCouponId?: true
    size?: true
    base64Data?: true
    _all?: true
  }

  export type CafeCouponQRCodeAggregateArgs = {
    /**
     * Filter which CafeCouponQRCode to aggregate.
     * 
    **/
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponQRCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponQRCodes
    **/
    _count?: true | CafeCouponQRCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponQRCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponQRCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponQRCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponQRCodeMaxAggregateInputType
  }

  export type GetCafeCouponQRCodeAggregateType<T extends CafeCouponQRCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponQRCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponQRCode[P]>
      : GetScalarType<T[P], AggregateCafeCouponQRCode[P]>
  }




  export type CafeCouponQRCodeGroupByArgs = {
    where?: CafeCouponQRCodeWhereInput
    orderBy?: Enumerable<CafeCouponQRCodeOrderByWithAggregationInput>
    by: Array<CafeCouponQRCodeScalarFieldEnum>
    having?: CafeCouponQRCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponQRCodeCountAggregateInputType | true
    _avg?: CafeCouponQRCodeAvgAggregateInputType
    _sum?: CafeCouponQRCodeSumAggregateInputType
    _min?: CafeCouponQRCodeMinAggregateInputType
    _max?: CafeCouponQRCodeMaxAggregateInputType
  }


  export type CafeCouponQRCodeGroupByOutputType = {
    serialNumber: string
    createdAt: Date
    isDisable: boolean
    cafeCouponId: number | null
    size: number
    base64Data: string
    _count: CafeCouponQRCodeCountAggregateOutputType | null
    _avg: CafeCouponQRCodeAvgAggregateOutputType | null
    _sum: CafeCouponQRCodeSumAggregateOutputType | null
    _min: CafeCouponQRCodeMinAggregateOutputType | null
    _max: CafeCouponQRCodeMaxAggregateOutputType | null
  }

  type GetCafeCouponQRCodeGroupByPayload<T extends CafeCouponQRCodeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CafeCouponQRCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponQRCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponQRCodeGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponQRCodeGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponQRCodeSelect = {
    serialNumber?: boolean
    createdAt?: boolean
    isDisable?: boolean
    cafeCouponId?: boolean
    CafeCoupon?: boolean | CafeCouponArgs
    size?: boolean
    base64Data?: boolean
  }


  export type CafeCouponQRCodeInclude = {
    CafeCoupon?: boolean | CafeCouponArgs
  } 

  export type CafeCouponQRCodeGetPayload<S extends boolean | null | undefined | CafeCouponQRCodeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CafeCouponQRCode :
    S extends undefined ? never :
    S extends { include: any } & (CafeCouponQRCodeArgs | CafeCouponQRCodeFindManyArgs)
    ? CafeCouponQRCode  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeCoupon' ? CafeCouponGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CafeCouponQRCodeArgs | CafeCouponQRCodeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeCoupon' ? CafeCouponGetPayload<S['select'][P]> | null :  P extends keyof CafeCouponQRCode ? CafeCouponQRCode[P] : never
  } 
      : CafeCouponQRCode


  type CafeCouponQRCodeCountArgs = Merge<
    Omit<CafeCouponQRCodeFindManyArgs, 'select' | 'include'> & {
      select?: CafeCouponQRCodeCountAggregateInputType | true
    }
  >

  export interface CafeCouponQRCodeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CafeCouponQRCode that matches the filter.
     * @param {CafeCouponQRCodeFindUniqueArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CafeCouponQRCodeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CafeCouponQRCodeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CafeCouponQRCode'> extends True ? Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>> : Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T> | null, null>

    /**
     * Find one CafeCouponQRCode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CafeCouponQRCodeFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CafeCouponQRCodeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponQRCodeFindUniqueOrThrowArgs>
    ): Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>>

    /**
     * Find the first CafeCouponQRCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeFindFirstArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CafeCouponQRCodeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CafeCouponQRCodeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CafeCouponQRCode'> extends True ? Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>> : Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T> | null, null>

    /**
     * Find the first CafeCouponQRCode that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeFindFirstOrThrowArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CafeCouponQRCodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CafeCouponQRCodeFindFirstOrThrowArgs>
    ): Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>>

    /**
     * Find zero or more CafeCouponQRCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponQRCodes
     * const cafeCouponQRCodes = await prisma.cafeCouponQRCode.findMany()
     * 
     * // Get first 10 CafeCouponQRCodes
     * const cafeCouponQRCodes = await prisma.cafeCouponQRCode.findMany({ take: 10 })
     * 
     * // Only select the `serialNumber`
     * const cafeCouponQRCodeWithSerialNumberOnly = await prisma.cafeCouponQRCode.findMany({ select: { serialNumber: true } })
     * 
    **/
    findMany<T extends CafeCouponQRCodeFindManyArgs>(
      args?: SelectSubset<T, CafeCouponQRCodeFindManyArgs>
    ): PrismaPromise<Array<CafeCouponQRCodeGetPayload<T>>>

    /**
     * Create a CafeCouponQRCode.
     * @param {CafeCouponQRCodeCreateArgs} args - Arguments to create a CafeCouponQRCode.
     * @example
     * // Create one CafeCouponQRCode
     * const CafeCouponQRCode = await prisma.cafeCouponQRCode.create({
     *   data: {
     *     // ... data to create a CafeCouponQRCode
     *   }
     * })
     * 
    **/
    create<T extends CafeCouponQRCodeCreateArgs>(
      args: SelectSubset<T, CafeCouponQRCodeCreateArgs>
    ): Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>>

    /**
     * Create many CafeCouponQRCodes.
     *     @param {CafeCouponQRCodeCreateManyArgs} args - Arguments to create many CafeCouponQRCodes.
     *     @example
     *     // Create many CafeCouponQRCodes
     *     const cafeCouponQRCode = await prisma.cafeCouponQRCode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CafeCouponQRCodeCreateManyArgs>(
      args?: SelectSubset<T, CafeCouponQRCodeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CafeCouponQRCode.
     * @param {CafeCouponQRCodeDeleteArgs} args - Arguments to delete one CafeCouponQRCode.
     * @example
     * // Delete one CafeCouponQRCode
     * const CafeCouponQRCode = await prisma.cafeCouponQRCode.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponQRCode
     *   }
     * })
     * 
    **/
    delete<T extends CafeCouponQRCodeDeleteArgs>(
      args: SelectSubset<T, CafeCouponQRCodeDeleteArgs>
    ): Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>>

    /**
     * Update one CafeCouponQRCode.
     * @param {CafeCouponQRCodeUpdateArgs} args - Arguments to update one CafeCouponQRCode.
     * @example
     * // Update one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CafeCouponQRCodeUpdateArgs>(
      args: SelectSubset<T, CafeCouponQRCodeUpdateArgs>
    ): Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>>

    /**
     * Delete zero or more CafeCouponQRCodes.
     * @param {CafeCouponQRCodeDeleteManyArgs} args - Arguments to filter CafeCouponQRCodes to delete.
     * @example
     * // Delete a few CafeCouponQRCodes
     * const { count } = await prisma.cafeCouponQRCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CafeCouponQRCodeDeleteManyArgs>(
      args?: SelectSubset<T, CafeCouponQRCodeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponQRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponQRCodes
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CafeCouponQRCodeUpdateManyArgs>(
      args: SelectSubset<T, CafeCouponQRCodeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CafeCouponQRCode.
     * @param {CafeCouponQRCodeUpsertArgs} args - Arguments to update or create a CafeCouponQRCode.
     * @example
     * // Update or create a CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.upsert({
     *   create: {
     *     // ... data to create a CafeCouponQRCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponQRCode we want to update
     *   }
     * })
    **/
    upsert<T extends CafeCouponQRCodeUpsertArgs>(
      args: SelectSubset<T, CafeCouponQRCodeUpsertArgs>
    ): Prisma__CafeCouponQRCodeClient<CafeCouponQRCodeGetPayload<T>>

    /**
     * Count the number of CafeCouponQRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeCountArgs} args - Arguments to filter CafeCouponQRCodes to count.
     * @example
     * // Count the number of CafeCouponQRCodes
     * const count = await prisma.cafeCouponQRCode.count({
     *   where: {
     *     // ... the filter for the CafeCouponQRCodes we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponQRCodeCountArgs>(
      args?: Subset<T, CafeCouponQRCodeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponQRCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponQRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponQRCodeAggregateArgs>(args: Subset<T, CafeCouponQRCodeAggregateArgs>): PrismaPromise<GetCafeCouponQRCodeAggregateType<T>>

    /**
     * Group by CafeCouponQRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponQRCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponQRCodeGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponQRCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponQRCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponQRCodeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponQRCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CafeCouponQRCodeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeCoupon<T extends CafeCouponArgs= {}>(args?: Subset<T, CafeCouponArgs>): Prisma__CafeCouponClient<CafeCouponGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CafeCouponQRCode base type for findUnique actions
   */
  export type CafeCouponQRCodeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     * 
    **/
    where: CafeCouponQRCodeWhereUniqueInput
  }

  /**
   * CafeCouponQRCode: findUnique
   */
  export interface CafeCouponQRCodeFindUniqueArgs extends CafeCouponQRCodeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponQRCode findUniqueOrThrow
   */
  export type CafeCouponQRCodeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     * 
    **/
    where: CafeCouponQRCodeWhereUniqueInput
  }


  /**
   * CafeCouponQRCode base type for findFirst actions
   */
  export type CafeCouponQRCodeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     * 
    **/
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponQRCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponQRCodes.
     * 
    **/
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponQRCodes.
     * 
    **/
    distinct?: Enumerable<CafeCouponQRCodeScalarFieldEnum>
  }

  /**
   * CafeCouponQRCode: findFirst
   */
  export interface CafeCouponQRCodeFindFirstArgs extends CafeCouponQRCodeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CafeCouponQRCode findFirstOrThrow
   */
  export type CafeCouponQRCodeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     * 
    **/
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponQRCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponQRCodes.
     * 
    **/
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponQRCodes.
     * 
    **/
    distinct?: Enumerable<CafeCouponQRCodeScalarFieldEnum>
  }


  /**
   * CafeCouponQRCode findMany
   */
  export type CafeCouponQRCodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * Filter, which CafeCouponQRCodes to fetch.
     * 
    **/
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     * 
    **/
    orderBy?: Enumerable<CafeCouponQRCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponQRCodes.
     * 
    **/
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CafeCouponQRCodeScalarFieldEnum>
  }


  /**
   * CafeCouponQRCode create
   */
  export type CafeCouponQRCodeCreateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * The data needed to create a CafeCouponQRCode.
     * 
    **/
    data: XOR<CafeCouponQRCodeCreateInput, CafeCouponQRCodeUncheckedCreateInput>
  }


  /**
   * CafeCouponQRCode createMany
   */
  export type CafeCouponQRCodeCreateManyArgs = {
    /**
     * The data used to create many CafeCouponQRCodes.
     * 
    **/
    data: Enumerable<CafeCouponQRCodeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CafeCouponQRCode update
   */
  export type CafeCouponQRCodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * The data needed to update a CafeCouponQRCode.
     * 
    **/
    data: XOR<CafeCouponQRCodeUpdateInput, CafeCouponQRCodeUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponQRCode to update.
     * 
    **/
    where: CafeCouponQRCodeWhereUniqueInput
  }


  /**
   * CafeCouponQRCode updateMany
   */
  export type CafeCouponQRCodeUpdateManyArgs = {
    /**
     * The data used to update CafeCouponQRCodes.
     * 
    **/
    data: XOR<CafeCouponQRCodeUpdateManyMutationInput, CafeCouponQRCodeUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponQRCodes to update
     * 
    **/
    where?: CafeCouponQRCodeWhereInput
  }


  /**
   * CafeCouponQRCode upsert
   */
  export type CafeCouponQRCodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * The filter to search for the CafeCouponQRCode to update in case it exists.
     * 
    **/
    where: CafeCouponQRCodeWhereUniqueInput
    /**
     * In case the CafeCouponQRCode found by the `where` argument doesn't exist, create a new CafeCouponQRCode with this data.
     * 
    **/
    create: XOR<CafeCouponQRCodeCreateInput, CafeCouponQRCodeUncheckedCreateInput>
    /**
     * In case the CafeCouponQRCode was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CafeCouponQRCodeUpdateInput, CafeCouponQRCodeUncheckedUpdateInput>
  }


  /**
   * CafeCouponQRCode delete
   */
  export type CafeCouponQRCodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
    /**
     * Filter which CafeCouponQRCode to delete.
     * 
    **/
    where: CafeCouponQRCodeWhereUniqueInput
  }


  /**
   * CafeCouponQRCode deleteMany
   */
  export type CafeCouponQRCodeDeleteManyArgs = {
    /**
     * Filter which CafeCouponQRCodes to delete
     * 
    **/
    where?: CafeCouponQRCodeWhereInput
  }


  /**
   * CafeCouponQRCode without action
   */
  export type CafeCouponQRCodeArgs = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     * 
    **/
    select?: CafeCouponQRCodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CafeCouponQRCodeInclude | null
  }



  /**
   * Model MetaViewerInfo
   */


  export type AggregateMetaViewerInfo = {
    _count: MetaViewerInfoCountAggregateOutputType | null
    _avg: MetaViewerInfoAvgAggregateOutputType | null
    _sum: MetaViewerInfoSumAggregateOutputType | null
    _min: MetaViewerInfoMinAggregateOutputType | null
    _max: MetaViewerInfoMaxAggregateOutputType | null
  }

  export type MetaViewerInfoAvgAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoSumAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    code: number
    isDisable: number
    worldData: number
    cafeInfoId: number
    _all: number
  }


  export type MetaViewerInfoAvgAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoSumAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    isDisable?: true
    worldData?: true
    cafeInfoId?: true
    _all?: true
  }

  export type MetaViewerInfoAggregateArgs = {
    /**
     * Filter which MetaViewerInfo to aggregate.
     * 
    **/
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaViewerInfos
    **/
    _count?: true | MetaViewerInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaViewerInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaViewerInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaViewerInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaViewerInfoMaxAggregateInputType
  }

  export type GetMetaViewerInfoAggregateType<T extends MetaViewerInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaViewerInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaViewerInfo[P]>
      : GetScalarType<T[P], AggregateMetaViewerInfo[P]>
  }




  export type MetaViewerInfoGroupByArgs = {
    where?: MetaViewerInfoWhereInput
    orderBy?: Enumerable<MetaViewerInfoOrderByWithAggregationInput>
    by: Array<MetaViewerInfoScalarFieldEnum>
    having?: MetaViewerInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaViewerInfoCountAggregateInputType | true
    _avg?: MetaViewerInfoAvgAggregateInputType
    _sum?: MetaViewerInfoSumAggregateInputType
    _min?: MetaViewerInfoMinAggregateInputType
    _max?: MetaViewerInfoMaxAggregateInputType
  }


  export type MetaViewerInfoGroupByOutputType = {
    id: number
    createdAt: Date
    code: string
    isDisable: boolean
    worldData: JsonValue
    cafeInfoId: number
    _count: MetaViewerInfoCountAggregateOutputType | null
    _avg: MetaViewerInfoAvgAggregateOutputType | null
    _sum: MetaViewerInfoSumAggregateOutputType | null
    _min: MetaViewerInfoMinAggregateOutputType | null
    _max: MetaViewerInfoMaxAggregateOutputType | null
  }

  type GetMetaViewerInfoGroupByPayload<T extends MetaViewerInfoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MetaViewerInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaViewerInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaViewerInfoGroupByOutputType[P]>
            : GetScalarType<T[P], MetaViewerInfoGroupByOutputType[P]>
        }
      >
    >


  export type MetaViewerInfoSelect = {
    id?: boolean
    createdAt?: boolean
    code?: boolean
    isDisable?: boolean
    worldData?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
    MetaViewerMaps?: boolean | MetaViewerMapFindManyArgs
    ActiveMaps?: boolean | MetaViewerActiveMapArgs
    _count?: boolean | MetaViewerInfoCountOutputTypeArgs
  }


  export type MetaViewerInfoInclude = {
    CafeInfo?: boolean | CafeInfoArgs
    MetaViewerMaps?: boolean | MetaViewerMapFindManyArgs
    ActiveMaps?: boolean | MetaViewerActiveMapArgs
    _count?: boolean | MetaViewerInfoCountOutputTypeArgs
  } 

  export type MetaViewerInfoGetPayload<S extends boolean | null | undefined | MetaViewerInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetaViewerInfo :
    S extends undefined ? never :
    S extends { include: any } & (MetaViewerInfoArgs | MetaViewerInfoFindManyArgs)
    ? MetaViewerInfo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> :
        P extends 'MetaViewerMaps' ? Array < MetaViewerMapGetPayload<S['include'][P]>>  :
        P extends 'ActiveMaps' ? MetaViewerActiveMapGetPayload<S['include'][P]> | null :
        P extends '_count' ? MetaViewerInfoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MetaViewerInfoArgs | MetaViewerInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> :
        P extends 'MetaViewerMaps' ? Array < MetaViewerMapGetPayload<S['select'][P]>>  :
        P extends 'ActiveMaps' ? MetaViewerActiveMapGetPayload<S['select'][P]> | null :
        P extends '_count' ? MetaViewerInfoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MetaViewerInfo ? MetaViewerInfo[P] : never
  } 
      : MetaViewerInfo


  type MetaViewerInfoCountArgs = Merge<
    Omit<MetaViewerInfoFindManyArgs, 'select' | 'include'> & {
      select?: MetaViewerInfoCountAggregateInputType | true
    }
  >

  export interface MetaViewerInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MetaViewerInfo that matches the filter.
     * @param {MetaViewerInfoFindUniqueArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetaViewerInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MetaViewerInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MetaViewerInfo'> extends True ? Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>> : Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T> | null, null>

    /**
     * Find one MetaViewerInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MetaViewerInfoFindUniqueOrThrowArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MetaViewerInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MetaViewerInfoFindUniqueOrThrowArgs>
    ): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>>

    /**
     * Find the first MetaViewerInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoFindFirstArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetaViewerInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MetaViewerInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MetaViewerInfo'> extends True ? Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>> : Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T> | null, null>

    /**
     * Find the first MetaViewerInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoFindFirstOrThrowArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MetaViewerInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MetaViewerInfoFindFirstOrThrowArgs>
    ): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>>

    /**
     * Find zero or more MetaViewerInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaViewerInfos
     * const metaViewerInfos = await prisma.metaViewerInfo.findMany()
     * 
     * // Get first 10 MetaViewerInfos
     * const metaViewerInfos = await prisma.metaViewerInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaViewerInfoWithIdOnly = await prisma.metaViewerInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MetaViewerInfoFindManyArgs>(
      args?: SelectSubset<T, MetaViewerInfoFindManyArgs>
    ): PrismaPromise<Array<MetaViewerInfoGetPayload<T>>>

    /**
     * Create a MetaViewerInfo.
     * @param {MetaViewerInfoCreateArgs} args - Arguments to create a MetaViewerInfo.
     * @example
     * // Create one MetaViewerInfo
     * const MetaViewerInfo = await prisma.metaViewerInfo.create({
     *   data: {
     *     // ... data to create a MetaViewerInfo
     *   }
     * })
     * 
    **/
    create<T extends MetaViewerInfoCreateArgs>(
      args: SelectSubset<T, MetaViewerInfoCreateArgs>
    ): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>>

    /**
     * Create many MetaViewerInfos.
     *     @param {MetaViewerInfoCreateManyArgs} args - Arguments to create many MetaViewerInfos.
     *     @example
     *     // Create many MetaViewerInfos
     *     const metaViewerInfo = await prisma.metaViewerInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetaViewerInfoCreateManyArgs>(
      args?: SelectSubset<T, MetaViewerInfoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MetaViewerInfo.
     * @param {MetaViewerInfoDeleteArgs} args - Arguments to delete one MetaViewerInfo.
     * @example
     * // Delete one MetaViewerInfo
     * const MetaViewerInfo = await prisma.metaViewerInfo.delete({
     *   where: {
     *     // ... filter to delete one MetaViewerInfo
     *   }
     * })
     * 
    **/
    delete<T extends MetaViewerInfoDeleteArgs>(
      args: SelectSubset<T, MetaViewerInfoDeleteArgs>
    ): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>>

    /**
     * Update one MetaViewerInfo.
     * @param {MetaViewerInfoUpdateArgs} args - Arguments to update one MetaViewerInfo.
     * @example
     * // Update one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetaViewerInfoUpdateArgs>(
      args: SelectSubset<T, MetaViewerInfoUpdateArgs>
    ): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>>

    /**
     * Delete zero or more MetaViewerInfos.
     * @param {MetaViewerInfoDeleteManyArgs} args - Arguments to filter MetaViewerInfos to delete.
     * @example
     * // Delete a few MetaViewerInfos
     * const { count } = await prisma.metaViewerInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetaViewerInfoDeleteManyArgs>(
      args?: SelectSubset<T, MetaViewerInfoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaViewerInfos
     * const metaViewerInfo = await prisma.metaViewerInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetaViewerInfoUpdateManyArgs>(
      args: SelectSubset<T, MetaViewerInfoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MetaViewerInfo.
     * @param {MetaViewerInfoUpsertArgs} args - Arguments to update or create a MetaViewerInfo.
     * @example
     * // Update or create a MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.upsert({
     *   create: {
     *     // ... data to create a MetaViewerInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaViewerInfo we want to update
     *   }
     * })
    **/
    upsert<T extends MetaViewerInfoUpsertArgs>(
      args: SelectSubset<T, MetaViewerInfoUpsertArgs>
    ): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T>>

    /**
     * Count the number of MetaViewerInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoCountArgs} args - Arguments to filter MetaViewerInfos to count.
     * @example
     * // Count the number of MetaViewerInfos
     * const count = await prisma.metaViewerInfo.count({
     *   where: {
     *     // ... the filter for the MetaViewerInfos we want to count
     *   }
     * })
    **/
    count<T extends MetaViewerInfoCountArgs>(
      args?: Subset<T, MetaViewerInfoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaViewerInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaViewerInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaViewerInfoAggregateArgs>(args: Subset<T, MetaViewerInfoAggregateArgs>): PrismaPromise<GetMetaViewerInfoAggregateType<T>>

    /**
     * Group by MetaViewerInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaViewerInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaViewerInfoGroupByArgs['orderBy'] }
        : { orderBy?: MetaViewerInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaViewerInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaViewerInfoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaViewerInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MetaViewerInfoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    MetaViewerMaps<T extends MetaViewerMapFindManyArgs= {}>(args?: Subset<T, MetaViewerMapFindManyArgs>): PrismaPromise<Array<MetaViewerMapGetPayload<T>>| Null>;

    ActiveMaps<T extends MetaViewerActiveMapArgs= {}>(args?: Subset<T, MetaViewerActiveMapArgs>): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MetaViewerInfo base type for findUnique actions
   */
  export type MetaViewerInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     * 
    **/
    where: MetaViewerInfoWhereUniqueInput
  }

  /**
   * MetaViewerInfo: findUnique
   */
  export interface MetaViewerInfoFindUniqueArgs extends MetaViewerInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetaViewerInfo findUniqueOrThrow
   */
  export type MetaViewerInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     * 
    **/
    where: MetaViewerInfoWhereUniqueInput
  }


  /**
   * MetaViewerInfo base type for findFirst actions
   */
  export type MetaViewerInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     * 
    **/
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerInfos.
     * 
    **/
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerInfos.
     * 
    **/
    distinct?: Enumerable<MetaViewerInfoScalarFieldEnum>
  }

  /**
   * MetaViewerInfo: findFirst
   */
  export interface MetaViewerInfoFindFirstArgs extends MetaViewerInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetaViewerInfo findFirstOrThrow
   */
  export type MetaViewerInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     * 
    **/
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerInfos.
     * 
    **/
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerInfos.
     * 
    **/
    distinct?: Enumerable<MetaViewerInfoScalarFieldEnum>
  }


  /**
   * MetaViewerInfo findMany
   */
  export type MetaViewerInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * Filter, which MetaViewerInfos to fetch.
     * 
    **/
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaViewerInfos.
     * 
    **/
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MetaViewerInfoScalarFieldEnum>
  }


  /**
   * MetaViewerInfo create
   */
  export type MetaViewerInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * The data needed to create a MetaViewerInfo.
     * 
    **/
    data: XOR<MetaViewerInfoCreateInput, MetaViewerInfoUncheckedCreateInput>
  }


  /**
   * MetaViewerInfo createMany
   */
  export type MetaViewerInfoCreateManyArgs = {
    /**
     * The data used to create many MetaViewerInfos.
     * 
    **/
    data: Enumerable<MetaViewerInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MetaViewerInfo update
   */
  export type MetaViewerInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * The data needed to update a MetaViewerInfo.
     * 
    **/
    data: XOR<MetaViewerInfoUpdateInput, MetaViewerInfoUncheckedUpdateInput>
    /**
     * Choose, which MetaViewerInfo to update.
     * 
    **/
    where: MetaViewerInfoWhereUniqueInput
  }


  /**
   * MetaViewerInfo updateMany
   */
  export type MetaViewerInfoUpdateManyArgs = {
    /**
     * The data used to update MetaViewerInfos.
     * 
    **/
    data: XOR<MetaViewerInfoUpdateManyMutationInput, MetaViewerInfoUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerInfos to update
     * 
    **/
    where?: MetaViewerInfoWhereInput
  }


  /**
   * MetaViewerInfo upsert
   */
  export type MetaViewerInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * The filter to search for the MetaViewerInfo to update in case it exists.
     * 
    **/
    where: MetaViewerInfoWhereUniqueInput
    /**
     * In case the MetaViewerInfo found by the `where` argument doesn't exist, create a new MetaViewerInfo with this data.
     * 
    **/
    create: XOR<MetaViewerInfoCreateInput, MetaViewerInfoUncheckedCreateInput>
    /**
     * In case the MetaViewerInfo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MetaViewerInfoUpdateInput, MetaViewerInfoUncheckedUpdateInput>
  }


  /**
   * MetaViewerInfo delete
   */
  export type MetaViewerInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
    /**
     * Filter which MetaViewerInfo to delete.
     * 
    **/
    where: MetaViewerInfoWhereUniqueInput
  }


  /**
   * MetaViewerInfo deleteMany
   */
  export type MetaViewerInfoDeleteManyArgs = {
    /**
     * Filter which MetaViewerInfos to delete
     * 
    **/
    where?: MetaViewerInfoWhereInput
  }


  /**
   * MetaViewerInfo without action
   */
  export type MetaViewerInfoArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     * 
    **/
    select?: MetaViewerInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerInfoInclude | null
  }



  /**
   * Model MetaViewerMap
   */


  export type AggregateMetaViewerMap = {
    _count: MetaViewerMapCountAggregateOutputType | null
    _avg: MetaViewerMapAvgAggregateOutputType | null
    _sum: MetaViewerMapSumAggregateOutputType | null
    _min: MetaViewerMapMinAggregateOutputType | null
    _max: MetaViewerMapMaxAggregateOutputType | null
  }

  export type MetaViewerMapAvgAggregateOutputType = {
    id: number | null
    version: number | null
    size: number | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapSumAggregateOutputType = {
    id: number | null
    version: number | null
    size: number | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: MetaMapType | null
    version: number | null
    url: string | null
    size: number | null
    contentKey: string | null
    isDraco: boolean | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: MetaMapType | null
    version: number | null
    url: string | null
    size: number | null
    contentKey: string | null
    isDraco: boolean | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapCountAggregateOutputType = {
    id: number
    createdAt: number
    type: number
    version: number
    url: number
    size: number
    contentKey: number
    isDraco: number
    metaViewerInfoId: number
    _all: number
  }


  export type MetaViewerMapAvgAggregateInputType = {
    id?: true
    version?: true
    size?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapSumAggregateInputType = {
    id?: true
    version?: true
    size?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapMinAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    version?: true
    url?: true
    size?: true
    contentKey?: true
    isDraco?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapMaxAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    version?: true
    url?: true
    size?: true
    contentKey?: true
    isDraco?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapCountAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    version?: true
    url?: true
    size?: true
    contentKey?: true
    isDraco?: true
    metaViewerInfoId?: true
    _all?: true
  }

  export type MetaViewerMapAggregateArgs = {
    /**
     * Filter which MetaViewerMap to aggregate.
     * 
    **/
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaViewerMaps
    **/
    _count?: true | MetaViewerMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaViewerMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaViewerMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaViewerMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaViewerMapMaxAggregateInputType
  }

  export type GetMetaViewerMapAggregateType<T extends MetaViewerMapAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaViewerMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaViewerMap[P]>
      : GetScalarType<T[P], AggregateMetaViewerMap[P]>
  }




  export type MetaViewerMapGroupByArgs = {
    where?: MetaViewerMapWhereInput
    orderBy?: Enumerable<MetaViewerMapOrderByWithAggregationInput>
    by: Array<MetaViewerMapScalarFieldEnum>
    having?: MetaViewerMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaViewerMapCountAggregateInputType | true
    _avg?: MetaViewerMapAvgAggregateInputType
    _sum?: MetaViewerMapSumAggregateInputType
    _min?: MetaViewerMapMinAggregateInputType
    _max?: MetaViewerMapMaxAggregateInputType
  }


  export type MetaViewerMapGroupByOutputType = {
    id: number
    createdAt: Date
    type: MetaMapType
    version: number
    url: string
    size: number
    contentKey: string | null
    isDraco: boolean
    metaViewerInfoId: number
    _count: MetaViewerMapCountAggregateOutputType | null
    _avg: MetaViewerMapAvgAggregateOutputType | null
    _sum: MetaViewerMapSumAggregateOutputType | null
    _min: MetaViewerMapMinAggregateOutputType | null
    _max: MetaViewerMapMaxAggregateOutputType | null
  }

  type GetMetaViewerMapGroupByPayload<T extends MetaViewerMapGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MetaViewerMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaViewerMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaViewerMapGroupByOutputType[P]>
            : GetScalarType<T[P], MetaViewerMapGroupByOutputType[P]>
        }
      >
    >


  export type MetaViewerMapSelect = {
    id?: boolean
    createdAt?: boolean
    type?: boolean
    version?: boolean
    url?: boolean
    size?: boolean
    contentKey?: boolean
    isDraco?: boolean
    metaViewerInfoId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoArgs
    ActiveRenderFor?: boolean | MetaViewerActiveMapFindManyArgs
    ActiveColliderFor?: boolean | MetaViewerActiveMapFindManyArgs
    _count?: boolean | MetaViewerMapCountOutputTypeArgs
  }


  export type MetaViewerMapInclude = {
    MetaViewerInfo?: boolean | MetaViewerInfoArgs
    ActiveRenderFor?: boolean | MetaViewerActiveMapFindManyArgs
    ActiveColliderFor?: boolean | MetaViewerActiveMapFindManyArgs
    _count?: boolean | MetaViewerMapCountOutputTypeArgs
  } 

  export type MetaViewerMapGetPayload<S extends boolean | null | undefined | MetaViewerMapArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetaViewerMap :
    S extends undefined ? never :
    S extends { include: any } & (MetaViewerMapArgs | MetaViewerMapFindManyArgs)
    ? MetaViewerMap  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'MetaViewerInfo' ? MetaViewerInfoGetPayload<S['include'][P]> :
        P extends 'ActiveRenderFor' ? Array < MetaViewerActiveMapGetPayload<S['include'][P]>>  :
        P extends 'ActiveColliderFor' ? Array < MetaViewerActiveMapGetPayload<S['include'][P]>>  :
        P extends '_count' ? MetaViewerMapCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MetaViewerMapArgs | MetaViewerMapFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'MetaViewerInfo' ? MetaViewerInfoGetPayload<S['select'][P]> :
        P extends 'ActiveRenderFor' ? Array < MetaViewerActiveMapGetPayload<S['select'][P]>>  :
        P extends 'ActiveColliderFor' ? Array < MetaViewerActiveMapGetPayload<S['select'][P]>>  :
        P extends '_count' ? MetaViewerMapCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MetaViewerMap ? MetaViewerMap[P] : never
  } 
      : MetaViewerMap


  type MetaViewerMapCountArgs = Merge<
    Omit<MetaViewerMapFindManyArgs, 'select' | 'include'> & {
      select?: MetaViewerMapCountAggregateInputType | true
    }
  >

  export interface MetaViewerMapDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MetaViewerMap that matches the filter.
     * @param {MetaViewerMapFindUniqueArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetaViewerMapFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MetaViewerMapFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MetaViewerMap'> extends True ? Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>> : Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T> | null, null>

    /**
     * Find one MetaViewerMap that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MetaViewerMapFindUniqueOrThrowArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MetaViewerMapFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MetaViewerMapFindUniqueOrThrowArgs>
    ): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>>

    /**
     * Find the first MetaViewerMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapFindFirstArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetaViewerMapFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MetaViewerMapFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MetaViewerMap'> extends True ? Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>> : Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T> | null, null>

    /**
     * Find the first MetaViewerMap that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapFindFirstOrThrowArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MetaViewerMapFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MetaViewerMapFindFirstOrThrowArgs>
    ): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>>

    /**
     * Find zero or more MetaViewerMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaViewerMaps
     * const metaViewerMaps = await prisma.metaViewerMap.findMany()
     * 
     * // Get first 10 MetaViewerMaps
     * const metaViewerMaps = await prisma.metaViewerMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaViewerMapWithIdOnly = await prisma.metaViewerMap.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MetaViewerMapFindManyArgs>(
      args?: SelectSubset<T, MetaViewerMapFindManyArgs>
    ): PrismaPromise<Array<MetaViewerMapGetPayload<T>>>

    /**
     * Create a MetaViewerMap.
     * @param {MetaViewerMapCreateArgs} args - Arguments to create a MetaViewerMap.
     * @example
     * // Create one MetaViewerMap
     * const MetaViewerMap = await prisma.metaViewerMap.create({
     *   data: {
     *     // ... data to create a MetaViewerMap
     *   }
     * })
     * 
    **/
    create<T extends MetaViewerMapCreateArgs>(
      args: SelectSubset<T, MetaViewerMapCreateArgs>
    ): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>>

    /**
     * Create many MetaViewerMaps.
     *     @param {MetaViewerMapCreateManyArgs} args - Arguments to create many MetaViewerMaps.
     *     @example
     *     // Create many MetaViewerMaps
     *     const metaViewerMap = await prisma.metaViewerMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetaViewerMapCreateManyArgs>(
      args?: SelectSubset<T, MetaViewerMapCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MetaViewerMap.
     * @param {MetaViewerMapDeleteArgs} args - Arguments to delete one MetaViewerMap.
     * @example
     * // Delete one MetaViewerMap
     * const MetaViewerMap = await prisma.metaViewerMap.delete({
     *   where: {
     *     // ... filter to delete one MetaViewerMap
     *   }
     * })
     * 
    **/
    delete<T extends MetaViewerMapDeleteArgs>(
      args: SelectSubset<T, MetaViewerMapDeleteArgs>
    ): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>>

    /**
     * Update one MetaViewerMap.
     * @param {MetaViewerMapUpdateArgs} args - Arguments to update one MetaViewerMap.
     * @example
     * // Update one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetaViewerMapUpdateArgs>(
      args: SelectSubset<T, MetaViewerMapUpdateArgs>
    ): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>>

    /**
     * Delete zero or more MetaViewerMaps.
     * @param {MetaViewerMapDeleteManyArgs} args - Arguments to filter MetaViewerMaps to delete.
     * @example
     * // Delete a few MetaViewerMaps
     * const { count } = await prisma.metaViewerMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetaViewerMapDeleteManyArgs>(
      args?: SelectSubset<T, MetaViewerMapDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaViewerMaps
     * const metaViewerMap = await prisma.metaViewerMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetaViewerMapUpdateManyArgs>(
      args: SelectSubset<T, MetaViewerMapUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MetaViewerMap.
     * @param {MetaViewerMapUpsertArgs} args - Arguments to update or create a MetaViewerMap.
     * @example
     * // Update or create a MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.upsert({
     *   create: {
     *     // ... data to create a MetaViewerMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaViewerMap we want to update
     *   }
     * })
    **/
    upsert<T extends MetaViewerMapUpsertArgs>(
      args: SelectSubset<T, MetaViewerMapUpsertArgs>
    ): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T>>

    /**
     * Count the number of MetaViewerMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapCountArgs} args - Arguments to filter MetaViewerMaps to count.
     * @example
     * // Count the number of MetaViewerMaps
     * const count = await prisma.metaViewerMap.count({
     *   where: {
     *     // ... the filter for the MetaViewerMaps we want to count
     *   }
     * })
    **/
    count<T extends MetaViewerMapCountArgs>(
      args?: Subset<T, MetaViewerMapCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaViewerMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaViewerMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaViewerMapAggregateArgs>(args: Subset<T, MetaViewerMapAggregateArgs>): PrismaPromise<GetMetaViewerMapAggregateType<T>>

    /**
     * Group by MetaViewerMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaViewerMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaViewerMapGroupByArgs['orderBy'] }
        : { orderBy?: MetaViewerMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaViewerMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaViewerMapGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaViewerMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MetaViewerMapClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    MetaViewerInfo<T extends MetaViewerInfoArgs= {}>(args?: Subset<T, MetaViewerInfoArgs>): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T> | Null>;

    ActiveRenderFor<T extends MetaViewerActiveMapFindManyArgs= {}>(args?: Subset<T, MetaViewerActiveMapFindManyArgs>): PrismaPromise<Array<MetaViewerActiveMapGetPayload<T>>| Null>;

    ActiveColliderFor<T extends MetaViewerActiveMapFindManyArgs= {}>(args?: Subset<T, MetaViewerActiveMapFindManyArgs>): PrismaPromise<Array<MetaViewerActiveMapGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MetaViewerMap base type for findUnique actions
   */
  export type MetaViewerMapFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * Filter, which MetaViewerMap to fetch.
     * 
    **/
    where: MetaViewerMapWhereUniqueInput
  }

  /**
   * MetaViewerMap: findUnique
   */
  export interface MetaViewerMapFindUniqueArgs extends MetaViewerMapFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetaViewerMap findUniqueOrThrow
   */
  export type MetaViewerMapFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * Filter, which MetaViewerMap to fetch.
     * 
    **/
    where: MetaViewerMapWhereUniqueInput
  }


  /**
   * MetaViewerMap base type for findFirst actions
   */
  export type MetaViewerMapFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * Filter, which MetaViewerMap to fetch.
     * 
    **/
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerMaps.
     * 
    **/
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerMaps.
     * 
    **/
    distinct?: Enumerable<MetaViewerMapScalarFieldEnum>
  }

  /**
   * MetaViewerMap: findFirst
   */
  export interface MetaViewerMapFindFirstArgs extends MetaViewerMapFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetaViewerMap findFirstOrThrow
   */
  export type MetaViewerMapFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * Filter, which MetaViewerMap to fetch.
     * 
    **/
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerMaps.
     * 
    **/
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerMaps.
     * 
    **/
    distinct?: Enumerable<MetaViewerMapScalarFieldEnum>
  }


  /**
   * MetaViewerMap findMany
   */
  export type MetaViewerMapFindManyArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * Filter, which MetaViewerMaps to fetch.
     * 
    **/
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaViewerMaps.
     * 
    **/
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MetaViewerMapScalarFieldEnum>
  }


  /**
   * MetaViewerMap create
   */
  export type MetaViewerMapCreateArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * The data needed to create a MetaViewerMap.
     * 
    **/
    data: XOR<MetaViewerMapCreateInput, MetaViewerMapUncheckedCreateInput>
  }


  /**
   * MetaViewerMap createMany
   */
  export type MetaViewerMapCreateManyArgs = {
    /**
     * The data used to create many MetaViewerMaps.
     * 
    **/
    data: Enumerable<MetaViewerMapCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MetaViewerMap update
   */
  export type MetaViewerMapUpdateArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * The data needed to update a MetaViewerMap.
     * 
    **/
    data: XOR<MetaViewerMapUpdateInput, MetaViewerMapUncheckedUpdateInput>
    /**
     * Choose, which MetaViewerMap to update.
     * 
    **/
    where: MetaViewerMapWhereUniqueInput
  }


  /**
   * MetaViewerMap updateMany
   */
  export type MetaViewerMapUpdateManyArgs = {
    /**
     * The data used to update MetaViewerMaps.
     * 
    **/
    data: XOR<MetaViewerMapUpdateManyMutationInput, MetaViewerMapUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerMaps to update
     * 
    **/
    where?: MetaViewerMapWhereInput
  }


  /**
   * MetaViewerMap upsert
   */
  export type MetaViewerMapUpsertArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * The filter to search for the MetaViewerMap to update in case it exists.
     * 
    **/
    where: MetaViewerMapWhereUniqueInput
    /**
     * In case the MetaViewerMap found by the `where` argument doesn't exist, create a new MetaViewerMap with this data.
     * 
    **/
    create: XOR<MetaViewerMapCreateInput, MetaViewerMapUncheckedCreateInput>
    /**
     * In case the MetaViewerMap was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MetaViewerMapUpdateInput, MetaViewerMapUncheckedUpdateInput>
  }


  /**
   * MetaViewerMap delete
   */
  export type MetaViewerMapDeleteArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
    /**
     * Filter which MetaViewerMap to delete.
     * 
    **/
    where: MetaViewerMapWhereUniqueInput
  }


  /**
   * MetaViewerMap deleteMany
   */
  export type MetaViewerMapDeleteManyArgs = {
    /**
     * Filter which MetaViewerMaps to delete
     * 
    **/
    where?: MetaViewerMapWhereInput
  }


  /**
   * MetaViewerMap without action
   */
  export type MetaViewerMapArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     * 
    **/
    select?: MetaViewerMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerMapInclude | null
  }



  /**
   * Model MetaViewerActiveMap
   */


  export type AggregateMetaViewerActiveMap = {
    _count: MetaViewerActiveMapCountAggregateOutputType | null
    _avg: MetaViewerActiveMapAvgAggregateOutputType | null
    _sum: MetaViewerActiveMapSumAggregateOutputType | null
    _min: MetaViewerActiveMapMinAggregateOutputType | null
    _max: MetaViewerActiveMapMaxAggregateOutputType | null
  }

  export type MetaViewerActiveMapAvgAggregateOutputType = {
    id: number | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapSumAggregateOutputType = {
    id: number | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapMinAggregateOutputType = {
    id: number | null
    updatedAt: Date | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapMaxAggregateOutputType = {
    id: number | null
    updatedAt: Date | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapCountAggregateOutputType = {
    id: number
    updatedAt: number
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
    _all: number
  }


  export type MetaViewerActiveMapAvgAggregateInputType = {
    id?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapSumAggregateInputType = {
    id?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapMinAggregateInputType = {
    id?: true
    updatedAt?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapMaxAggregateInputType = {
    id?: true
    updatedAt?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapCountAggregateInputType = {
    id?: true
    updatedAt?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
    _all?: true
  }

  export type MetaViewerActiveMapAggregateArgs = {
    /**
     * Filter which MetaViewerActiveMap to aggregate.
     * 
    **/
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerActiveMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaViewerActiveMaps
    **/
    _count?: true | MetaViewerActiveMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaViewerActiveMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaViewerActiveMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaViewerActiveMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaViewerActiveMapMaxAggregateInputType
  }

  export type GetMetaViewerActiveMapAggregateType<T extends MetaViewerActiveMapAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaViewerActiveMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaViewerActiveMap[P]>
      : GetScalarType<T[P], AggregateMetaViewerActiveMap[P]>
  }




  export type MetaViewerActiveMapGroupByArgs = {
    where?: MetaViewerActiveMapWhereInput
    orderBy?: Enumerable<MetaViewerActiveMapOrderByWithAggregationInput>
    by: Array<MetaViewerActiveMapScalarFieldEnum>
    having?: MetaViewerActiveMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaViewerActiveMapCountAggregateInputType | true
    _avg?: MetaViewerActiveMapAvgAggregateInputType
    _sum?: MetaViewerActiveMapSumAggregateInputType
    _min?: MetaViewerActiveMapMinAggregateInputType
    _max?: MetaViewerActiveMapMaxAggregateInputType
  }


  export type MetaViewerActiveMapGroupByOutputType = {
    id: number
    updatedAt: Date
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
    _count: MetaViewerActiveMapCountAggregateOutputType | null
    _avg: MetaViewerActiveMapAvgAggregateOutputType | null
    _sum: MetaViewerActiveMapSumAggregateOutputType | null
    _min: MetaViewerActiveMapMinAggregateOutputType | null
    _max: MetaViewerActiveMapMaxAggregateOutputType | null
  }

  type GetMetaViewerActiveMapGroupByPayload<T extends MetaViewerActiveMapGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MetaViewerActiveMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaViewerActiveMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaViewerActiveMapGroupByOutputType[P]>
            : GetScalarType<T[P], MetaViewerActiveMapGroupByOutputType[P]>
        }
      >
    >


  export type MetaViewerActiveMapSelect = {
    id?: boolean
    updatedAt?: boolean
    metaViewerInfoId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoArgs
    activeRenderMapId?: boolean
    ActiveRenderMap?: boolean | MetaViewerMapArgs
    activeColliderMapId?: boolean
    ActiveColliderMap?: boolean | MetaViewerMapArgs
  }


  export type MetaViewerActiveMapInclude = {
    MetaViewerInfo?: boolean | MetaViewerInfoArgs
    ActiveRenderMap?: boolean | MetaViewerMapArgs
    ActiveColliderMap?: boolean | MetaViewerMapArgs
  } 

  export type MetaViewerActiveMapGetPayload<S extends boolean | null | undefined | MetaViewerActiveMapArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MetaViewerActiveMap :
    S extends undefined ? never :
    S extends { include: any } & (MetaViewerActiveMapArgs | MetaViewerActiveMapFindManyArgs)
    ? MetaViewerActiveMap  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'MetaViewerInfo' ? MetaViewerInfoGetPayload<S['include'][P]> :
        P extends 'ActiveRenderMap' ? MetaViewerMapGetPayload<S['include'][P]> :
        P extends 'ActiveColliderMap' ? MetaViewerMapGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MetaViewerActiveMapArgs | MetaViewerActiveMapFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'MetaViewerInfo' ? MetaViewerInfoGetPayload<S['select'][P]> :
        P extends 'ActiveRenderMap' ? MetaViewerMapGetPayload<S['select'][P]> :
        P extends 'ActiveColliderMap' ? MetaViewerMapGetPayload<S['select'][P]> :  P extends keyof MetaViewerActiveMap ? MetaViewerActiveMap[P] : never
  } 
      : MetaViewerActiveMap


  type MetaViewerActiveMapCountArgs = Merge<
    Omit<MetaViewerActiveMapFindManyArgs, 'select' | 'include'> & {
      select?: MetaViewerActiveMapCountAggregateInputType | true
    }
  >

  export interface MetaViewerActiveMapDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one MetaViewerActiveMap that matches the filter.
     * @param {MetaViewerActiveMapFindUniqueArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetaViewerActiveMapFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MetaViewerActiveMapFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MetaViewerActiveMap'> extends True ? Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>> : Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T> | null, null>

    /**
     * Find one MetaViewerActiveMap that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MetaViewerActiveMapFindUniqueOrThrowArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MetaViewerActiveMapFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MetaViewerActiveMapFindUniqueOrThrowArgs>
    ): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>>

    /**
     * Find the first MetaViewerActiveMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapFindFirstArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetaViewerActiveMapFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MetaViewerActiveMapFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MetaViewerActiveMap'> extends True ? Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>> : Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T> | null, null>

    /**
     * Find the first MetaViewerActiveMap that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapFindFirstOrThrowArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MetaViewerActiveMapFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MetaViewerActiveMapFindFirstOrThrowArgs>
    ): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>>

    /**
     * Find zero or more MetaViewerActiveMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaViewerActiveMaps
     * const metaViewerActiveMaps = await prisma.metaViewerActiveMap.findMany()
     * 
     * // Get first 10 MetaViewerActiveMaps
     * const metaViewerActiveMaps = await prisma.metaViewerActiveMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaViewerActiveMapWithIdOnly = await prisma.metaViewerActiveMap.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MetaViewerActiveMapFindManyArgs>(
      args?: SelectSubset<T, MetaViewerActiveMapFindManyArgs>
    ): PrismaPromise<Array<MetaViewerActiveMapGetPayload<T>>>

    /**
     * Create a MetaViewerActiveMap.
     * @param {MetaViewerActiveMapCreateArgs} args - Arguments to create a MetaViewerActiveMap.
     * @example
     * // Create one MetaViewerActiveMap
     * const MetaViewerActiveMap = await prisma.metaViewerActiveMap.create({
     *   data: {
     *     // ... data to create a MetaViewerActiveMap
     *   }
     * })
     * 
    **/
    create<T extends MetaViewerActiveMapCreateArgs>(
      args: SelectSubset<T, MetaViewerActiveMapCreateArgs>
    ): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>>

    /**
     * Create many MetaViewerActiveMaps.
     *     @param {MetaViewerActiveMapCreateManyArgs} args - Arguments to create many MetaViewerActiveMaps.
     *     @example
     *     // Create many MetaViewerActiveMaps
     *     const metaViewerActiveMap = await prisma.metaViewerActiveMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetaViewerActiveMapCreateManyArgs>(
      args?: SelectSubset<T, MetaViewerActiveMapCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MetaViewerActiveMap.
     * @param {MetaViewerActiveMapDeleteArgs} args - Arguments to delete one MetaViewerActiveMap.
     * @example
     * // Delete one MetaViewerActiveMap
     * const MetaViewerActiveMap = await prisma.metaViewerActiveMap.delete({
     *   where: {
     *     // ... filter to delete one MetaViewerActiveMap
     *   }
     * })
     * 
    **/
    delete<T extends MetaViewerActiveMapDeleteArgs>(
      args: SelectSubset<T, MetaViewerActiveMapDeleteArgs>
    ): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>>

    /**
     * Update one MetaViewerActiveMap.
     * @param {MetaViewerActiveMapUpdateArgs} args - Arguments to update one MetaViewerActiveMap.
     * @example
     * // Update one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetaViewerActiveMapUpdateArgs>(
      args: SelectSubset<T, MetaViewerActiveMapUpdateArgs>
    ): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>>

    /**
     * Delete zero or more MetaViewerActiveMaps.
     * @param {MetaViewerActiveMapDeleteManyArgs} args - Arguments to filter MetaViewerActiveMaps to delete.
     * @example
     * // Delete a few MetaViewerActiveMaps
     * const { count } = await prisma.metaViewerActiveMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetaViewerActiveMapDeleteManyArgs>(
      args?: SelectSubset<T, MetaViewerActiveMapDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerActiveMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaViewerActiveMaps
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetaViewerActiveMapUpdateManyArgs>(
      args: SelectSubset<T, MetaViewerActiveMapUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MetaViewerActiveMap.
     * @param {MetaViewerActiveMapUpsertArgs} args - Arguments to update or create a MetaViewerActiveMap.
     * @example
     * // Update or create a MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.upsert({
     *   create: {
     *     // ... data to create a MetaViewerActiveMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaViewerActiveMap we want to update
     *   }
     * })
    **/
    upsert<T extends MetaViewerActiveMapUpsertArgs>(
      args: SelectSubset<T, MetaViewerActiveMapUpsertArgs>
    ): Prisma__MetaViewerActiveMapClient<MetaViewerActiveMapGetPayload<T>>

    /**
     * Count the number of MetaViewerActiveMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapCountArgs} args - Arguments to filter MetaViewerActiveMaps to count.
     * @example
     * // Count the number of MetaViewerActiveMaps
     * const count = await prisma.metaViewerActiveMap.count({
     *   where: {
     *     // ... the filter for the MetaViewerActiveMaps we want to count
     *   }
     * })
    **/
    count<T extends MetaViewerActiveMapCountArgs>(
      args?: Subset<T, MetaViewerActiveMapCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaViewerActiveMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaViewerActiveMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaViewerActiveMapAggregateArgs>(args: Subset<T, MetaViewerActiveMapAggregateArgs>): PrismaPromise<GetMetaViewerActiveMapAggregateType<T>>

    /**
     * Group by MetaViewerActiveMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaViewerActiveMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaViewerActiveMapGroupByArgs['orderBy'] }
        : { orderBy?: MetaViewerActiveMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaViewerActiveMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaViewerActiveMapGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaViewerActiveMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MetaViewerActiveMapClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    MetaViewerInfo<T extends MetaViewerInfoArgs= {}>(args?: Subset<T, MetaViewerInfoArgs>): Prisma__MetaViewerInfoClient<MetaViewerInfoGetPayload<T> | Null>;

    ActiveRenderMap<T extends MetaViewerMapArgs= {}>(args?: Subset<T, MetaViewerMapArgs>): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T> | Null>;

    ActiveColliderMap<T extends MetaViewerMapArgs= {}>(args?: Subset<T, MetaViewerMapArgs>): Prisma__MetaViewerMapClient<MetaViewerMapGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MetaViewerActiveMap base type for findUnique actions
   */
  export type MetaViewerActiveMapFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     * 
    **/
    where: MetaViewerActiveMapWhereUniqueInput
  }

  /**
   * MetaViewerActiveMap: findUnique
   */
  export interface MetaViewerActiveMapFindUniqueArgs extends MetaViewerActiveMapFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetaViewerActiveMap findUniqueOrThrow
   */
  export type MetaViewerActiveMapFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     * 
    **/
    where: MetaViewerActiveMapWhereUniqueInput
  }


  /**
   * MetaViewerActiveMap base type for findFirst actions
   */
  export type MetaViewerActiveMapFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     * 
    **/
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerActiveMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerActiveMaps.
     * 
    **/
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerActiveMaps.
     * 
    **/
    distinct?: Enumerable<MetaViewerActiveMapScalarFieldEnum>
  }

  /**
   * MetaViewerActiveMap: findFirst
   */
  export interface MetaViewerActiveMapFindFirstArgs extends MetaViewerActiveMapFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MetaViewerActiveMap findFirstOrThrow
   */
  export type MetaViewerActiveMapFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     * 
    **/
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerActiveMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerActiveMaps.
     * 
    **/
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerActiveMaps.
     * 
    **/
    distinct?: Enumerable<MetaViewerActiveMapScalarFieldEnum>
  }


  /**
   * MetaViewerActiveMap findMany
   */
  export type MetaViewerActiveMapFindManyArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * Filter, which MetaViewerActiveMaps to fetch.
     * 
    **/
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaViewerActiveMapOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaViewerActiveMaps.
     * 
    **/
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MetaViewerActiveMapScalarFieldEnum>
  }


  /**
   * MetaViewerActiveMap create
   */
  export type MetaViewerActiveMapCreateArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * The data needed to create a MetaViewerActiveMap.
     * 
    **/
    data: XOR<MetaViewerActiveMapCreateInput, MetaViewerActiveMapUncheckedCreateInput>
  }


  /**
   * MetaViewerActiveMap createMany
   */
  export type MetaViewerActiveMapCreateManyArgs = {
    /**
     * The data used to create many MetaViewerActiveMaps.
     * 
    **/
    data: Enumerable<MetaViewerActiveMapCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MetaViewerActiveMap update
   */
  export type MetaViewerActiveMapUpdateArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * The data needed to update a MetaViewerActiveMap.
     * 
    **/
    data: XOR<MetaViewerActiveMapUpdateInput, MetaViewerActiveMapUncheckedUpdateInput>
    /**
     * Choose, which MetaViewerActiveMap to update.
     * 
    **/
    where: MetaViewerActiveMapWhereUniqueInput
  }


  /**
   * MetaViewerActiveMap updateMany
   */
  export type MetaViewerActiveMapUpdateManyArgs = {
    /**
     * The data used to update MetaViewerActiveMaps.
     * 
    **/
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerActiveMaps to update
     * 
    **/
    where?: MetaViewerActiveMapWhereInput
  }


  /**
   * MetaViewerActiveMap upsert
   */
  export type MetaViewerActiveMapUpsertArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * The filter to search for the MetaViewerActiveMap to update in case it exists.
     * 
    **/
    where: MetaViewerActiveMapWhereUniqueInput
    /**
     * In case the MetaViewerActiveMap found by the `where` argument doesn't exist, create a new MetaViewerActiveMap with this data.
     * 
    **/
    create: XOR<MetaViewerActiveMapCreateInput, MetaViewerActiveMapUncheckedCreateInput>
    /**
     * In case the MetaViewerActiveMap was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MetaViewerActiveMapUpdateInput, MetaViewerActiveMapUncheckedUpdateInput>
  }


  /**
   * MetaViewerActiveMap delete
   */
  export type MetaViewerActiveMapDeleteArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
    /**
     * Filter which MetaViewerActiveMap to delete.
     * 
    **/
    where: MetaViewerActiveMapWhereUniqueInput
  }


  /**
   * MetaViewerActiveMap deleteMany
   */
  export type MetaViewerActiveMapDeleteManyArgs = {
    /**
     * Filter which MetaViewerActiveMaps to delete
     * 
    **/
    where?: MetaViewerActiveMapWhereInput
  }


  /**
   * MetaViewerActiveMap without action
   */
  export type MetaViewerActiveMapArgs = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     * 
    **/
    select?: MetaViewerActiveMapSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaViewerActiveMapInclude | null
  }



  /**
   * Model ProductCategory
   */


  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    description: string | null
    isDisable: boolean | null
    code: string | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    description: string | null
    isDisable: boolean | null
    code: string | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    description: number
    isDisable: number
    code: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    description?: true
    isDisable?: true
    code?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    description?: true
    isDisable?: true
    code?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    description?: true
    isDisable?: true
    code?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs = {
    /**
     * Filter which ProductCategory to aggregate.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs = {
    where?: ProductCategoryWhereInput
    orderBy?: Enumerable<ProductCategoryOrderByWithAggregationInput>
    by: Array<ProductCategoryScalarFieldEnum>
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }


  export type ProductCategoryGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    description: string | null
    isDisable: boolean
    code: string
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    description?: boolean
    isDisable?: boolean
    code?: boolean
    AncestorCategories?: boolean | ClosureProductCategoryFindManyArgs
    DescendantCategories?: boolean | ClosureProductCategoryFindManyArgs
    Products?: boolean | ProductFindManyArgs
    _count?: boolean | ProductCategoryCountOutputTypeArgs
  }


  export type ProductCategoryInclude = {
    AncestorCategories?: boolean | ClosureProductCategoryFindManyArgs
    DescendantCategories?: boolean | ClosureProductCategoryFindManyArgs
    Products?: boolean | ProductFindManyArgs
    _count?: boolean | ProductCategoryCountOutputTypeArgs
  } 

  export type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCategory :
    S extends undefined ? never :
    S extends { include: any } & (ProductCategoryArgs | ProductCategoryFindManyArgs)
    ? ProductCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'AncestorCategories' ? Array < ClosureProductCategoryGetPayload<S['include'][P]>>  :
        P extends 'DescendantCategories' ? Array < ClosureProductCategoryGetPayload<S['include'][P]>>  :
        P extends 'Products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductCategoryArgs | ProductCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'AncestorCategories' ? Array < ClosureProductCategoryGetPayload<S['select'][P]>>  :
        P extends 'DescendantCategories' ? Array < ClosureProductCategoryGetPayload<S['select'][P]>>  :
        P extends 'Products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductCategory ? ProductCategory[P] : never
  } 
      : ProductCategory


  type ProductCategoryCountArgs = Merge<
    Omit<ProductCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }
  >

  export interface ProductCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductCategory'> extends True ? Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>> : Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | null, null>

    /**
     * Find one ProductCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs>
    ): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductCategory'> extends True ? Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>> : Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | null, null>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs>
    ): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductCategoryFindManyArgs>(
      args?: SelectSubset<T, ProductCategoryFindManyArgs>
    ): PrismaPromise<Array<ProductCategoryGetPayload<T>>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
    **/
    create<T extends ProductCategoryCreateArgs>(
      args: SelectSubset<T, ProductCategoryCreateArgs>
    ): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>

    /**
     * Create many ProductCategories.
     *     @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     *     @example
     *     // Create many ProductCategories
     *     const productCategory = await prisma.productCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCategoryCreateManyArgs>(
      args?: SelectSubset<T, ProductCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
    **/
    delete<T extends ProductCategoryDeleteArgs>(
      args: SelectSubset<T, ProductCategoryDeleteArgs>
    ): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductCategoryUpdateArgs>(
      args: SelectSubset<T, ProductCategoryUpdateArgs>
    ): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ProductCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductCategoryUpdateManyArgs>(
      args: SelectSubset<T, ProductCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ProductCategoryUpsertArgs>(
      args: SelectSubset<T, ProductCategoryUpsertArgs>
    ): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>

    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductCategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AncestorCategories<T extends ClosureProductCategoryFindManyArgs= {}>(args?: Subset<T, ClosureProductCategoryFindManyArgs>): PrismaPromise<Array<ClosureProductCategoryGetPayload<T>>| Null>;

    DescendantCategories<T extends ClosureProductCategoryFindManyArgs= {}>(args?: Subset<T, ClosureProductCategoryFindManyArgs>): PrismaPromise<Array<ClosureProductCategoryGetPayload<T>>| Null>;

    Products<T extends ProductFindManyArgs= {}>(args?: Subset<T, ProductFindManyArgs>): PrismaPromise<Array<ProductGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductCategory base type for findUnique actions
   */
  export type ProductCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter, which ProductCategory to fetch.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory: findUnique
   */
  export interface ProductCategoryFindUniqueArgs extends ProductCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter, which ProductCategory to fetch.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory base type for findFirst actions
   */
  export type ProductCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter, which ProductCategory to fetch.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     * 
    **/
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }

  /**
   * ProductCategory: findFirst
   */
  export interface ProductCategoryFindFirstArgs extends ProductCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter, which ProductCategory to fetch.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     * 
    **/
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter, which ProductCategories to fetch.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * The data needed to create a ProductCategory.
     * 
    **/
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }


  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs = {
    /**
     * The data used to create many ProductCategories.
     * 
    **/
    data: Enumerable<ProductCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * The data needed to update a ProductCategory.
     * 
    **/
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs = {
    /**
     * The data used to update ProductCategories.
     * 
    **/
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     * 
    **/
    where?: ProductCategoryWhereInput
  }


  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     * 
    **/
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }


  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter which ProductCategory to delete.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs = {
    /**
     * Filter which ProductCategories to delete
     * 
    **/
    where?: ProductCategoryWhereInput
  }


  /**
   * ProductCategory without action
   */
  export type ProductCategoryArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
  }



  /**
   * Model ClosureProductCategory
   */


  export type AggregateClosureProductCategory = {
    _count: ClosureProductCategoryCountAggregateOutputType | null
    _avg: ClosureProductCategoryAvgAggregateOutputType | null
    _sum: ClosureProductCategorySumAggregateOutputType | null
    _min: ClosureProductCategoryMinAggregateOutputType | null
    _max: ClosureProductCategoryMaxAggregateOutputType | null
  }

  export type ClosureProductCategoryAvgAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategorySumAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategoryMinAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategoryMaxAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategoryCountAggregateOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _all: number
  }


  export type ClosureProductCategoryAvgAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategorySumAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategoryMinAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategoryMaxAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategoryCountAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
    _all?: true
  }

  export type ClosureProductCategoryAggregateArgs = {
    /**
     * Filter which ClosureProductCategory to aggregate.
     * 
    **/
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClosureProductCategories
    **/
    _count?: true | ClosureProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClosureProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClosureProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClosureProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClosureProductCategoryMaxAggregateInputType
  }

  export type GetClosureProductCategoryAggregateType<T extends ClosureProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateClosureProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClosureProductCategory[P]>
      : GetScalarType<T[P], AggregateClosureProductCategory[P]>
  }




  export type ClosureProductCategoryGroupByArgs = {
    where?: ClosureProductCategoryWhereInput
    orderBy?: Enumerable<ClosureProductCategoryOrderByWithAggregationInput>
    by: Array<ClosureProductCategoryScalarFieldEnum>
    having?: ClosureProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClosureProductCategoryCountAggregateInputType | true
    _avg?: ClosureProductCategoryAvgAggregateInputType
    _sum?: ClosureProductCategorySumAggregateInputType
    _min?: ClosureProductCategoryMinAggregateInputType
    _max?: ClosureProductCategoryMaxAggregateInputType
  }


  export type ClosureProductCategoryGroupByOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _count: ClosureProductCategoryCountAggregateOutputType | null
    _avg: ClosureProductCategoryAvgAggregateOutputType | null
    _sum: ClosureProductCategorySumAggregateOutputType | null
    _min: ClosureProductCategoryMinAggregateOutputType | null
    _max: ClosureProductCategoryMaxAggregateOutputType | null
  }

  type GetClosureProductCategoryGroupByPayload<T extends ClosureProductCategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClosureProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClosureProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClosureProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ClosureProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ClosureProductCategorySelect = {
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | ProductCategoryArgs
    DescendantCategory?: boolean | ProductCategoryArgs
  }


  export type ClosureProductCategoryInclude = {
    AncestorCategory?: boolean | ProductCategoryArgs
    DescendantCategory?: boolean | ProductCategoryArgs
  } 

  export type ClosureProductCategoryGetPayload<S extends boolean | null | undefined | ClosureProductCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClosureProductCategory :
    S extends undefined ? never :
    S extends { include: any } & (ClosureProductCategoryArgs | ClosureProductCategoryFindManyArgs)
    ? ClosureProductCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'AncestorCategory' ? ProductCategoryGetPayload<S['include'][P]> :
        P extends 'DescendantCategory' ? ProductCategoryGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ClosureProductCategoryArgs | ClosureProductCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'AncestorCategory' ? ProductCategoryGetPayload<S['select'][P]> :
        P extends 'DescendantCategory' ? ProductCategoryGetPayload<S['select'][P]> :  P extends keyof ClosureProductCategory ? ClosureProductCategory[P] : never
  } 
      : ClosureProductCategory


  type ClosureProductCategoryCountArgs = Merge<
    Omit<ClosureProductCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ClosureProductCategoryCountAggregateInputType | true
    }
  >

  export interface ClosureProductCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ClosureProductCategory that matches the filter.
     * @param {ClosureProductCategoryFindUniqueArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClosureProductCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClosureProductCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClosureProductCategory'> extends True ? Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>> : Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T> | null, null>

    /**
     * Find one ClosureProductCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClosureProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClosureProductCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClosureProductCategoryFindUniqueOrThrowArgs>
    ): Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>>

    /**
     * Find the first ClosureProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryFindFirstArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClosureProductCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClosureProductCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClosureProductCategory'> extends True ? Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>> : Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T> | null, null>

    /**
     * Find the first ClosureProductCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClosureProductCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClosureProductCategoryFindFirstOrThrowArgs>
    ): Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>>

    /**
     * Find zero or more ClosureProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClosureProductCategories
     * const closureProductCategories = await prisma.closureProductCategory.findMany()
     * 
     * // Get first 10 ClosureProductCategories
     * const closureProductCategories = await prisma.closureProductCategory.findMany({ take: 10 })
     * 
     * // Only select the `ancestor`
     * const closureProductCategoryWithAncestorOnly = await prisma.closureProductCategory.findMany({ select: { ancestor: true } })
     * 
    **/
    findMany<T extends ClosureProductCategoryFindManyArgs>(
      args?: SelectSubset<T, ClosureProductCategoryFindManyArgs>
    ): PrismaPromise<Array<ClosureProductCategoryGetPayload<T>>>

    /**
     * Create a ClosureProductCategory.
     * @param {ClosureProductCategoryCreateArgs} args - Arguments to create a ClosureProductCategory.
     * @example
     * // Create one ClosureProductCategory
     * const ClosureProductCategory = await prisma.closureProductCategory.create({
     *   data: {
     *     // ... data to create a ClosureProductCategory
     *   }
     * })
     * 
    **/
    create<T extends ClosureProductCategoryCreateArgs>(
      args: SelectSubset<T, ClosureProductCategoryCreateArgs>
    ): Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>>

    /**
     * Create many ClosureProductCategories.
     *     @param {ClosureProductCategoryCreateManyArgs} args - Arguments to create many ClosureProductCategories.
     *     @example
     *     // Create many ClosureProductCategories
     *     const closureProductCategory = await prisma.closureProductCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClosureProductCategoryCreateManyArgs>(
      args?: SelectSubset<T, ClosureProductCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ClosureProductCategory.
     * @param {ClosureProductCategoryDeleteArgs} args - Arguments to delete one ClosureProductCategory.
     * @example
     * // Delete one ClosureProductCategory
     * const ClosureProductCategory = await prisma.closureProductCategory.delete({
     *   where: {
     *     // ... filter to delete one ClosureProductCategory
     *   }
     * })
     * 
    **/
    delete<T extends ClosureProductCategoryDeleteArgs>(
      args: SelectSubset<T, ClosureProductCategoryDeleteArgs>
    ): Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>>

    /**
     * Update one ClosureProductCategory.
     * @param {ClosureProductCategoryUpdateArgs} args - Arguments to update one ClosureProductCategory.
     * @example
     * // Update one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClosureProductCategoryUpdateArgs>(
      args: SelectSubset<T, ClosureProductCategoryUpdateArgs>
    ): Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>>

    /**
     * Delete zero or more ClosureProductCategories.
     * @param {ClosureProductCategoryDeleteManyArgs} args - Arguments to filter ClosureProductCategories to delete.
     * @example
     * // Delete a few ClosureProductCategories
     * const { count } = await prisma.closureProductCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClosureProductCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ClosureProductCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClosureProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClosureProductCategories
     * const closureProductCategory = await prisma.closureProductCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClosureProductCategoryUpdateManyArgs>(
      args: SelectSubset<T, ClosureProductCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ClosureProductCategory.
     * @param {ClosureProductCategoryUpsertArgs} args - Arguments to update or create a ClosureProductCategory.
     * @example
     * // Update or create a ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.upsert({
     *   create: {
     *     // ... data to create a ClosureProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClosureProductCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ClosureProductCategoryUpsertArgs>(
      args: SelectSubset<T, ClosureProductCategoryUpsertArgs>
    ): Prisma__ClosureProductCategoryClient<ClosureProductCategoryGetPayload<T>>

    /**
     * Count the number of ClosureProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryCountArgs} args - Arguments to filter ClosureProductCategories to count.
     * @example
     * // Count the number of ClosureProductCategories
     * const count = await prisma.closureProductCategory.count({
     *   where: {
     *     // ... the filter for the ClosureProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ClosureProductCategoryCountArgs>(
      args?: Subset<T, ClosureProductCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClosureProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClosureProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClosureProductCategoryAggregateArgs>(args: Subset<T, ClosureProductCategoryAggregateArgs>): PrismaPromise<GetClosureProductCategoryAggregateType<T>>

    /**
     * Group by ClosureProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClosureProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClosureProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ClosureProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClosureProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosureProductCategoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClosureProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClosureProductCategoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AncestorCategory<T extends ProductCategoryArgs= {}>(args?: Subset<T, ProductCategoryArgs>): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | Null>;

    DescendantCategory<T extends ProductCategoryArgs= {}>(args?: Subset<T, ProductCategoryArgs>): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClosureProductCategory base type for findUnique actions
   */
  export type ClosureProductCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     * 
    **/
    where: ClosureProductCategoryWhereUniqueInput
  }

  /**
   * ClosureProductCategory: findUnique
   */
  export interface ClosureProductCategoryFindUniqueArgs extends ClosureProductCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClosureProductCategory findUniqueOrThrow
   */
  export type ClosureProductCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     * 
    **/
    where: ClosureProductCategoryWhereUniqueInput
  }


  /**
   * ClosureProductCategory base type for findFirst actions
   */
  export type ClosureProductCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     * 
    **/
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureProductCategories.
     * 
    **/
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureProductCategories.
     * 
    **/
    distinct?: Enumerable<ClosureProductCategoryScalarFieldEnum>
  }

  /**
   * ClosureProductCategory: findFirst
   */
  export interface ClosureProductCategoryFindFirstArgs extends ClosureProductCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClosureProductCategory findFirstOrThrow
   */
  export type ClosureProductCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     * 
    **/
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureProductCategories.
     * 
    **/
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureProductCategories.
     * 
    **/
    distinct?: Enumerable<ClosureProductCategoryScalarFieldEnum>
  }


  /**
   * ClosureProductCategory findMany
   */
  export type ClosureProductCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * Filter, which ClosureProductCategories to fetch.
     * 
    **/
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ClosureProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClosureProductCategories.
     * 
    **/
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClosureProductCategoryScalarFieldEnum>
  }


  /**
   * ClosureProductCategory create
   */
  export type ClosureProductCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * The data needed to create a ClosureProductCategory.
     * 
    **/
    data: XOR<ClosureProductCategoryCreateInput, ClosureProductCategoryUncheckedCreateInput>
  }


  /**
   * ClosureProductCategory createMany
   */
  export type ClosureProductCategoryCreateManyArgs = {
    /**
     * The data used to create many ClosureProductCategories.
     * 
    **/
    data: Enumerable<ClosureProductCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ClosureProductCategory update
   */
  export type ClosureProductCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * The data needed to update a ClosureProductCategory.
     * 
    **/
    data: XOR<ClosureProductCategoryUpdateInput, ClosureProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ClosureProductCategory to update.
     * 
    **/
    where: ClosureProductCategoryWhereUniqueInput
  }


  /**
   * ClosureProductCategory updateMany
   */
  export type ClosureProductCategoryUpdateManyArgs = {
    /**
     * The data used to update ClosureProductCategories.
     * 
    **/
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ClosureProductCategories to update
     * 
    **/
    where?: ClosureProductCategoryWhereInput
  }


  /**
   * ClosureProductCategory upsert
   */
  export type ClosureProductCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * The filter to search for the ClosureProductCategory to update in case it exists.
     * 
    **/
    where: ClosureProductCategoryWhereUniqueInput
    /**
     * In case the ClosureProductCategory found by the `where` argument doesn't exist, create a new ClosureProductCategory with this data.
     * 
    **/
    create: XOR<ClosureProductCategoryCreateInput, ClosureProductCategoryUncheckedCreateInput>
    /**
     * In case the ClosureProductCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClosureProductCategoryUpdateInput, ClosureProductCategoryUncheckedUpdateInput>
  }


  /**
   * ClosureProductCategory delete
   */
  export type ClosureProductCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
    /**
     * Filter which ClosureProductCategory to delete.
     * 
    **/
    where: ClosureProductCategoryWhereUniqueInput
  }


  /**
   * ClosureProductCategory deleteMany
   */
  export type ClosureProductCategoryDeleteManyArgs = {
    /**
     * Filter which ClosureProductCategories to delete
     * 
    **/
    where?: ClosureProductCategoryWhereInput
  }


  /**
   * ClosureProductCategory without action
   */
  export type ClosureProductCategoryArgs = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     * 
    **/
    select?: ClosureProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClosureProductCategoryInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    categoryId: number | null
    cafeInfoId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    categoryId: number | null
    cafeInfoId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    isDisable: boolean | null
    isAvailable: boolean | null
    categoryId: number | null
    cafeInfoId: number | null
    productRedirectUrl: string | null
    isSignature: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    isDisable: boolean | null
    isAvailable: boolean | null
    categoryId: number | null
    cafeInfoId: number | null
    productRedirectUrl: string | null
    isSignature: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    code: number
    description: number
    price: number
    originalPrice: number
    stockQuantity: number
    minOrderQuantity: number
    isDisable: number
    isAvailable: number
    categoryId: number
    cafeInfoId: number
    productRedirectUrl: number
    isSignature: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    categoryId?: true
    cafeInfoId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    categoryId?: true
    cafeInfoId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    description?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    isDisable?: true
    isAvailable?: true
    categoryId?: true
    cafeInfoId?: true
    productRedirectUrl?: true
    isSignature?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    description?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    isDisable?: true
    isAvailable?: true
    categoryId?: true
    cafeInfoId?: true
    productRedirectUrl?: true
    isSignature?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    description?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    isDisable?: true
    isAvailable?: true
    categoryId?: true
    cafeInfoId?: true
    productRedirectUrl?: true
    isSignature?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    code: string
    description: string | null
    price: number
    originalPrice: number | null
    stockQuantity: number
    minOrderQuantity: number
    isDisable: boolean
    isAvailable: boolean
    categoryId: number
    cafeInfoId: number | null
    productRedirectUrl: string | null
    isSignature: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    isDisable?: boolean
    isAvailable?: boolean
    categoryId?: boolean
    ProductCategory?: boolean | ProductCategoryArgs
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoArgs
    WishlistProducts?: boolean | WishlistProductFindManyArgs
    ProductImages?: boolean | ProductImageFindManyArgs
    productRedirectUrl?: boolean
    isSignature?: boolean
    _count?: boolean | ProductCountOutputTypeArgs
  }


  export type ProductInclude = {
    ProductCategory?: boolean | ProductCategoryArgs
    CafeInfo?: boolean | CafeInfoArgs
    WishlistProducts?: boolean | WishlistProductFindManyArgs
    ProductImages?: boolean | ProductImageFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  } 

  export type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Product :
    S extends undefined ? never :
    S extends { include: any } & (ProductArgs | ProductFindManyArgs)
    ? Product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ProductCategory' ? ProductCategoryGetPayload<S['include'][P]> :
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['include'][P]> | null :
        P extends 'WishlistProducts' ? Array < WishlistProductGetPayload<S['include'][P]>>  :
        P extends 'ProductImages' ? Array < ProductImageGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductArgs | ProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ProductCategory' ? ProductCategoryGetPayload<S['select'][P]> :
        P extends 'CafeInfo' ? CafeInfoGetPayload<S['select'][P]> | null :
        P extends 'WishlistProducts' ? Array < WishlistProductGetPayload<S['select'][P]>>  :
        P extends 'ProductImages' ? Array < ProductImageGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
      : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): PrismaPromise<Array<ProductGetPayload<T>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProductCategory<T extends ProductCategoryArgs= {}>(args?: Subset<T, ProductCategoryArgs>): Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | Null>;

    CafeInfo<T extends CafeInfoArgs= {}>(args?: Subset<T, CafeInfoArgs>): Prisma__CafeInfoClient<CafeInfoGetPayload<T> | Null>;

    WishlistProducts<T extends WishlistProductFindManyArgs= {}>(args?: Subset<T, WishlistProductFindManyArgs>): PrismaPromise<Array<WishlistProductGetPayload<T>>| Null>;

    ProductImages<T extends ProductImageFindManyArgs= {}>(args?: Subset<T, ProductImageFindManyArgs>): PrismaPromise<Array<ProductImageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }

  /**
   * Product: findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product: findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model WishlistProduct
   */


  export type AggregateWishlistProduct = {
    _count: WishlistProductCountAggregateOutputType | null
    _avg: WishlistProductAvgAggregateOutputType | null
    _sum: WishlistProductSumAggregateOutputType | null
    _min: WishlistProductMinAggregateOutputType | null
    _max: WishlistProductMaxAggregateOutputType | null
  }

  export type WishlistProductAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductSumAggregateOutputType = {
    id: number | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductCountAggregateOutputType = {
    id: number
    createdAt: number
    productId: number
    proxyUserId: number
    _all: number
  }


  export type WishlistProductAvgAggregateInputType = {
    id?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductSumAggregateInputType = {
    id?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    proxyUserId?: true
    _all?: true
  }

  export type WishlistProductAggregateArgs = {
    /**
     * Filter which WishlistProduct to aggregate.
     * 
    **/
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<WishlistProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistProducts
    **/
    _count?: true | WishlistProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistProductMaxAggregateInputType
  }

  export type GetWishlistProductAggregateType<T extends WishlistProductAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistProduct[P]>
      : GetScalarType<T[P], AggregateWishlistProduct[P]>
  }




  export type WishlistProductGroupByArgs = {
    where?: WishlistProductWhereInput
    orderBy?: Enumerable<WishlistProductOrderByWithAggregationInput>
    by: Array<WishlistProductScalarFieldEnum>
    having?: WishlistProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistProductCountAggregateInputType | true
    _avg?: WishlistProductAvgAggregateInputType
    _sum?: WishlistProductSumAggregateInputType
    _min?: WishlistProductMinAggregateInputType
    _max?: WishlistProductMaxAggregateInputType
  }


  export type WishlistProductGroupByOutputType = {
    id: number
    createdAt: Date
    productId: number
    proxyUserId: number
    _count: WishlistProductCountAggregateOutputType | null
    _avg: WishlistProductAvgAggregateOutputType | null
    _sum: WishlistProductSumAggregateOutputType | null
    _min: WishlistProductMinAggregateOutputType | null
    _max: WishlistProductMaxAggregateOutputType | null
  }

  type GetWishlistProductGroupByPayload<T extends WishlistProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WishlistProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistProductGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistProductGroupByOutputType[P]>
        }
      >
    >


  export type WishlistProductSelect = {
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    Product?: boolean | ProductArgs
    proxyUserId?: boolean
    ProxyUser?: boolean | ProxyUserArgs
  }


  export type WishlistProductInclude = {
    Product?: boolean | ProductArgs
    ProxyUser?: boolean | ProxyUserArgs
  } 

  export type WishlistProductGetPayload<S extends boolean | null | undefined | WishlistProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WishlistProduct :
    S extends undefined ? never :
    S extends { include: any } & (WishlistProductArgs | WishlistProductFindManyArgs)
    ? WishlistProduct  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Product' ? ProductGetPayload<S['include'][P]> :
        P extends 'ProxyUser' ? ProxyUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WishlistProductArgs | WishlistProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Product' ? ProductGetPayload<S['select'][P]> :
        P extends 'ProxyUser' ? ProxyUserGetPayload<S['select'][P]> :  P extends keyof WishlistProduct ? WishlistProduct[P] : never
  } 
      : WishlistProduct


  type WishlistProductCountArgs = Merge<
    Omit<WishlistProductFindManyArgs, 'select' | 'include'> & {
      select?: WishlistProductCountAggregateInputType | true
    }
  >

  export interface WishlistProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one WishlistProduct that matches the filter.
     * @param {WishlistProductFindUniqueArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WishlistProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WishlistProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WishlistProduct'> extends True ? Prisma__WishlistProductClient<WishlistProductGetPayload<T>> : Prisma__WishlistProductClient<WishlistProductGetPayload<T> | null, null>

    /**
     * Find one WishlistProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WishlistProductFindUniqueOrThrowArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WishlistProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WishlistProductFindUniqueOrThrowArgs>
    ): Prisma__WishlistProductClient<WishlistProductGetPayload<T>>

    /**
     * Find the first WishlistProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductFindFirstArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WishlistProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WishlistProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WishlistProduct'> extends True ? Prisma__WishlistProductClient<WishlistProductGetPayload<T>> : Prisma__WishlistProductClient<WishlistProductGetPayload<T> | null, null>

    /**
     * Find the first WishlistProduct that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductFindFirstOrThrowArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WishlistProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WishlistProductFindFirstOrThrowArgs>
    ): Prisma__WishlistProductClient<WishlistProductGetPayload<T>>

    /**
     * Find zero or more WishlistProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistProducts
     * const wishlistProducts = await prisma.wishlistProduct.findMany()
     * 
     * // Get first 10 WishlistProducts
     * const wishlistProducts = await prisma.wishlistProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistProductWithIdOnly = await prisma.wishlistProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WishlistProductFindManyArgs>(
      args?: SelectSubset<T, WishlistProductFindManyArgs>
    ): PrismaPromise<Array<WishlistProductGetPayload<T>>>

    /**
     * Create a WishlistProduct.
     * @param {WishlistProductCreateArgs} args - Arguments to create a WishlistProduct.
     * @example
     * // Create one WishlistProduct
     * const WishlistProduct = await prisma.wishlistProduct.create({
     *   data: {
     *     // ... data to create a WishlistProduct
     *   }
     * })
     * 
    **/
    create<T extends WishlistProductCreateArgs>(
      args: SelectSubset<T, WishlistProductCreateArgs>
    ): Prisma__WishlistProductClient<WishlistProductGetPayload<T>>

    /**
     * Create many WishlistProducts.
     *     @param {WishlistProductCreateManyArgs} args - Arguments to create many WishlistProducts.
     *     @example
     *     // Create many WishlistProducts
     *     const wishlistProduct = await prisma.wishlistProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WishlistProductCreateManyArgs>(
      args?: SelectSubset<T, WishlistProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WishlistProduct.
     * @param {WishlistProductDeleteArgs} args - Arguments to delete one WishlistProduct.
     * @example
     * // Delete one WishlistProduct
     * const WishlistProduct = await prisma.wishlistProduct.delete({
     *   where: {
     *     // ... filter to delete one WishlistProduct
     *   }
     * })
     * 
    **/
    delete<T extends WishlistProductDeleteArgs>(
      args: SelectSubset<T, WishlistProductDeleteArgs>
    ): Prisma__WishlistProductClient<WishlistProductGetPayload<T>>

    /**
     * Update one WishlistProduct.
     * @param {WishlistProductUpdateArgs} args - Arguments to update one WishlistProduct.
     * @example
     * // Update one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WishlistProductUpdateArgs>(
      args: SelectSubset<T, WishlistProductUpdateArgs>
    ): Prisma__WishlistProductClient<WishlistProductGetPayload<T>>

    /**
     * Delete zero or more WishlistProducts.
     * @param {WishlistProductDeleteManyArgs} args - Arguments to filter WishlistProducts to delete.
     * @example
     * // Delete a few WishlistProducts
     * const { count } = await prisma.wishlistProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WishlistProductDeleteManyArgs>(
      args?: SelectSubset<T, WishlistProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistProducts
     * const wishlistProduct = await prisma.wishlistProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WishlistProductUpdateManyArgs>(
      args: SelectSubset<T, WishlistProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WishlistProduct.
     * @param {WishlistProductUpsertArgs} args - Arguments to update or create a WishlistProduct.
     * @example
     * // Update or create a WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.upsert({
     *   create: {
     *     // ... data to create a WishlistProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistProduct we want to update
     *   }
     * })
    **/
    upsert<T extends WishlistProductUpsertArgs>(
      args: SelectSubset<T, WishlistProductUpsertArgs>
    ): Prisma__WishlistProductClient<WishlistProductGetPayload<T>>

    /**
     * Count the number of WishlistProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductCountArgs} args - Arguments to filter WishlistProducts to count.
     * @example
     * // Count the number of WishlistProducts
     * const count = await prisma.wishlistProduct.count({
     *   where: {
     *     // ... the filter for the WishlistProducts we want to count
     *   }
     * })
    **/
    count<T extends WishlistProductCountArgs>(
      args?: Subset<T, WishlistProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistProductAggregateArgs>(args: Subset<T, WishlistProductAggregateArgs>): PrismaPromise<GetWishlistProductAggregateType<T>>

    /**
     * Group by WishlistProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistProductGroupByArgs['orderBy'] }
        : { orderBy?: WishlistProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistProductGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WishlistProductClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    ProxyUser<T extends ProxyUserArgs= {}>(args?: Subset<T, ProxyUserArgs>): Prisma__ProxyUserClient<ProxyUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WishlistProduct base type for findUnique actions
   */
  export type WishlistProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * Filter, which WishlistProduct to fetch.
     * 
    **/
    where: WishlistProductWhereUniqueInput
  }

  /**
   * WishlistProduct: findUnique
   */
  export interface WishlistProductFindUniqueArgs extends WishlistProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WishlistProduct findUniqueOrThrow
   */
  export type WishlistProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * Filter, which WishlistProduct to fetch.
     * 
    **/
    where: WishlistProductWhereUniqueInput
  }


  /**
   * WishlistProduct base type for findFirst actions
   */
  export type WishlistProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * Filter, which WishlistProduct to fetch.
     * 
    **/
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<WishlistProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistProducts.
     * 
    **/
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistProducts.
     * 
    **/
    distinct?: Enumerable<WishlistProductScalarFieldEnum>
  }

  /**
   * WishlistProduct: findFirst
   */
  export interface WishlistProductFindFirstArgs extends WishlistProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WishlistProduct findFirstOrThrow
   */
  export type WishlistProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * Filter, which WishlistProduct to fetch.
     * 
    **/
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<WishlistProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistProducts.
     * 
    **/
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistProducts.
     * 
    **/
    distinct?: Enumerable<WishlistProductScalarFieldEnum>
  }


  /**
   * WishlistProduct findMany
   */
  export type WishlistProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * Filter, which WishlistProducts to fetch.
     * 
    **/
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<WishlistProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistProducts.
     * 
    **/
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WishlistProductScalarFieldEnum>
  }


  /**
   * WishlistProduct create
   */
  export type WishlistProductCreateArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * The data needed to create a WishlistProduct.
     * 
    **/
    data: XOR<WishlistProductCreateInput, WishlistProductUncheckedCreateInput>
  }


  /**
   * WishlistProduct createMany
   */
  export type WishlistProductCreateManyArgs = {
    /**
     * The data used to create many WishlistProducts.
     * 
    **/
    data: Enumerable<WishlistProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WishlistProduct update
   */
  export type WishlistProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * The data needed to update a WishlistProduct.
     * 
    **/
    data: XOR<WishlistProductUpdateInput, WishlistProductUncheckedUpdateInput>
    /**
     * Choose, which WishlistProduct to update.
     * 
    **/
    where: WishlistProductWhereUniqueInput
  }


  /**
   * WishlistProduct updateMany
   */
  export type WishlistProductUpdateManyArgs = {
    /**
     * The data used to update WishlistProducts.
     * 
    **/
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyInput>
    /**
     * Filter which WishlistProducts to update
     * 
    **/
    where?: WishlistProductWhereInput
  }


  /**
   * WishlistProduct upsert
   */
  export type WishlistProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * The filter to search for the WishlistProduct to update in case it exists.
     * 
    **/
    where: WishlistProductWhereUniqueInput
    /**
     * In case the WishlistProduct found by the `where` argument doesn't exist, create a new WishlistProduct with this data.
     * 
    **/
    create: XOR<WishlistProductCreateInput, WishlistProductUncheckedCreateInput>
    /**
     * In case the WishlistProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WishlistProductUpdateInput, WishlistProductUncheckedUpdateInput>
  }


  /**
   * WishlistProduct delete
   */
  export type WishlistProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
    /**
     * Filter which WishlistProduct to delete.
     * 
    **/
    where: WishlistProductWhereUniqueInput
  }


  /**
   * WishlistProduct deleteMany
   */
  export type WishlistProductDeleteManyArgs = {
    /**
     * Filter which WishlistProducts to delete
     * 
    **/
    where?: WishlistProductWhereInput
  }


  /**
   * WishlistProduct without action
   */
  export type WishlistProductArgs = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     * 
    **/
    select?: WishlistProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WishlistProductInclude | null
  }



  /**
   * Model ProductImage
   */


  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    productId: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    productId: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isDisable: boolean | null
    isThumb: boolean | null
    productId: number | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isDisable: boolean | null
    isThumb: boolean | null
    productId: number | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    thumbnailUrl: number
    width: number
    height: number
    size: number
    isDisable: number
    isThumb: number
    productId: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    productId?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    productId?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isDisable?: true
    isThumb?: true
    productId?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isDisable?: true
    isThumb?: true
    productId?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isDisable?: true
    isThumb?: true
    productId?: true
    _all?: true
  }

  export type ProductImageAggregateArgs = {
    /**
     * Filter which ProductImage to aggregate.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs = {
    where?: ProductImageWhereInput
    orderBy?: Enumerable<ProductImageOrderByWithAggregationInput>
    by: Array<ProductImageScalarFieldEnum>
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }


  export type ProductImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable: boolean
    isThumb: boolean
    productId: number
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isDisable?: boolean
    isThumb?: boolean
    productId?: boolean
    Product?: boolean | ProductArgs
  }


  export type ProductImageInclude = {
    Product?: boolean | ProductArgs
  } 

  export type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductImage :
    S extends undefined ? never :
    S extends { include: any } & (ProductImageArgs | ProductImageFindManyArgs)
    ? ProductImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductImageArgs | ProductImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Product' ? ProductGetPayload<S['select'][P]> :  P extends keyof ProductImage ? ProductImage[P] : never
  } 
      : ProductImage


  type ProductImageCountArgs = Merge<
    Omit<ProductImageFindManyArgs, 'select' | 'include'> & {
      select?: ProductImageCountAggregateInputType | true
    }
  >

  export interface ProductImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductImage'> extends True ? Prisma__ProductImageClient<ProductImageGetPayload<T>> : Prisma__ProductImageClient<ProductImageGetPayload<T> | null, null>

    /**
     * Find one ProductImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductImageFindUniqueOrThrowArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductImage'> extends True ? Prisma__ProductImageClient<ProductImageGetPayload<T>> : Prisma__ProductImageClient<ProductImageGetPayload<T> | null, null>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductImageFindManyArgs>(
      args?: SelectSubset<T, ProductImageFindManyArgs>
    ): PrismaPromise<Array<ProductImageGetPayload<T>>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
    **/
    create<T extends ProductImageCreateArgs>(
      args: SelectSubset<T, ProductImageCreateArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Create many ProductImages.
     *     @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     *     @example
     *     // Create many ProductImages
     *     const productImage = await prisma.productImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductImageCreateManyArgs>(
      args?: SelectSubset<T, ProductImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
    **/
    delete<T extends ProductImageDeleteArgs>(
      args: SelectSubset<T, ProductImageDeleteArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductImageUpdateArgs>(
      args: SelectSubset<T, ProductImageUpdateArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductImageDeleteManyArgs>(
      args?: SelectSubset<T, ProductImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductImageUpdateManyArgs>(
      args: SelectSubset<T, ProductImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
    **/
    upsert<T extends ProductImageUpsertArgs>(
      args: SelectSubset<T, ProductImageUpsertArgs>
    ): Prisma__ProductImageClient<ProductImageGetPayload<T>>

    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductImageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductImage base type for findUnique actions
   */
  export type ProductImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage: findUnique
   */
  export interface ProductImageFindUniqueArgs extends ProductImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage base type for findFirst actions
   */
  export type ProductImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     * 
    **/
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }

  /**
   * ProductImage: findFirst
   */
  export interface ProductImageFindFirstArgs extends ProductImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImage to fetch.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     * 
    **/
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImages to fetch.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * The data needed to create a ProductImage.
     * 
    **/
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }


  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs = {
    /**
     * The data used to create many ProductImages.
     * 
    **/
    data: Enumerable<ProductImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * The data needed to update a ProductImage.
     * 
    **/
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs = {
    /**
     * The data used to update ProductImages.
     * 
    **/
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     * 
    **/
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     * 
    **/
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     * 
    **/
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }


  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter which ProductImage to delete.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs = {
    /**
     * Filter which ProductImages to delete
     * 
    **/
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage without action
   */
  export type ProductImageArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BoardImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    width: 'width',
    height: 'height',
    size: 'size',
    isThumb: 'isThumb',
    isDisable: 'isDisable',
    boardId: 'boardId'
  };

  export type BoardImageScalarFieldEnum = (typeof BoardImageScalarFieldEnum)[keyof typeof BoardImageScalarFieldEnum]


  export const BoardReplyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    isDisable: 'isDisable',
    userId: 'userId',
    boardId: 'boardId',
    boardReplyId: 'boardReplyId'
  };

  export type BoardReplyScalarFieldEnum = (typeof BoardReplyScalarFieldEnum)[keyof typeof BoardReplyScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    content: 'content',
    link: 'link',
    startDay: 'startDay',
    endDay: 'endDay',
    isDisable: 'isDisable',
    isReplyAvaliable: 'isReplyAvaliable',
    userId: 'userId',
    boardType: 'boardType'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const CafeBoardScalarFieldEnum: {
    boardId: 'boardId',
    cafeInfoId: 'cafeInfoId',
    createdAt: 'createdAt'
  };

  export type CafeBoardScalarFieldEnum = (typeof CafeBoardScalarFieldEnum)[keyof typeof CafeBoardScalarFieldEnum]


  export const CafeCouponGoupPartnerScalarFieldEnum: {
    cafeCouponGroupId: 'cafeCouponGroupId',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeCouponGoupPartnerScalarFieldEnum = (typeof CafeCouponGoupPartnerScalarFieldEnum)[keyof typeof CafeCouponGoupPartnerScalarFieldEnum]


  export const CafeCouponGroupScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    code: 'code',
    name: 'name',
    tag: 'tag',
    description: 'description',
    isDisable: 'isDisable',
    startDay: 'startDay',
    endDay: 'endDay',
    issuanceStartDay: 'issuanceStartDay',
    issuanceEndDay: 'issuanceEndDay'
  };

  export type CafeCouponGroupScalarFieldEnum = (typeof CafeCouponGroupScalarFieldEnum)[keyof typeof CafeCouponGroupScalarFieldEnum]


  export const CafeCouponHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    cafeCouponId: 'cafeCouponId',
    eventType: 'eventType',
    description: 'description',
    actorId: 'actorId',
    statusBefore: 'statusBefore',
    statusAfter: 'statusAfter'
  };

  export type CafeCouponHistoryScalarFieldEnum = (typeof CafeCouponHistoryScalarFieldEnum)[keyof typeof CafeCouponHistoryScalarFieldEnum]


  export const CafeCouponQRCodeScalarFieldEnum: {
    serialNumber: 'serialNumber',
    createdAt: 'createdAt',
    isDisable: 'isDisable',
    cafeCouponId: 'cafeCouponId',
    size: 'size',
    base64Data: 'base64Data'
  };

  export type CafeCouponQRCodeScalarFieldEnum = (typeof CafeCouponQRCodeScalarFieldEnum)[keyof typeof CafeCouponQRCodeScalarFieldEnum]


  export const CafeCouponScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    content: 'content',
    serialNumber: 'serialNumber',
    startDay: 'startDay',
    endDay: 'endDay',
    isDisable: 'isDisable',
    proxyUserId: 'proxyUserId',
    cafeCouponGroupId: 'cafeCouponGroupId'
  };

  export type CafeCouponScalarFieldEnum = (typeof CafeCouponScalarFieldEnum)[keyof typeof CafeCouponScalarFieldEnum]


  export const CafeInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDisable: 'isDisable',
    name: 'name',
    code: 'code',
    regionCategoryId: 'regionCategoryId',
    address: 'address',
    directions: 'directions',
    businessNumber: 'businessNumber',
    ceoName: 'ceoName'
  };

  export type CafeInfoScalarFieldEnum = (typeof CafeInfoScalarFieldEnum)[keyof typeof CafeInfoScalarFieldEnum]


  export const CafeRealImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    width: 'width',
    height: 'height',
    size: 'size',
    priority: 'priority',
    isDisable: 'isDisable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeRealImageScalarFieldEnum = (typeof CafeRealImageScalarFieldEnum)[keyof typeof CafeRealImageScalarFieldEnum]


  export const CafeThumbnailImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    width: 'width',
    height: 'height',
    size: 'size',
    priority: 'priority',
    isDisable: 'isDisable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeThumbnailImageScalarFieldEnum = (typeof CafeThumbnailImageScalarFieldEnum)[keyof typeof CafeThumbnailImageScalarFieldEnum]


  export const CafeVirtualImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    width: 'width',
    height: 'height',
    size: 'size',
    priority: 'priority',
    isDisable: 'isDisable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeVirtualImageScalarFieldEnum = (typeof CafeVirtualImageScalarFieldEnum)[keyof typeof CafeVirtualImageScalarFieldEnum]


  export const CafeVirtualLinkScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    url: 'url',
    type: 'type',
    isDisable: 'isDisable',
    isAvaliable: 'isAvaliable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeVirtualLinkScalarFieldEnum = (typeof CafeVirtualLinkScalarFieldEnum)[keyof typeof CafeVirtualLinkScalarFieldEnum]


  export const CafeVirtualLinkThumbnailImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    width: 'width',
    height: 'height',
    size: 'size',
    cafeVirtualLinkId: 'cafeVirtualLinkId'
  };

  export type CafeVirtualLinkThumbnailImageScalarFieldEnum = (typeof CafeVirtualLinkThumbnailImageScalarFieldEnum)[keyof typeof CafeVirtualLinkThumbnailImageScalarFieldEnum]


  export const ClosureProductCategoryScalarFieldEnum: {
    ancestor: 'ancestor',
    descendant: 'descendant',
    depth: 'depth'
  };

  export type ClosureProductCategoryScalarFieldEnum = (typeof ClosureProductCategoryScalarFieldEnum)[keyof typeof ClosureProductCategoryScalarFieldEnum]


  export const ClosureRegionCategoryScalarFieldEnum: {
    ancestor: 'ancestor',
    descendant: 'descendant',
    depth: 'depth'
  };

  export type ClosureRegionCategoryScalarFieldEnum = (typeof ClosureRegionCategoryScalarFieldEnum)[keyof typeof ClosureRegionCategoryScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const MetaViewerActiveMapScalarFieldEnum: {
    id: 'id',
    updatedAt: 'updatedAt',
    metaViewerInfoId: 'metaViewerInfoId',
    activeRenderMapId: 'activeRenderMapId',
    activeColliderMapId: 'activeColliderMapId'
  };

  export type MetaViewerActiveMapScalarFieldEnum = (typeof MetaViewerActiveMapScalarFieldEnum)[keyof typeof MetaViewerActiveMapScalarFieldEnum]


  export const MetaViewerInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    code: 'code',
    isDisable: 'isDisable',
    worldData: 'worldData',
    cafeInfoId: 'cafeInfoId'
  };

  export type MetaViewerInfoScalarFieldEnum = (typeof MetaViewerInfoScalarFieldEnum)[keyof typeof MetaViewerInfoScalarFieldEnum]


  export const MetaViewerMapScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    type: 'type',
    version: 'version',
    url: 'url',
    size: 'size',
    contentKey: 'contentKey',
    isDraco: 'isDraco',
    metaViewerInfoId: 'metaViewerInfoId'
  };

  export type MetaViewerMapScalarFieldEnum = (typeof MetaViewerMapScalarFieldEnum)[keyof typeof MetaViewerMapScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    content: 'content',
    link: 'link',
    userId: 'userId'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    description: 'description',
    isDisable: 'isDisable',
    code: 'code'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    width: 'width',
    height: 'height',
    size: 'size',
    isDisable: 'isDisable',
    isThumb: 'isThumb',
    productId: 'productId'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    code: 'code',
    description: 'description',
    price: 'price',
    originalPrice: 'originalPrice',
    stockQuantity: 'stockQuantity',
    minOrderQuantity: 'minOrderQuantity',
    isDisable: 'isDisable',
    isAvailable: 'isAvailable',
    categoryId: 'categoryId',
    cafeInfoId: 'cafeInfoId',
    productRedirectUrl: 'productRedirectUrl',
    isSignature: 'isSignature'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProxyUserScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    createdAt: 'createdAt',
    proxyUserType: 'proxyUserType',
    name: 'name',
    token: 'token',
    userId: 'userId'
  };

  export type ProxyUserScalarFieldEnum = (typeof ProxyUserScalarFieldEnum)[keyof typeof ProxyUserScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RegionCategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    isDisable: 'isDisable',
    govermentType: 'govermentType'
  };

  export type RegionCategoryScalarFieldEnum = (typeof RegionCategoryScalarFieldEnum)[keyof typeof RegionCategoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    loginId: 'loginId',
    loginPw: 'loginPw',
    username: 'username',
    loginType: 'loginType',
    userType: 'userType',
    nickname: 'nickname',
    email: 'email',
    isDisable: 'isDisable'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WishlistProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    productId: 'productId',
    proxyUserId: 'proxyUserId'
  };

  export type WishlistProductScalarFieldEnum = (typeof WishlistProductScalarFieldEnum)[keyof typeof WishlistProductScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    loginId?: StringFilter | string
    loginPw?: StringNullableFilter | string | null
    username?: StringFilter | string
    loginType?: EnumLoginTypeFilter | LoginType
    userType?: EnumUserTypeFilter | UserType
    nickname?: StringFilter | string
    email?: StringFilter | string
    isDisable?: BoolFilter | boolean
    Boards?: BoardListRelationFilter
    BoardReplies?: BoardReplyListRelationFilter
    Notices?: NoticeListRelationFilter
    ProxyUsers?: ProxyUserListRelationFilter
    CafeCouponHistories?: CafeCouponHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
    Boards?: BoardOrderByRelationAggregateInput
    BoardReplies?: BoardReplyOrderByRelationAggregateInput
    Notices?: NoticeOrderByRelationAggregateInput
    ProxyUsers?: ProxyUserOrderByRelationAggregateInput
    CafeCouponHistories?: CafeCouponHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    loginUnique?: UserLoginUniqueCompoundUniqueInput
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    loginId?: StringWithAggregatesFilter | string
    loginPw?: StringNullableWithAggregatesFilter | string | null
    username?: StringWithAggregatesFilter | string
    loginType?: EnumLoginTypeWithAggregatesFilter | LoginType
    userType?: EnumUserTypeWithAggregatesFilter | UserType
    nickname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    isDisable?: BoolWithAggregatesFilter | boolean
  }

  export type NoticeWhereInput = {
    AND?: Enumerable<NoticeWhereInput>
    OR?: Enumerable<NoticeWhereInput>
    NOT?: Enumerable<NoticeWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    userId?: IntFilter | number
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type NoticeWhereUniqueInput = {
    id?: number
  }

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    OR?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    link?: StringNullableWithAggregatesFilter | string | null
    userId?: IntWithAggregatesFilter | number
  }

  export type BoardWhereInput = {
    AND?: Enumerable<BoardWhereInput>
    OR?: Enumerable<BoardWhereInput>
    NOT?: Enumerable<BoardWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    startDay?: DateTimeFilter | Date | string
    endDay?: DateTimeNullableFilter | Date | string | null
    isDisable?: BoolFilter | boolean
    isReplyAvaliable?: BoolFilter | boolean
    BoardImages?: BoardImageListRelationFilter
    BoardReplies?: BoardReplyListRelationFilter
    userId?: IntFilter | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    boardType?: EnumBoardTypeFilter | BoardType
    CafeBoards?: CafeBoardListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    BoardImages?: BoardImageOrderByRelationAggregateInput
    BoardReplies?: BoardReplyOrderByRelationAggregateInput
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
    boardType?: SortOrder
    CafeBoards?: CafeBoardOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = {
    id?: number
  }

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _avg?: BoardAvgOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
    _sum?: BoardSumOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    link?: StringNullableWithAggregatesFilter | string | null
    startDay?: DateTimeWithAggregatesFilter | Date | string
    endDay?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDisable?: BoolWithAggregatesFilter | boolean
    isReplyAvaliable?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
    boardType?: EnumBoardTypeWithAggregatesFilter | BoardType
  }

  export type BoardImageWhereInput = {
    AND?: Enumerable<BoardImageWhereInput>
    OR?: Enumerable<BoardImageWhereInput>
    NOT?: Enumerable<BoardImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    thumbnailUrl?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    isThumb?: BoolFilter | boolean
    isDisable?: BoolFilter | boolean
    boardId?: IntFilter | number
    Board?: XOR<BoardRelationFilter, BoardWhereInput>
  }

  export type BoardImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
    Board?: BoardOrderByWithRelationInput
  }

  export type BoardImageWhereUniqueInput = {
    id?: number
  }

  export type BoardImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
    _count?: BoardImageCountOrderByAggregateInput
    _avg?: BoardImageAvgOrderByAggregateInput
    _max?: BoardImageMaxOrderByAggregateInput
    _min?: BoardImageMinOrderByAggregateInput
    _sum?: BoardImageSumOrderByAggregateInput
  }

  export type BoardImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    thumbnailUrl?: StringWithAggregatesFilter | string
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    isThumb?: BoolWithAggregatesFilter | boolean
    isDisable?: BoolWithAggregatesFilter | boolean
    boardId?: IntWithAggregatesFilter | number
  }

  export type BoardReplyWhereInput = {
    AND?: Enumerable<BoardReplyWhereInput>
    OR?: Enumerable<BoardReplyWhereInput>
    NOT?: Enumerable<BoardReplyWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    content?: StringFilter | string
    isDisable?: BoolFilter | boolean
    userId?: IntFilter | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    boardId?: IntFilter | number
    Board?: XOR<BoardRelationFilter, BoardWhereInput>
    boardReplyId?: IntNullableFilter | number | null
    BoardReply?: XOR<BoardReplyRelationFilter, BoardReplyWhereInput> | null
    BoardNestedReplies?: BoardReplyListRelationFilter
  }

  export type BoardReplyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
    boardId?: SortOrder
    Board?: BoardOrderByWithRelationInput
    boardReplyId?: SortOrder
    BoardReply?: BoardReplyOrderByWithRelationInput
    BoardNestedReplies?: BoardReplyOrderByRelationAggregateInput
  }

  export type BoardReplyWhereUniqueInput = {
    id?: number
  }

  export type BoardReplyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
    _count?: BoardReplyCountOrderByAggregateInput
    _avg?: BoardReplyAvgOrderByAggregateInput
    _max?: BoardReplyMaxOrderByAggregateInput
    _min?: BoardReplyMinOrderByAggregateInput
    _sum?: BoardReplySumOrderByAggregateInput
  }

  export type BoardReplyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardReplyScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardReplyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardReplyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    content?: StringWithAggregatesFilter | string
    isDisable?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
    boardId?: IntWithAggregatesFilter | number
    boardReplyId?: IntNullableWithAggregatesFilter | number | null
  }

  export type CafeBoardWhereInput = {
    AND?: Enumerable<CafeBoardWhereInput>
    OR?: Enumerable<CafeBoardWhereInput>
    NOT?: Enumerable<CafeBoardWhereInput>
    boardId?: IntFilter | number
    cafeInfoId?: IntFilter | number
    Board?: XOR<BoardRelationFilter, BoardWhereInput>
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
    createdAt?: DateTimeFilter | Date | string
  }

  export type CafeBoardOrderByWithRelationInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    Board?: BoardOrderByWithRelationInput
    CafeInfo?: CafeInfoOrderByWithRelationInput
    createdAt?: SortOrder
  }

  export type CafeBoardWhereUniqueInput = {
    cafeBoardUnique?: CafeBoardCafeBoardUniqueCompoundUniqueInput
  }

  export type CafeBoardOrderByWithAggregationInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
    _count?: CafeBoardCountOrderByAggregateInput
    _avg?: CafeBoardAvgOrderByAggregateInput
    _max?: CafeBoardMaxOrderByAggregateInput
    _min?: CafeBoardMinOrderByAggregateInput
    _sum?: CafeBoardSumOrderByAggregateInput
  }

  export type CafeBoardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeBoardScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeBoardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeBoardScalarWhereWithAggregatesInput>
    boardId?: IntWithAggregatesFilter | number
    cafeInfoId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RegionCategoryWhereInput = {
    AND?: Enumerable<RegionCategoryWhereInput>
    OR?: Enumerable<RegionCategoryWhereInput>
    NOT?: Enumerable<RegionCategoryWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    isDisable?: BoolFilter | boolean
    govermentType?: EnumGovermentTypeFilter | GovermentType
    CafeInfos?: CafeInfoListRelationFilter
    AncestorCategories?: ClosureRegionCategoryListRelationFilter
    DescendantCategories?: ClosureRegionCategoryListRelationFilter
  }

  export type RegionCategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
    CafeInfos?: CafeInfoOrderByRelationAggregateInput
    AncestorCategories?: ClosureRegionCategoryOrderByRelationAggregateInput
    DescendantCategories?: ClosureRegionCategoryOrderByRelationAggregateInput
  }

  export type RegionCategoryWhereUniqueInput = {
    id?: number
  }

  export type RegionCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
    _count?: RegionCategoryCountOrderByAggregateInput
    _avg?: RegionCategoryAvgOrderByAggregateInput
    _max?: RegionCategoryMaxOrderByAggregateInput
    _min?: RegionCategoryMinOrderByAggregateInput
    _sum?: RegionCategorySumOrderByAggregateInput
  }

  export type RegionCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegionCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegionCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegionCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    isDisable?: BoolWithAggregatesFilter | boolean
    govermentType?: EnumGovermentTypeWithAggregatesFilter | GovermentType
  }

  export type ClosureRegionCategoryWhereInput = {
    AND?: Enumerable<ClosureRegionCategoryWhereInput>
    OR?: Enumerable<ClosureRegionCategoryWhereInput>
    NOT?: Enumerable<ClosureRegionCategoryWhereInput>
    ancestor?: IntFilter | number
    descendant?: IntFilter | number
    depth?: IntFilter | number
    AncestorCategory?: XOR<RegionCategoryRelationFilter, RegionCategoryWhereInput>
    DescendantCategory?: XOR<RegionCategoryRelationFilter, RegionCategoryWhereInput>
  }

  export type ClosureRegionCategoryOrderByWithRelationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    AncestorCategory?: RegionCategoryOrderByWithRelationInput
    DescendantCategory?: RegionCategoryOrderByWithRelationInput
  }

  export type ClosureRegionCategoryWhereUniqueInput = {
    regionCategoryTreeUnique?: ClosureRegionCategoryRegionCategoryTreeUniqueCompoundUniqueInput
  }

  export type ClosureRegionCategoryOrderByWithAggregationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    _count?: ClosureRegionCategoryCountOrderByAggregateInput
    _avg?: ClosureRegionCategoryAvgOrderByAggregateInput
    _max?: ClosureRegionCategoryMaxOrderByAggregateInput
    _min?: ClosureRegionCategoryMinOrderByAggregateInput
    _sum?: ClosureRegionCategorySumOrderByAggregateInput
  }

  export type ClosureRegionCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClosureRegionCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClosureRegionCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClosureRegionCategoryScalarWhereWithAggregatesInput>
    ancestor?: IntWithAggregatesFilter | number
    descendant?: IntWithAggregatesFilter | number
    depth?: IntWithAggregatesFilter | number
  }

  export type CafeInfoWhereInput = {
    AND?: Enumerable<CafeInfoWhereInput>
    OR?: Enumerable<CafeInfoWhereInput>
    NOT?: Enumerable<CafeInfoWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDisable?: BoolFilter | boolean
    name?: StringFilter | string
    code?: StringNullableFilter | string | null
    regionCategoryId?: IntFilter | number
    RegionCategory?: XOR<RegionCategoryRelationFilter, RegionCategoryWhereInput>
    address?: StringFilter | string
    directions?: StringFilter | string
    businessNumber?: StringFilter | string
    ceoName?: StringFilter | string
    CafeVirtualLinks?: CafeVirtualLinkListRelationFilter
    CafeThumbnailImages?: CafeThumbnailImageListRelationFilter
    CafeVirtualImages?: CafeVirtualImageListRelationFilter
    CafeRealImages?: CafeRealImageListRelationFilter
    CafeCouponGroupPartners?: CafeCouponGoupPartnerListRelationFilter
    CafeBoards?: CafeBoardListRelationFilter
    MetaViewerInfos?: MetaViewerInfoListRelationFilter
    Products?: ProductListRelationFilter
  }

  export type CafeInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    RegionCategory?: RegionCategoryOrderByWithRelationInput
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
    CafeVirtualLinks?: CafeVirtualLinkOrderByRelationAggregateInput
    CafeThumbnailImages?: CafeThumbnailImageOrderByRelationAggregateInput
    CafeVirtualImages?: CafeVirtualImageOrderByRelationAggregateInput
    CafeRealImages?: CafeRealImageOrderByRelationAggregateInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerOrderByRelationAggregateInput
    CafeBoards?: CafeBoardOrderByRelationAggregateInput
    MetaViewerInfos?: MetaViewerInfoOrderByRelationAggregateInput
    Products?: ProductOrderByRelationAggregateInput
  }

  export type CafeInfoWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type CafeInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
    _count?: CafeInfoCountOrderByAggregateInput
    _avg?: CafeInfoAvgOrderByAggregateInput
    _max?: CafeInfoMaxOrderByAggregateInput
    _min?: CafeInfoMinOrderByAggregateInput
    _sum?: CafeInfoSumOrderByAggregateInput
  }

  export type CafeInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeInfoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDisable?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    code?: StringNullableWithAggregatesFilter | string | null
    regionCategoryId?: IntWithAggregatesFilter | number
    address?: StringWithAggregatesFilter | string
    directions?: StringWithAggregatesFilter | string
    businessNumber?: StringWithAggregatesFilter | string
    ceoName?: StringWithAggregatesFilter | string
  }

  export type CafeThumbnailImageWhereInput = {
    AND?: Enumerable<CafeThumbnailImageWhereInput>
    OR?: Enumerable<CafeThumbnailImageWhereInput>
    NOT?: Enumerable<CafeThumbnailImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    thumbnailUrl?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    priority?: IntFilter | number
    isDisable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
  }

  export type CafeThumbnailImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeThumbnailImageWhereUniqueInput = {
    id?: number
  }

  export type CafeThumbnailImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeThumbnailImageCountOrderByAggregateInput
    _avg?: CafeThumbnailImageAvgOrderByAggregateInput
    _max?: CafeThumbnailImageMaxOrderByAggregateInput
    _min?: CafeThumbnailImageMinOrderByAggregateInput
    _sum?: CafeThumbnailImageSumOrderByAggregateInput
  }

  export type CafeThumbnailImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeThumbnailImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeThumbnailImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeThumbnailImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    thumbnailUrl?: StringWithAggregatesFilter | string
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    priority?: IntWithAggregatesFilter | number
    isDisable?: BoolWithAggregatesFilter | boolean
    cafeInfoId?: IntWithAggregatesFilter | number
  }

  export type CafeVirtualImageWhereInput = {
    AND?: Enumerable<CafeVirtualImageWhereInput>
    OR?: Enumerable<CafeVirtualImageWhereInput>
    NOT?: Enumerable<CafeVirtualImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    priority?: IntFilter | number
    isDisable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
  }

  export type CafeVirtualImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeVirtualImageWhereUniqueInput = {
    id?: number
  }

  export type CafeVirtualImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeVirtualImageCountOrderByAggregateInput
    _avg?: CafeVirtualImageAvgOrderByAggregateInput
    _max?: CafeVirtualImageMaxOrderByAggregateInput
    _min?: CafeVirtualImageMinOrderByAggregateInput
    _sum?: CafeVirtualImageSumOrderByAggregateInput
  }

  export type CafeVirtualImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeVirtualImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeVirtualImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeVirtualImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    priority?: IntWithAggregatesFilter | number
    isDisable?: BoolWithAggregatesFilter | boolean
    cafeInfoId?: IntWithAggregatesFilter | number
  }

  export type CafeRealImageWhereInput = {
    AND?: Enumerable<CafeRealImageWhereInput>
    OR?: Enumerable<CafeRealImageWhereInput>
    NOT?: Enumerable<CafeRealImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    priority?: IntFilter | number
    isDisable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
  }

  export type CafeRealImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeRealImageWhereUniqueInput = {
    id?: number
  }

  export type CafeRealImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeRealImageCountOrderByAggregateInput
    _avg?: CafeRealImageAvgOrderByAggregateInput
    _max?: CafeRealImageMaxOrderByAggregateInput
    _min?: CafeRealImageMinOrderByAggregateInput
    _sum?: CafeRealImageSumOrderByAggregateInput
  }

  export type CafeRealImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeRealImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeRealImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeRealImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    priority?: IntWithAggregatesFilter | number
    isDisable?: BoolWithAggregatesFilter | boolean
    cafeInfoId?: IntWithAggregatesFilter | number
  }

  export type CafeVirtualLinkWhereInput = {
    AND?: Enumerable<CafeVirtualLinkWhereInput>
    OR?: Enumerable<CafeVirtualLinkWhereInput>
    NOT?: Enumerable<CafeVirtualLinkWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    url?: StringFilter | string
    type?: StringFilter | string
    isDisable?: BoolFilter | boolean
    isAvaliable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
    CafeVirtualLinkThumbnailImage?: XOR<CafeVirtualLinkThumbnailImageRelationFilter, CafeVirtualLinkThumbnailImageWhereInput> | null
  }

  export type CafeVirtualLinkOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageOrderByWithRelationInput
  }

  export type CafeVirtualLinkWhereUniqueInput = {
    id?: number
  }

  export type CafeVirtualLinkOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeVirtualLinkCountOrderByAggregateInput
    _avg?: CafeVirtualLinkAvgOrderByAggregateInput
    _max?: CafeVirtualLinkMaxOrderByAggregateInput
    _min?: CafeVirtualLinkMinOrderByAggregateInput
    _sum?: CafeVirtualLinkSumOrderByAggregateInput
  }

  export type CafeVirtualLinkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeVirtualLinkScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeVirtualLinkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeVirtualLinkScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    isDisable?: BoolWithAggregatesFilter | boolean
    isAvaliable?: BoolWithAggregatesFilter | boolean
    cafeInfoId?: IntWithAggregatesFilter | number
  }

  export type CafeVirtualLinkThumbnailImageWhereInput = {
    AND?: Enumerable<CafeVirtualLinkThumbnailImageWhereInput>
    OR?: Enumerable<CafeVirtualLinkThumbnailImageWhereInput>
    NOT?: Enumerable<CafeVirtualLinkThumbnailImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    cafeVirtualLinkId?: IntFilter | number
    CafeVirtualLink?: XOR<CafeVirtualLinkRelationFilter, CafeVirtualLinkWhereInput>
  }

  export type CafeVirtualLinkThumbnailImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
    CafeVirtualLink?: CafeVirtualLinkOrderByWithRelationInput
  }

  export type CafeVirtualLinkThumbnailImageWhereUniqueInput = {
    id?: number
    cafeVirtualLinkId?: number
  }

  export type CafeVirtualLinkThumbnailImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
    _count?: CafeVirtualLinkThumbnailImageCountOrderByAggregateInput
    _avg?: CafeVirtualLinkThumbnailImageAvgOrderByAggregateInput
    _max?: CafeVirtualLinkThumbnailImageMaxOrderByAggregateInput
    _min?: CafeVirtualLinkThumbnailImageMinOrderByAggregateInput
    _sum?: CafeVirtualLinkThumbnailImageSumOrderByAggregateInput
  }

  export type CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    cafeVirtualLinkId?: IntWithAggregatesFilter | number
  }

  export type CafeCouponGroupWhereInput = {
    AND?: Enumerable<CafeCouponGroupWhereInput>
    OR?: Enumerable<CafeCouponGroupWhereInput>
    NOT?: Enumerable<CafeCouponGroupWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    code?: StringFilter | string
    name?: StringFilter | string
    tag?: StringFilter | string
    description?: StringFilter | string
    isDisable?: BoolFilter | boolean
    startDay?: DateTimeFilter | Date | string
    endDay?: DateTimeFilter | Date | string
    issuanceStartDay?: DateTimeFilter | Date | string
    issuanceEndDay?: DateTimeFilter | Date | string
    CafeCoupons?: CafeCouponListRelationFilter
    CafeCouponGoupPartners?: CafeCouponGoupPartnerListRelationFilter
  }

  export type CafeCouponGroupOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
    CafeCoupons?: CafeCouponOrderByRelationAggregateInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerOrderByRelationAggregateInput
  }

  export type CafeCouponGroupWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type CafeCouponGroupOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
    _count?: CafeCouponGroupCountOrderByAggregateInput
    _avg?: CafeCouponGroupAvgOrderByAggregateInput
    _max?: CafeCouponGroupMaxOrderByAggregateInput
    _min?: CafeCouponGroupMinOrderByAggregateInput
    _sum?: CafeCouponGroupSumOrderByAggregateInput
  }

  export type CafeCouponGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeCouponGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeCouponGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeCouponGroupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    tag?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isDisable?: BoolWithAggregatesFilter | boolean
    startDay?: DateTimeWithAggregatesFilter | Date | string
    endDay?: DateTimeWithAggregatesFilter | Date | string
    issuanceStartDay?: DateTimeWithAggregatesFilter | Date | string
    issuanceEndDay?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CafeCouponGoupPartnerWhereInput = {
    AND?: Enumerable<CafeCouponGoupPartnerWhereInput>
    OR?: Enumerable<CafeCouponGoupPartnerWhereInput>
    NOT?: Enumerable<CafeCouponGoupPartnerWhereInput>
    cafeCouponGroupId?: IntFilter | number
    CafeCouponGroup?: XOR<CafeCouponGroupRelationFilter, CafeCouponGroupWhereInput>
    cafeInfoId?: IntFilter | number
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
  }

  export type CafeCouponGoupPartnerOrderByWithRelationInput = {
    cafeCouponGroupId?: SortOrder
    CafeCouponGroup?: CafeCouponGroupOrderByWithRelationInput
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeCouponGoupPartnerWhereUniqueInput = {
    cafeCouponGroupPartnerUnique?: CafeCouponGoupPartnerCafeCouponGroupPartnerUniqueCompoundUniqueInput
  }

  export type CafeCouponGoupPartnerOrderByWithAggregationInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeCouponGoupPartnerCountOrderByAggregateInput
    _avg?: CafeCouponGoupPartnerAvgOrderByAggregateInput
    _max?: CafeCouponGoupPartnerMaxOrderByAggregateInput
    _min?: CafeCouponGoupPartnerMinOrderByAggregateInput
    _sum?: CafeCouponGoupPartnerSumOrderByAggregateInput
  }

  export type CafeCouponGoupPartnerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeCouponGoupPartnerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeCouponGoupPartnerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeCouponGoupPartnerScalarWhereWithAggregatesInput>
    cafeCouponGroupId?: IntWithAggregatesFilter | number
    cafeInfoId?: IntWithAggregatesFilter | number
  }

  export type ProxyUserWhereInput = {
    AND?: Enumerable<ProxyUserWhereInput>
    OR?: Enumerable<ProxyUserWhereInput>
    NOT?: Enumerable<ProxyUserWhereInput>
    id?: IntFilter | number
    memberId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    proxyUserType?: EnumProxyUserTypeFilter | ProxyUserType
    name?: StringFilter | string
    token?: StringFilter | string
    userId?: IntNullableFilter | number | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    CafeCoupons?: CafeCouponListRelationFilter
    WishlistProducts?: WishlistProductListRelationFilter
  }

  export type ProxyUserOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
    CafeCoupons?: CafeCouponOrderByRelationAggregateInput
    WishlistProducts?: WishlistProductOrderByRelationAggregateInput
  }

  export type ProxyUserWhereUniqueInput = {
    id?: number
    proxyUserUnique?: ProxyUserProxyUserUniqueCompoundUniqueInput
  }

  export type ProxyUserOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    _count?: ProxyUserCountOrderByAggregateInput
    _avg?: ProxyUserAvgOrderByAggregateInput
    _max?: ProxyUserMaxOrderByAggregateInput
    _min?: ProxyUserMinOrderByAggregateInput
    _sum?: ProxyUserSumOrderByAggregateInput
  }

  export type ProxyUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProxyUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProxyUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProxyUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    memberId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    proxyUserType?: EnumProxyUserTypeWithAggregatesFilter | ProxyUserType
    name?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    userId?: IntNullableWithAggregatesFilter | number | null
  }

  export type CafeCouponWhereInput = {
    AND?: Enumerable<CafeCouponWhereInput>
    OR?: Enumerable<CafeCouponWhereInput>
    NOT?: Enumerable<CafeCouponWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    content?: StringFilter | string
    serialNumber?: StringFilter | string
    startDay?: DateTimeFilter | Date | string
    endDay?: DateTimeNullableFilter | Date | string | null
    isDisable?: BoolFilter | boolean
    proxyUserId?: IntFilter | number
    ProxyUser?: XOR<ProxyUserRelationFilter, ProxyUserWhereInput>
    cafeCouponGroupId?: IntFilter | number
    CafeCouponGroup?: XOR<CafeCouponGroupRelationFilter, CafeCouponGroupWhereInput>
    CafeCouponQRCodes?: CafeCouponQRCodeListRelationFilter
    CafeCouponHistories?: CafeCouponHistoryListRelationFilter
  }

  export type CafeCouponOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    ProxyUser?: ProxyUserOrderByWithRelationInput
    cafeCouponGroupId?: SortOrder
    CafeCouponGroup?: CafeCouponGroupOrderByWithRelationInput
    CafeCouponQRCodes?: CafeCouponQRCodeOrderByRelationAggregateInput
    CafeCouponHistories?: CafeCouponHistoryOrderByRelationAggregateInput
  }

  export type CafeCouponWhereUniqueInput = {
    id?: number
    serialNumber?: string
  }

  export type CafeCouponOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
    _count?: CafeCouponCountOrderByAggregateInput
    _avg?: CafeCouponAvgOrderByAggregateInput
    _max?: CafeCouponMaxOrderByAggregateInput
    _min?: CafeCouponMinOrderByAggregateInput
    _sum?: CafeCouponSumOrderByAggregateInput
  }

  export type CafeCouponScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeCouponScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeCouponScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeCouponScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    serialNumber?: StringWithAggregatesFilter | string
    startDay?: DateTimeWithAggregatesFilter | Date | string
    endDay?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDisable?: BoolWithAggregatesFilter | boolean
    proxyUserId?: IntWithAggregatesFilter | number
    cafeCouponGroupId?: IntWithAggregatesFilter | number
  }

  export type CafeCouponHistoryWhereInput = {
    AND?: Enumerable<CafeCouponHistoryWhereInput>
    OR?: Enumerable<CafeCouponHistoryWhereInput>
    NOT?: Enumerable<CafeCouponHistoryWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    cafeCouponId?: IntFilter | number
    CafeCoupon?: XOR<CafeCouponRelationFilter, CafeCouponWhereInput>
    eventType?: EnumCafeCouponEventTypeFilter | CafeCouponEventType
    description?: StringFilter | string
    actorId?: IntFilter | number
    Actor?: XOR<UserRelationFilter, UserWhereInput>
    statusBefore?: EnumCafeCouponStatusNullableFilter | CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableFilter | CafeCouponStatus | null
  }

  export type CafeCouponHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    CafeCoupon?: CafeCouponOrderByWithRelationInput
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    Actor?: UserOrderByWithRelationInput
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistoryWhereUniqueInput = {
    id?: number
  }

  export type CafeCouponHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
    _count?: CafeCouponHistoryCountOrderByAggregateInput
    _avg?: CafeCouponHistoryAvgOrderByAggregateInput
    _max?: CafeCouponHistoryMaxOrderByAggregateInput
    _min?: CafeCouponHistoryMinOrderByAggregateInput
    _sum?: CafeCouponHistorySumOrderByAggregateInput
  }

  export type CafeCouponHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeCouponHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeCouponHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeCouponHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    cafeCouponId?: IntWithAggregatesFilter | number
    eventType?: EnumCafeCouponEventTypeWithAggregatesFilter | CafeCouponEventType
    description?: StringWithAggregatesFilter | string
    actorId?: IntWithAggregatesFilter | number
    statusBefore?: EnumCafeCouponStatusNullableWithAggregatesFilter | CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableWithAggregatesFilter | CafeCouponStatus | null
  }

  export type CafeCouponQRCodeWhereInput = {
    AND?: Enumerable<CafeCouponQRCodeWhereInput>
    OR?: Enumerable<CafeCouponQRCodeWhereInput>
    NOT?: Enumerable<CafeCouponQRCodeWhereInput>
    serialNumber?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDisable?: BoolFilter | boolean
    cafeCouponId?: IntNullableFilter | number | null
    CafeCoupon?: XOR<CafeCouponRelationFilter, CafeCouponWhereInput> | null
    size?: IntFilter | number
    base64Data?: StringFilter | string
  }

  export type CafeCouponQRCodeOrderByWithRelationInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    CafeCoupon?: CafeCouponOrderByWithRelationInput
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeWhereUniqueInput = {
    serialNumber?: string
  }

  export type CafeCouponQRCodeOrderByWithAggregationInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
    _count?: CafeCouponQRCodeCountOrderByAggregateInput
    _avg?: CafeCouponQRCodeAvgOrderByAggregateInput
    _max?: CafeCouponQRCodeMaxOrderByAggregateInput
    _min?: CafeCouponQRCodeMinOrderByAggregateInput
    _sum?: CafeCouponQRCodeSumOrderByAggregateInput
  }

  export type CafeCouponQRCodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CafeCouponQRCodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<CafeCouponQRCodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CafeCouponQRCodeScalarWhereWithAggregatesInput>
    serialNumber?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isDisable?: BoolWithAggregatesFilter | boolean
    cafeCouponId?: IntNullableWithAggregatesFilter | number | null
    size?: IntWithAggregatesFilter | number
    base64Data?: StringWithAggregatesFilter | string
  }

  export type MetaViewerInfoWhereInput = {
    AND?: Enumerable<MetaViewerInfoWhereInput>
    OR?: Enumerable<MetaViewerInfoWhereInput>
    NOT?: Enumerable<MetaViewerInfoWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    code?: StringFilter | string
    isDisable?: BoolFilter | boolean
    worldData?: JsonFilter
    cafeInfoId?: IntFilter | number
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput>
    MetaViewerMaps?: MetaViewerMapListRelationFilter
    ActiveMaps?: XOR<MetaViewerActiveMapRelationFilter, MetaViewerActiveMapWhereInput> | null
  }

  export type MetaViewerInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    worldData?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
    MetaViewerMaps?: MetaViewerMapOrderByRelationAggregateInput
    ActiveMaps?: MetaViewerActiveMapOrderByWithRelationInput
  }

  export type MetaViewerInfoWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type MetaViewerInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    worldData?: SortOrder
    cafeInfoId?: SortOrder
    _count?: MetaViewerInfoCountOrderByAggregateInput
    _avg?: MetaViewerInfoAvgOrderByAggregateInput
    _max?: MetaViewerInfoMaxOrderByAggregateInput
    _min?: MetaViewerInfoMinOrderByAggregateInput
    _sum?: MetaViewerInfoSumOrderByAggregateInput
  }

  export type MetaViewerInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MetaViewerInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<MetaViewerInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MetaViewerInfoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    code?: StringWithAggregatesFilter | string
    isDisable?: BoolWithAggregatesFilter | boolean
    worldData?: JsonWithAggregatesFilter
    cafeInfoId?: IntWithAggregatesFilter | number
  }

  export type MetaViewerMapWhereInput = {
    AND?: Enumerable<MetaViewerMapWhereInput>
    OR?: Enumerable<MetaViewerMapWhereInput>
    NOT?: Enumerable<MetaViewerMapWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    type?: EnumMetaMapTypeFilter | MetaMapType
    version?: FloatFilter | number
    url?: StringFilter | string
    size?: IntFilter | number
    contentKey?: StringNullableFilter | string | null
    isDraco?: BoolFilter | boolean
    metaViewerInfoId?: IntFilter | number
    MetaViewerInfo?: XOR<MetaViewerInfoRelationFilter, MetaViewerInfoWhereInput>
    ActiveRenderFor?: MetaViewerActiveMapListRelationFilter
    ActiveColliderFor?: MetaViewerActiveMapListRelationFilter
  }

  export type MetaViewerMapOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
    MetaViewerInfo?: MetaViewerInfoOrderByWithRelationInput
    ActiveRenderFor?: MetaViewerActiveMapOrderByRelationAggregateInput
    ActiveColliderFor?: MetaViewerActiveMapOrderByRelationAggregateInput
  }

  export type MetaViewerMapWhereUniqueInput = {
    id?: number
  }

  export type MetaViewerMapOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
    _count?: MetaViewerMapCountOrderByAggregateInput
    _avg?: MetaViewerMapAvgOrderByAggregateInput
    _max?: MetaViewerMapMaxOrderByAggregateInput
    _min?: MetaViewerMapMinOrderByAggregateInput
    _sum?: MetaViewerMapSumOrderByAggregateInput
  }

  export type MetaViewerMapScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MetaViewerMapScalarWhereWithAggregatesInput>
    OR?: Enumerable<MetaViewerMapScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MetaViewerMapScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumMetaMapTypeWithAggregatesFilter | MetaMapType
    version?: FloatWithAggregatesFilter | number
    url?: StringWithAggregatesFilter | string
    size?: IntWithAggregatesFilter | number
    contentKey?: StringNullableWithAggregatesFilter | string | null
    isDraco?: BoolWithAggregatesFilter | boolean
    metaViewerInfoId?: IntWithAggregatesFilter | number
  }

  export type MetaViewerActiveMapWhereInput = {
    AND?: Enumerable<MetaViewerActiveMapWhereInput>
    OR?: Enumerable<MetaViewerActiveMapWhereInput>
    NOT?: Enumerable<MetaViewerActiveMapWhereInput>
    id?: IntFilter | number
    updatedAt?: DateTimeFilter | Date | string
    metaViewerInfoId?: IntFilter | number
    MetaViewerInfo?: XOR<MetaViewerInfoRelationFilter, MetaViewerInfoWhereInput>
    activeRenderMapId?: IntFilter | number
    ActiveRenderMap?: XOR<MetaViewerMapRelationFilter, MetaViewerMapWhereInput>
    activeColliderMapId?: IntFilter | number
    ActiveColliderMap?: XOR<MetaViewerMapRelationFilter, MetaViewerMapWhereInput>
  }

  export type MetaViewerActiveMapOrderByWithRelationInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    MetaViewerInfo?: MetaViewerInfoOrderByWithRelationInput
    activeRenderMapId?: SortOrder
    ActiveRenderMap?: MetaViewerMapOrderByWithRelationInput
    activeColliderMapId?: SortOrder
    ActiveColliderMap?: MetaViewerMapOrderByWithRelationInput
  }

  export type MetaViewerActiveMapWhereUniqueInput = {
    id?: number
    metaViewerInfoId?: number
  }

  export type MetaViewerActiveMapOrderByWithAggregationInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
    _count?: MetaViewerActiveMapCountOrderByAggregateInput
    _avg?: MetaViewerActiveMapAvgOrderByAggregateInput
    _max?: MetaViewerActiveMapMaxOrderByAggregateInput
    _min?: MetaViewerActiveMapMinOrderByAggregateInput
    _sum?: MetaViewerActiveMapSumOrderByAggregateInput
  }

  export type MetaViewerActiveMapScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MetaViewerActiveMapScalarWhereWithAggregatesInput>
    OR?: Enumerable<MetaViewerActiveMapScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MetaViewerActiveMapScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    metaViewerInfoId?: IntWithAggregatesFilter | number
    activeRenderMapId?: IntWithAggregatesFilter | number
    activeColliderMapId?: IntWithAggregatesFilter | number
  }

  export type ProductCategoryWhereInput = {
    AND?: Enumerable<ProductCategoryWhereInput>
    OR?: Enumerable<ProductCategoryWhereInput>
    NOT?: Enumerable<ProductCategoryWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    isDisable?: BoolFilter | boolean
    code?: StringFilter | string
    AncestorCategories?: ClosureProductCategoryListRelationFilter
    DescendantCategories?: ClosureProductCategoryListRelationFilter
    Products?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
    AncestorCategories?: ClosureProductCategoryOrderByRelationAggregateInput
    DescendantCategories?: ClosureProductCategoryOrderByRelationAggregateInput
    Products?: ProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    isDisable?: BoolWithAggregatesFilter | boolean
    code?: StringWithAggregatesFilter | string
  }

  export type ClosureProductCategoryWhereInput = {
    AND?: Enumerable<ClosureProductCategoryWhereInput>
    OR?: Enumerable<ClosureProductCategoryWhereInput>
    NOT?: Enumerable<ClosureProductCategoryWhereInput>
    ancestor?: IntFilter | number
    descendant?: IntFilter | number
    depth?: IntFilter | number
    AncestorCategory?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    DescendantCategory?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
  }

  export type ClosureProductCategoryOrderByWithRelationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    AncestorCategory?: ProductCategoryOrderByWithRelationInput
    DescendantCategory?: ProductCategoryOrderByWithRelationInput
  }

  export type ClosureProductCategoryWhereUniqueInput = {
    productCategoryTreeUnique?: ClosureProductCategoryProductCategoryTreeUniqueCompoundUniqueInput
  }

  export type ClosureProductCategoryOrderByWithAggregationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    _count?: ClosureProductCategoryCountOrderByAggregateInput
    _avg?: ClosureProductCategoryAvgOrderByAggregateInput
    _max?: ClosureProductCategoryMaxOrderByAggregateInput
    _min?: ClosureProductCategoryMinOrderByAggregateInput
    _sum?: ClosureProductCategorySumOrderByAggregateInput
  }

  export type ClosureProductCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClosureProductCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClosureProductCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClosureProductCategoryScalarWhereWithAggregatesInput>
    ancestor?: IntWithAggregatesFilter | number
    descendant?: IntWithAggregatesFilter | number
    depth?: IntWithAggregatesFilter | number
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    code?: StringFilter | string
    description?: StringNullableFilter | string | null
    price?: IntFilter | number
    originalPrice?: IntNullableFilter | number | null
    stockQuantity?: IntFilter | number
    minOrderQuantity?: IntFilter | number
    isDisable?: BoolFilter | boolean
    isAvailable?: BoolFilter | boolean
    categoryId?: IntFilter | number
    ProductCategory?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    cafeInfoId?: IntNullableFilter | number | null
    CafeInfo?: XOR<CafeInfoRelationFilter, CafeInfoWhereInput> | null
    WishlistProducts?: WishlistProductListRelationFilter
    ProductImages?: ProductImageListRelationFilter
    productRedirectUrl?: StringNullableFilter | string | null
    isSignature?: BoolFilter | boolean
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    ProductCategory?: ProductCategoryOrderByWithRelationInput
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
    WishlistProducts?: WishlistProductOrderByRelationAggregateInput
    ProductImages?: ProductImageOrderByRelationAggregateInput
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    price?: IntWithAggregatesFilter | number
    originalPrice?: IntNullableWithAggregatesFilter | number | null
    stockQuantity?: IntWithAggregatesFilter | number
    minOrderQuantity?: IntWithAggregatesFilter | number
    isDisable?: BoolWithAggregatesFilter | boolean
    isAvailable?: BoolWithAggregatesFilter | boolean
    categoryId?: IntWithAggregatesFilter | number
    cafeInfoId?: IntNullableWithAggregatesFilter | number | null
    productRedirectUrl?: StringNullableWithAggregatesFilter | string | null
    isSignature?: BoolWithAggregatesFilter | boolean
  }

  export type WishlistProductWhereInput = {
    AND?: Enumerable<WishlistProductWhereInput>
    OR?: Enumerable<WishlistProductWhereInput>
    NOT?: Enumerable<WishlistProductWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    productId?: IntFilter | number
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
    proxyUserId?: IntFilter | number
    ProxyUser?: XOR<ProxyUserRelationFilter, ProxyUserWhereInput>
  }

  export type WishlistProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    Product?: ProductOrderByWithRelationInput
    proxyUserId?: SortOrder
    ProxyUser?: ProxyUserOrderByWithRelationInput
  }

  export type WishlistProductWhereUniqueInput = {
    id?: number
    wishlistProductUnique?: WishlistProductWishlistProductUniqueCompoundUniqueInput
  }

  export type WishlistProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
    _count?: WishlistProductCountOrderByAggregateInput
    _avg?: WishlistProductAvgOrderByAggregateInput
    _max?: WishlistProductMaxOrderByAggregateInput
    _min?: WishlistProductMinOrderByAggregateInput
    _sum?: WishlistProductSumOrderByAggregateInput
  }

  export type WishlistProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WishlistProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<WishlistProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WishlistProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    productId?: IntWithAggregatesFilter | number
    proxyUserId?: IntWithAggregatesFilter | number
  }

  export type ProductImageWhereInput = {
    AND?: Enumerable<ProductImageWhereInput>
    OR?: Enumerable<ProductImageWhereInput>
    NOT?: Enumerable<ProductImageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    thumbnailUrl?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    isDisable?: BoolFilter | boolean
    isThumb?: BoolFilter | boolean
    productId?: IntFilter | number
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
    Product?: ProductOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = {
    id?: number
  }

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    thumbnailUrl?: StringWithAggregatesFilter | string
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    isDisable?: BoolWithAggregatesFilter | boolean
    isThumb?: BoolWithAggregatesFilter | boolean
    productId?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoticeCreateInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    User: UserCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    userId: number
  }

  export type NoticeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NoticeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    userId: number
  }

  export type NoticeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardCreateInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    boardType?: BoardType
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    userId: number
    boardType?: BoardType
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId: number
    boardType?: BoardType
  }

  export type BoardUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
  }

  export type BoardImageCreateInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
    Board: BoardCreateNestedOneWithoutBoardImagesInput
  }

  export type BoardImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
    boardId: number
  }

  export type BoardImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Board?: BoardUpdateOneRequiredWithoutBoardImagesNestedInput
  }

  export type BoardImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
    boardId: number
  }

  export type BoardImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardReplyCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    boardReplyId?: number | null
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    boardReplyId?: number | null
  }

  export type BoardReplyUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardReplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CafeBoardCreateInput = {
    Board: BoardCreateNestedOneWithoutCafeBoardsInput
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeBoardsInput
    createdAt?: Date | string
  }

  export type CafeBoardUncheckedCreateInput = {
    boardId: number
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type CafeBoardUpdateInput = {
    Board?: BoardUpdateOneRequiredWithoutCafeBoardsNestedInput
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeBoardsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardCreateManyInput = {
    boardId: number
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type CafeBoardUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateManyInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCategoryCreateInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    CafeInfos?: CafeInfoCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    CafeInfos?: CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    CafeInfos?: CafeInfoUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    CafeInfos?: CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
  }

  export type RegionCategoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
  }

  export type RegionCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
  }

  export type ClosureRegionCategoryCreateInput = {
    depth?: number
    AncestorCategory: RegionCategoryCreateNestedOneWithoutAncestorCategoriesInput
    DescendantCategory: RegionCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureRegionCategoryUncheckedCreateInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryUpdateInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: RegionCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
    DescendantCategory?: RegionCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureRegionCategoryUncheckedUpdateInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryCreateManyInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryUpdateManyMutationInput = {
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUncheckedUpdateManyInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type CafeInfoCreateInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
  }

  export type CafeInfoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
  }

  export type CafeInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
  }

  export type CafeThumbnailImageCreateInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeThumbnailImagesInput
  }

  export type CafeThumbnailImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeThumbnailImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeThumbnailImagesNestedInput
  }

  export type CafeThumbnailImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeThumbnailImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeThumbnailImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualImageCreateInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeVirtualImagesInput
  }

  export type CafeVirtualImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeVirtualImagesNestedInput
  }

  export type CafeVirtualImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeRealImageCreateInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeRealImagesInput
  }

  export type CafeRealImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeRealImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeRealImagesNestedInput
  }

  export type CafeRealImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeRealImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeRealImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkCreateInput = {
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeVirtualLinksInput
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId: number
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeVirtualLinksNestedInput
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualLinkUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageCreateInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    CafeVirtualLink: CafeVirtualLinkCreateNestedOneWithoutCafeVirtualLinkThumbnailImageInput
  }

  export type CafeVirtualLinkThumbnailImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
  }

  export type CafeVirtualLinkThumbnailImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    CafeVirtualLink?: CafeVirtualLinkUpdateOneRequiredWithoutCafeVirtualLinkThumbnailImageNestedInput
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    cafeVirtualLinkId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
  }

  export type CafeVirtualLinkThumbnailImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    cafeVirtualLinkId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGroupCreateInput = {
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponCreateNestedManyWithoutCafeCouponGroupInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutCafeCouponGroupInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUpdateManyWithoutCafeCouponGroupNestedInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupCreateManyInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
  }

  export type CafeCouponGroupUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeCouponGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeCouponGoupPartnerCreateInput = {
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponGoupPartnersInput
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeCouponGroupPartnersInput
  }

  export type CafeCouponGoupPartnerUncheckedCreateInput = {
    cafeCouponGroupId: number
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerUpdateInput = {
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponGoupPartnersNestedInput
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeCouponGroupPartnersNestedInput
  }

  export type CafeCouponGoupPartnerUncheckedUpdateInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerCreateManyInput = {
    cafeCouponGroupId: number
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerUpdateManyMutationInput = {

  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type ProxyUserCreateInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    User?: UserCreateNestedOneWithoutProxyUsersInput
    CafeCoupons?: CafeCouponCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    userId?: number | null
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUpdateInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutProxyUsersNestedInput
    CafeCoupons?: CafeCouponUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserCreateManyInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    userId?: number | null
  }

  export type ProxyUserUpdateManyMutationInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CafeCouponCreateInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
  }

  export type CafeCouponUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeCouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponHistoryCreateInput = {
    createdAt?: Date | string
    CafeCoupon: CafeCouponCreateNestedOneWithoutCafeCouponHistoriesInput
    eventType: CafeCouponEventType
    description: string
    Actor: UserCreateNestedOneWithoutCafeCouponHistoriesInput
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupon?: CafeCouponUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    Actor?: UserUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponQRCodeCreateInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    CafeCoupon?: CafeCouponCreateNestedOneWithoutCafeCouponQRCodesInput
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUncheckedCreateInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    cafeCouponId?: number | null
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeCoupon?: CafeCouponUpdateOneWithoutCafeCouponQRCodesNestedInput
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeCreateManyInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    cafeCouponId?: number | null
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUpdateManyMutationInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateManyInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type MetaViewerInfoCreateInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    CafeInfo: CafeInfoCreateNestedOneWithoutMetaViewerInfosInput
    MetaViewerMaps?: MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
    MetaViewerMaps?: MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput
    MetaViewerMaps?: MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    MetaViewerMaps?: MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
  }

  export type MetaViewerInfoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
  }

  export type MetaViewerInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerMapCreateInput = {
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput
    ActiveRenderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput
    ActiveRenderFor?: MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapCreateManyInput = {
    id?: number
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
  }

  export type MetaViewerMapUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MetaViewerMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapCreateInput = {
    updatedAt?: Date | string
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutActiveMapsInput
    ActiveRenderMap: MetaViewerMapCreateNestedOneWithoutActiveRenderForInput
    ActiveColliderMap: MetaViewerMapCreateNestedOneWithoutActiveColliderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapUpdateInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput
    ActiveRenderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput
    ActiveColliderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapCreateManyInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapUpdateManyMutationInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaViewerActiveMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCategoryCreateInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
  }

  export type ClosureProductCategoryCreateInput = {
    depth?: number
    AncestorCategory: ProductCategoryCreateNestedOneWithoutAncestorCategoriesInput
    DescendantCategory: ProductCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureProductCategoryUncheckedCreateInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryUpdateInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: ProductCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
    DescendantCategory?: ProductCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureProductCategoryUncheckedUpdateInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryCreateManyInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryUpdateManyMutationInput = {
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUncheckedUpdateManyInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WishlistProductCreateInput = {
    createdAt?: Date | string
    Product: ProductCreateNestedOneWithoutWishlistProductsInput
    ProxyUser: ProxyUserCreateNestedOneWithoutWishlistProductsInput
  }

  export type WishlistProductUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    productId: number
    proxyUserId: number
  }

  export type WishlistProductUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutWishlistProductsNestedInput
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutWishlistProductsNestedInput
  }

  export type WishlistProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistProductCreateManyInput = {
    id?: number
    createdAt?: Date | string
    productId: number
    proxyUserId: number
  }

  export type WishlistProductUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
    Product: ProductCreateNestedOneWithoutProductImagesInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
    productId: number
  }

  export type ProductImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    Product?: ProductUpdateOneRequiredWithoutProductImagesNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
    productId: number
  }

  export type ProductImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumLoginTypeFilter = {
    equals?: LoginType
    in?: Enumerable<LoginType>
    notIn?: Enumerable<LoginType>
    not?: NestedEnumLoginTypeFilter | LoginType
  }

  export type EnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type BoardListRelationFilter = {
    every?: BoardWhereInput
    some?: BoardWhereInput
    none?: BoardWhereInput
  }

  export type BoardReplyListRelationFilter = {
    every?: BoardReplyWhereInput
    some?: BoardReplyWhereInput
    none?: BoardReplyWhereInput
  }

  export type NoticeListRelationFilter = {
    every?: NoticeWhereInput
    some?: NoticeWhereInput
    none?: NoticeWhereInput
  }

  export type ProxyUserListRelationFilter = {
    every?: ProxyUserWhereInput
    some?: ProxyUserWhereInput
    none?: ProxyUserWhereInput
  }

  export type CafeCouponHistoryListRelationFilter = {
    every?: CafeCouponHistoryWhereInput
    some?: CafeCouponHistoryWhereInput
    none?: CafeCouponHistoryWhereInput
  }

  export type BoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginUniqueCompoundUniqueInput = {
    loginType: LoginType
    loginId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumLoginTypeWithAggregatesFilter = {
    equals?: LoginType
    in?: Enumerable<LoginType>
    notIn?: Enumerable<LoginType>
    not?: NestedEnumLoginTypeWithAggregatesFilter | LoginType
    _count?: NestedIntFilter
    _min?: NestedEnumLoginTypeFilter
    _max?: NestedEnumLoginTypeFilter
  }

  export type EnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoardImageListRelationFilter = {
    every?: BoardImageWhereInput
    some?: BoardImageWhereInput
    none?: BoardImageWhereInput
  }

  export type EnumBoardTypeFilter = {
    equals?: BoardType
    in?: Enumerable<BoardType>
    notIn?: Enumerable<BoardType>
    not?: NestedEnumBoardTypeFilter | BoardType
  }

  export type CafeBoardListRelationFilter = {
    every?: CafeBoardWhereInput
    some?: CafeBoardWhereInput
    none?: CafeBoardWhereInput
  }

  export type BoardImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeBoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
  }

  export type BoardAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
  }

  export type BoardSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumBoardTypeWithAggregatesFilter = {
    equals?: BoardType
    in?: Enumerable<BoardType>
    notIn?: Enumerable<BoardType>
    not?: NestedEnumBoardTypeWithAggregatesFilter | BoardType
    _count?: NestedIntFilter
    _min?: NestedEnumBoardTypeFilter
    _max?: NestedEnumBoardTypeFilter
  }

  export type BoardRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type BoardImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    boardId?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BoardReplyRelationFilter = {
    is?: BoardReplyWhereInput | null
    isNot?: BoardReplyWhereInput | null
  }

  export type BoardReplyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type CafeInfoRelationFilter = {
    is?: CafeInfoWhereInput
    isNot?: CafeInfoWhereInput
  }

  export type CafeBoardCafeBoardUniqueCompoundUniqueInput = {
    boardId: number
    cafeInfoId: number
  }

  export type CafeBoardCountOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
  }

  export type CafeBoardAvgOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeBoardMaxOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
  }

  export type CafeBoardMinOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
  }

  export type CafeBoardSumOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type EnumGovermentTypeFilter = {
    equals?: GovermentType
    in?: Enumerable<GovermentType>
    notIn?: Enumerable<GovermentType>
    not?: NestedEnumGovermentTypeFilter | GovermentType
  }

  export type CafeInfoListRelationFilter = {
    every?: CafeInfoWhereInput
    some?: CafeInfoWhereInput
    none?: CafeInfoWhereInput
  }

  export type ClosureRegionCategoryListRelationFilter = {
    every?: ClosureRegionCategoryWhereInput
    some?: ClosureRegionCategoryWhereInput
    none?: ClosureRegionCategoryWhereInput
  }

  export type CafeInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClosureRegionCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
  }

  export type RegionCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
  }

  export type RegionCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
  }

  export type RegionCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGovermentTypeWithAggregatesFilter = {
    equals?: GovermentType
    in?: Enumerable<GovermentType>
    notIn?: Enumerable<GovermentType>
    not?: NestedEnumGovermentTypeWithAggregatesFilter | GovermentType
    _count?: NestedIntFilter
    _min?: NestedEnumGovermentTypeFilter
    _max?: NestedEnumGovermentTypeFilter
  }

  export type RegionCategoryRelationFilter = {
    is?: RegionCategoryWhereInput
    isNot?: RegionCategoryWhereInput
  }

  export type ClosureRegionCategoryRegionCategoryTreeUniqueCompoundUniqueInput = {
    ancestor: number
    descendant: number
    depth: number
  }

  export type ClosureRegionCategoryCountOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategoryAvgOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategoryMaxOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategoryMinOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategorySumOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type CafeVirtualLinkListRelationFilter = {
    every?: CafeVirtualLinkWhereInput
    some?: CafeVirtualLinkWhereInput
    none?: CafeVirtualLinkWhereInput
  }

  export type CafeThumbnailImageListRelationFilter = {
    every?: CafeThumbnailImageWhereInput
    some?: CafeThumbnailImageWhereInput
    none?: CafeThumbnailImageWhereInput
  }

  export type CafeVirtualImageListRelationFilter = {
    every?: CafeVirtualImageWhereInput
    some?: CafeVirtualImageWhereInput
    none?: CafeVirtualImageWhereInput
  }

  export type CafeRealImageListRelationFilter = {
    every?: CafeRealImageWhereInput
    some?: CafeRealImageWhereInput
    none?: CafeRealImageWhereInput
  }

  export type CafeCouponGoupPartnerListRelationFilter = {
    every?: CafeCouponGoupPartnerWhereInput
    some?: CafeCouponGoupPartnerWhereInput
    none?: CafeCouponGoupPartnerWhereInput
  }

  export type MetaViewerInfoListRelationFilter = {
    every?: MetaViewerInfoWhereInput
    some?: MetaViewerInfoWhereInput
    none?: MetaViewerInfoWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CafeVirtualLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeThumbnailImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeVirtualImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeRealImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponGoupPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaViewerInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
  }

  export type CafeInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    regionCategoryId?: SortOrder
  }

  export type CafeInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
  }

  export type CafeInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
  }

  export type CafeInfoSumOrderByAggregateInput = {
    id?: SortOrder
    regionCategoryId?: SortOrder
  }

  export type CafeThumbnailImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageRelationFilter = {
    is?: CafeVirtualLinkThumbnailImageWhereInput | null
    isNot?: CafeVirtualLinkThumbnailImageWhereInput | null
  }

  export type CafeVirtualLinkCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkSumOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkRelationFilter = {
    is?: CafeVirtualLinkWhereInput
    isNot?: CafeVirtualLinkWhereInput
  }

  export type CafeVirtualLinkThumbnailImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeCouponListRelationFilter = {
    every?: CafeCouponWhereInput
    some?: CafeCouponWhereInput
    none?: CafeCouponWhereInput
  }

  export type CafeCouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponGroupCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
  }

  export type CafeCouponGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CafeCouponGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
  }

  export type CafeCouponGroupMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
  }

  export type CafeCouponGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CafeCouponGroupRelationFilter = {
    is?: CafeCouponGroupWhereInput
    isNot?: CafeCouponGroupWhereInput
  }

  export type CafeCouponGoupPartnerCafeCouponGroupPartnerUniqueCompoundUniqueInput = {
    cafeCouponGroupId: number
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerCountOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerAvgOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerMaxOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerMinOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerSumOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type EnumProxyUserTypeFilter = {
    equals?: ProxyUserType
    in?: Enumerable<ProxyUserType>
    notIn?: Enumerable<ProxyUserType>
    not?: NestedEnumProxyUserTypeFilter | ProxyUserType
  }

  export type WishlistProductListRelationFilter = {
    every?: WishlistProductWhereInput
    some?: WishlistProductWhereInput
    none?: WishlistProductWhereInput
  }

  export type WishlistProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxyUserProxyUserUniqueCompoundUniqueInput = {
    memberId: string
    proxyUserType: ProxyUserType
  }

  export type ProxyUserCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumProxyUserTypeWithAggregatesFilter = {
    equals?: ProxyUserType
    in?: Enumerable<ProxyUserType>
    notIn?: Enumerable<ProxyUserType>
    not?: NestedEnumProxyUserTypeWithAggregatesFilter | ProxyUserType
    _count?: NestedIntFilter
    _min?: NestedEnumProxyUserTypeFilter
    _max?: NestedEnumProxyUserTypeFilter
  }

  export type ProxyUserRelationFilter = {
    is?: ProxyUserWhereInput
    isNot?: ProxyUserWhereInput
  }

  export type CafeCouponQRCodeListRelationFilter = {
    every?: CafeCouponQRCodeWhereInput
    some?: CafeCouponQRCodeWhereInput
    none?: CafeCouponQRCodeWhereInput
  }

  export type CafeCouponQRCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponAvgOrderByAggregateInput = {
    id?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponSumOrderByAggregateInput = {
    id?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponRelationFilter = {
    is?: CafeCouponWhereInput | null
    isNot?: CafeCouponWhereInput | null
  }

  export type EnumCafeCouponEventTypeFilter = {
    equals?: CafeCouponEventType
    in?: Enumerable<CafeCouponEventType>
    notIn?: Enumerable<CafeCouponEventType>
    not?: NestedEnumCafeCouponEventTypeFilter | CafeCouponEventType
  }

  export type EnumCafeCouponStatusNullableFilter = {
    equals?: CafeCouponStatus | null
    in?: Enumerable<CafeCouponStatus> | null
    notIn?: Enumerable<CafeCouponStatus> | null
    not?: NestedEnumCafeCouponStatusNullableFilter | CafeCouponStatus | null
  }

  export type CafeCouponHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    cafeCouponId?: SortOrder
    actorId?: SortOrder
  }

  export type CafeCouponHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistorySumOrderByAggregateInput = {
    id?: SortOrder
    cafeCouponId?: SortOrder
    actorId?: SortOrder
  }

  export type EnumCafeCouponEventTypeWithAggregatesFilter = {
    equals?: CafeCouponEventType
    in?: Enumerable<CafeCouponEventType>
    notIn?: Enumerable<CafeCouponEventType>
    not?: NestedEnumCafeCouponEventTypeWithAggregatesFilter | CafeCouponEventType
    _count?: NestedIntFilter
    _min?: NestedEnumCafeCouponEventTypeFilter
    _max?: NestedEnumCafeCouponEventTypeFilter
  }

  export type EnumCafeCouponStatusNullableWithAggregatesFilter = {
    equals?: CafeCouponStatus | null
    in?: Enumerable<CafeCouponStatus> | null
    notIn?: Enumerable<CafeCouponStatus> | null
    not?: NestedEnumCafeCouponStatusNullableWithAggregatesFilter | CafeCouponStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCafeCouponStatusNullableFilter
    _max?: NestedEnumCafeCouponStatusNullableFilter
  }

  export type CafeCouponQRCodeCountOrderByAggregateInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeAvgOrderByAggregateInput = {
    cafeCouponId?: SortOrder
    size?: SortOrder
  }

  export type CafeCouponQRCodeMaxOrderByAggregateInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeMinOrderByAggregateInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeSumOrderByAggregateInput = {
    cafeCouponId?: SortOrder
    size?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type MetaViewerMapListRelationFilter = {
    every?: MetaViewerMapWhereInput
    some?: MetaViewerMapWhereInput
    none?: MetaViewerMapWhereInput
  }

  export type MetaViewerActiveMapRelationFilter = {
    is?: MetaViewerActiveMapWhereInput | null
    isNot?: MetaViewerActiveMapWhereInput | null
  }

  export type MetaViewerMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaViewerInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    worldData?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoSumOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type EnumMetaMapTypeFilter = {
    equals?: MetaMapType
    in?: Enumerable<MetaMapType>
    notIn?: Enumerable<MetaMapType>
    not?: NestedEnumMetaMapTypeFilter | MetaMapType
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type MetaViewerInfoRelationFilter = {
    is?: MetaViewerInfoWhereInput
    isNot?: MetaViewerInfoWhereInput
  }

  export type MetaViewerActiveMapListRelationFilter = {
    every?: MetaViewerActiveMapWhereInput
    some?: MetaViewerActiveMapWhereInput
    none?: MetaViewerActiveMapWhereInput
  }

  export type MetaViewerActiveMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaViewerMapCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapAvgOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    size?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapSumOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    size?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type EnumMetaMapTypeWithAggregatesFilter = {
    equals?: MetaMapType
    in?: Enumerable<MetaMapType>
    notIn?: Enumerable<MetaMapType>
    not?: NestedEnumMetaMapTypeWithAggregatesFilter | MetaMapType
    _count?: NestedIntFilter
    _min?: NestedEnumMetaMapTypeFilter
    _max?: NestedEnumMetaMapTypeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type MetaViewerMapRelationFilter = {
    is?: MetaViewerMapWhereInput
    isNot?: MetaViewerMapWhereInput
  }

  export type MetaViewerActiveMapCountOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapAvgOrderByAggregateInput = {
    id?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapMaxOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapMinOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapSumOrderByAggregateInput = {
    id?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type ClosureProductCategoryListRelationFilter = {
    every?: ClosureProductCategoryWhereInput
    some?: ClosureProductCategoryWhereInput
    none?: ClosureProductCategoryWhereInput
  }

  export type ClosureProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type ClosureProductCategoryProductCategoryTreeUniqueCompoundUniqueInput = {
    ancestor: number
    descendant: number
    depth: number
  }

  export type ClosureProductCategoryCountOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategoryAvgOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategoryMaxOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategoryMinOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategorySumOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type WishlistProductWishlistProductUniqueCompoundUniqueInput = {
    productId: number
    proxyUserId: number
  }

  export type WishlistProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    productId?: SortOrder
  }

  export type BoardCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BoardCreateWithoutUserInput>, Enumerable<BoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardCreateOrConnectWithoutUserInput>
    createMany?: BoardCreateManyUserInputEnvelope
    connect?: Enumerable<BoardWhereUniqueInput>
  }

  export type BoardReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutUserInput>, Enumerable<BoardReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutUserInput>
    createMany?: BoardReplyCreateManyUserInputEnvelope
    connect?: Enumerable<BoardReplyWhereUniqueInput>
  }

  export type NoticeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeCreateWithoutUserInput>, Enumerable<NoticeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeCreateOrConnectWithoutUserInput>
    createMany?: NoticeCreateManyUserInputEnvelope
    connect?: Enumerable<NoticeWhereUniqueInput>
  }

  export type ProxyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProxyUserCreateWithoutUserInput>, Enumerable<ProxyUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProxyUserCreateOrConnectWithoutUserInput>
    createMany?: ProxyUserCreateManyUserInputEnvelope
    connect?: Enumerable<ProxyUserWhereUniqueInput>
  }

  export type CafeCouponHistoryCreateNestedManyWithoutActorInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutActorInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutActorInput>
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
  }

  export type BoardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BoardCreateWithoutUserInput>, Enumerable<BoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardCreateOrConnectWithoutUserInput>
    createMany?: BoardCreateManyUserInputEnvelope
    connect?: Enumerable<BoardWhereUniqueInput>
  }

  export type BoardReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutUserInput>, Enumerable<BoardReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutUserInput>
    createMany?: BoardReplyCreateManyUserInputEnvelope
    connect?: Enumerable<BoardReplyWhereUniqueInput>
  }

  export type NoticeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NoticeCreateWithoutUserInput>, Enumerable<NoticeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeCreateOrConnectWithoutUserInput>
    createMany?: NoticeCreateManyUserInputEnvelope
    connect?: Enumerable<NoticeWhereUniqueInput>
  }

  export type ProxyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProxyUserCreateWithoutUserInput>, Enumerable<ProxyUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProxyUserCreateOrConnectWithoutUserInput>
    createMany?: ProxyUserCreateManyUserInputEnvelope
    connect?: Enumerable<ProxyUserWhereUniqueInput>
  }

  export type CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutActorInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutActorInput>
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumLoginTypeFieldUpdateOperationsInput = {
    set?: LoginType
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: UserType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BoardUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BoardCreateWithoutUserInput>, Enumerable<BoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BoardUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BoardCreateManyUserInputEnvelope
    set?: Enumerable<BoardWhereUniqueInput>
    disconnect?: Enumerable<BoardWhereUniqueInput>
    delete?: Enumerable<BoardWhereUniqueInput>
    connect?: Enumerable<BoardWhereUniqueInput>
    update?: Enumerable<BoardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BoardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BoardScalarWhereInput>
  }

  export type BoardReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutUserInput>, Enumerable<BoardReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BoardReplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BoardReplyCreateManyUserInputEnvelope
    set?: Enumerable<BoardReplyWhereUniqueInput>
    disconnect?: Enumerable<BoardReplyWhereUniqueInput>
    delete?: Enumerable<BoardReplyWhereUniqueInput>
    connect?: Enumerable<BoardReplyWhereUniqueInput>
    update?: Enumerable<BoardReplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BoardReplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BoardReplyScalarWhereInput>
  }

  export type NoticeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NoticeCreateWithoutUserInput>, Enumerable<NoticeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NoticeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NoticeCreateManyUserInputEnvelope
    set?: Enumerable<NoticeWhereUniqueInput>
    disconnect?: Enumerable<NoticeWhereUniqueInput>
    delete?: Enumerable<NoticeWhereUniqueInput>
    connect?: Enumerable<NoticeWhereUniqueInput>
    update?: Enumerable<NoticeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NoticeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NoticeScalarWhereInput>
  }

  export type ProxyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProxyUserCreateWithoutUserInput>, Enumerable<ProxyUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProxyUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProxyUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProxyUserCreateManyUserInputEnvelope
    set?: Enumerable<ProxyUserWhereUniqueInput>
    disconnect?: Enumerable<ProxyUserWhereUniqueInput>
    delete?: Enumerable<ProxyUserWhereUniqueInput>
    connect?: Enumerable<ProxyUserWhereUniqueInput>
    update?: Enumerable<ProxyUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProxyUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProxyUserScalarWhereInput>
  }

  export type CafeCouponHistoryUpdateManyWithoutActorNestedInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutActorInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutActorInput>
    upsert?: Enumerable<CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput>
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    set?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    delete?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    update?: Enumerable<CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput>
    updateMany?: Enumerable<CafeCouponHistoryUpdateManyWithWhereWithoutActorInput>
    deleteMany?: Enumerable<CafeCouponHistoryScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BoardCreateWithoutUserInput>, Enumerable<BoardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BoardUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BoardCreateManyUserInputEnvelope
    set?: Enumerable<BoardWhereUniqueInput>
    disconnect?: Enumerable<BoardWhereUniqueInput>
    delete?: Enumerable<BoardWhereUniqueInput>
    connect?: Enumerable<BoardWhereUniqueInput>
    update?: Enumerable<BoardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BoardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BoardScalarWhereInput>
  }

  export type BoardReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutUserInput>, Enumerable<BoardReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BoardReplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BoardReplyCreateManyUserInputEnvelope
    set?: Enumerable<BoardReplyWhereUniqueInput>
    disconnect?: Enumerable<BoardReplyWhereUniqueInput>
    delete?: Enumerable<BoardReplyWhereUniqueInput>
    connect?: Enumerable<BoardReplyWhereUniqueInput>
    update?: Enumerable<BoardReplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BoardReplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BoardReplyScalarWhereInput>
  }

  export type NoticeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NoticeCreateWithoutUserInput>, Enumerable<NoticeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NoticeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NoticeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NoticeCreateManyUserInputEnvelope
    set?: Enumerable<NoticeWhereUniqueInput>
    disconnect?: Enumerable<NoticeWhereUniqueInput>
    delete?: Enumerable<NoticeWhereUniqueInput>
    connect?: Enumerable<NoticeWhereUniqueInput>
    update?: Enumerable<NoticeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NoticeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NoticeScalarWhereInput>
  }

  export type ProxyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProxyUserCreateWithoutUserInput>, Enumerable<ProxyUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProxyUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProxyUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProxyUserCreateManyUserInputEnvelope
    set?: Enumerable<ProxyUserWhereUniqueInput>
    disconnect?: Enumerable<ProxyUserWhereUniqueInput>
    delete?: Enumerable<ProxyUserWhereUniqueInput>
    connect?: Enumerable<ProxyUserWhereUniqueInput>
    update?: Enumerable<ProxyUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProxyUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProxyUserScalarWhereInput>
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutActorInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutActorInput>
    upsert?: Enumerable<CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput>
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    set?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    delete?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    update?: Enumerable<CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput>
    updateMany?: Enumerable<CafeCouponHistoryUpdateManyWithWhereWithoutActorInput>
    deleteMany?: Enumerable<CafeCouponHistoryScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutNoticesInput = {
    create?: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoticesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoticesNestedInput = {
    create?: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoticesInput
    upsert?: UserUpsertWithoutNoticesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNoticesInput, UserUncheckedUpdateWithoutNoticesInput>
  }

  export type BoardImageCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardImageCreateWithoutBoardInput>, Enumerable<BoardImageUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardImageCreateOrConnectWithoutBoardInput>
    createMany?: BoardImageCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardImageWhereUniqueInput>
  }

  export type BoardReplyCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardInput>
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardReplyWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutBoardsInput = {
    create?: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardsInput
    connect?: UserWhereUniqueInput
  }

  export type CafeBoardCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutBoardInput>, Enumerable<CafeBoardUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutBoardInput>
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    connect?: Enumerable<CafeBoardWhereUniqueInput>
  }

  export type BoardImageUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardImageCreateWithoutBoardInput>, Enumerable<BoardImageUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardImageCreateOrConnectWithoutBoardInput>
    createMany?: BoardImageCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardImageWhereUniqueInput>
  }

  export type BoardReplyUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardInput>
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardReplyWhereUniqueInput>
  }

  export type CafeBoardUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutBoardInput>, Enumerable<CafeBoardUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutBoardInput>
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    connect?: Enumerable<CafeBoardWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoardImageUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardImageCreateWithoutBoardInput>, Enumerable<BoardImageUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardImageCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardImageUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardImageCreateManyBoardInputEnvelope
    set?: Enumerable<BoardImageWhereUniqueInput>
    disconnect?: Enumerable<BoardImageWhereUniqueInput>
    delete?: Enumerable<BoardImageWhereUniqueInput>
    connect?: Enumerable<BoardImageWhereUniqueInput>
    update?: Enumerable<BoardImageUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardImageUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardImageScalarWhereInput>
  }

  export type BoardReplyUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardReplyUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    set?: Enumerable<BoardReplyWhereUniqueInput>
    disconnect?: Enumerable<BoardReplyWhereUniqueInput>
    delete?: Enumerable<BoardReplyWhereUniqueInput>
    connect?: Enumerable<BoardReplyWhereUniqueInput>
    update?: Enumerable<BoardReplyUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardReplyUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardReplyScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardsInput
    upsert?: UserUpsertWithoutBoardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBoardsInput, UserUncheckedUpdateWithoutBoardsInput>
  }

  export type EnumBoardTypeFieldUpdateOperationsInput = {
    set?: BoardType
  }

  export type CafeBoardUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutBoardInput>, Enumerable<CafeBoardUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<CafeBoardUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    set?: Enumerable<CafeBoardWhereUniqueInput>
    disconnect?: Enumerable<CafeBoardWhereUniqueInput>
    delete?: Enumerable<CafeBoardWhereUniqueInput>
    connect?: Enumerable<CafeBoardWhereUniqueInput>
    update?: Enumerable<CafeBoardUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<CafeBoardUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<CafeBoardScalarWhereInput>
  }

  export type BoardImageUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardImageCreateWithoutBoardInput>, Enumerable<BoardImageUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardImageCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardImageUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardImageCreateManyBoardInputEnvelope
    set?: Enumerable<BoardImageWhereUniqueInput>
    disconnect?: Enumerable<BoardImageWhereUniqueInput>
    delete?: Enumerable<BoardImageWhereUniqueInput>
    connect?: Enumerable<BoardImageWhereUniqueInput>
    update?: Enumerable<BoardImageUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardImageUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardImageScalarWhereInput>
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardReplyUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    set?: Enumerable<BoardReplyWhereUniqueInput>
    disconnect?: Enumerable<BoardReplyWhereUniqueInput>
    delete?: Enumerable<BoardReplyWhereUniqueInput>
    connect?: Enumerable<BoardReplyWhereUniqueInput>
    update?: Enumerable<BoardReplyUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardReplyUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardReplyScalarWhereInput>
  }

  export type CafeBoardUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutBoardInput>, Enumerable<CafeBoardUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<CafeBoardUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    set?: Enumerable<CafeBoardWhereUniqueInput>
    disconnect?: Enumerable<CafeBoardWhereUniqueInput>
    delete?: Enumerable<CafeBoardWhereUniqueInput>
    connect?: Enumerable<CafeBoardWhereUniqueInput>
    update?: Enumerable<CafeBoardUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<CafeBoardUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<CafeBoardScalarWhereInput>
  }

  export type BoardCreateNestedOneWithoutBoardImagesInput = {
    create?: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardImagesInput
    connect?: BoardWhereUniqueInput
  }

  export type BoardUpdateOneRequiredWithoutBoardImagesNestedInput = {
    create?: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardImagesInput
    upsert?: BoardUpsertWithoutBoardImagesInput
    connect?: BoardWhereUniqueInput
    update?: XOR<BoardUpdateWithoutBoardImagesInput, BoardUncheckedUpdateWithoutBoardImagesInput>
  }

  export type UserCreateNestedOneWithoutBoardRepliesInput = {
    create?: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type BoardCreateNestedOneWithoutBoardRepliesInput = {
    create?: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardRepliesInput
    connect?: BoardWhereUniqueInput
  }

  export type BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput = {
    create?: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardNestedRepliesInput
    connect?: BoardReplyWhereUniqueInput
  }

  export type BoardReplyCreateNestedManyWithoutBoardReplyInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardReplyInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardReplyInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardReplyInput>
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    connect?: Enumerable<BoardReplyWhereUniqueInput>
  }

  export type BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardReplyInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardReplyInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardReplyInput>
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    connect?: Enumerable<BoardReplyWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutBoardRepliesNestedInput = {
    create?: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardRepliesInput
    upsert?: UserUpsertWithoutBoardRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBoardRepliesInput, UserUncheckedUpdateWithoutBoardRepliesInput>
  }

  export type BoardUpdateOneRequiredWithoutBoardRepliesNestedInput = {
    create?: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardRepliesInput
    upsert?: BoardUpsertWithoutBoardRepliesInput
    connect?: BoardWhereUniqueInput
    update?: XOR<BoardUpdateWithoutBoardRepliesInput, BoardUncheckedUpdateWithoutBoardRepliesInput>
  }

  export type BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput = {
    create?: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardNestedRepliesInput
    upsert?: BoardReplyUpsertWithoutBoardNestedRepliesInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoardReplyWhereUniqueInput
    update?: XOR<BoardReplyUpdateWithoutBoardNestedRepliesInput, BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput>
  }

  export type BoardReplyUpdateManyWithoutBoardReplyNestedInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardReplyInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardReplyInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardReplyInput>
    upsert?: Enumerable<BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput>
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    set?: Enumerable<BoardReplyWhereUniqueInput>
    disconnect?: Enumerable<BoardReplyWhereUniqueInput>
    delete?: Enumerable<BoardReplyWhereUniqueInput>
    connect?: Enumerable<BoardReplyWhereUniqueInput>
    update?: Enumerable<BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput>
    updateMany?: Enumerable<BoardReplyUpdateManyWithWhereWithoutBoardReplyInput>
    deleteMany?: Enumerable<BoardReplyScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput = {
    create?: XOR<Enumerable<BoardReplyCreateWithoutBoardReplyInput>, Enumerable<BoardReplyUncheckedCreateWithoutBoardReplyInput>>
    connectOrCreate?: Enumerable<BoardReplyCreateOrConnectWithoutBoardReplyInput>
    upsert?: Enumerable<BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput>
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    set?: Enumerable<BoardReplyWhereUniqueInput>
    disconnect?: Enumerable<BoardReplyWhereUniqueInput>
    delete?: Enumerable<BoardReplyWhereUniqueInput>
    connect?: Enumerable<BoardReplyWhereUniqueInput>
    update?: Enumerable<BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput>
    updateMany?: Enumerable<BoardReplyUpdateManyWithWhereWithoutBoardReplyInput>
    deleteMany?: Enumerable<BoardReplyScalarWhereInput>
  }

  export type BoardCreateNestedOneWithoutCafeBoardsInput = {
    create?: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutCafeBoardsInput
    connect?: BoardWhereUniqueInput
  }

  export type CafeInfoCreateNestedOneWithoutCafeBoardsInput = {
    create?: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeBoardsInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type BoardUpdateOneRequiredWithoutCafeBoardsNestedInput = {
    create?: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutCafeBoardsInput
    upsert?: BoardUpsertWithoutCafeBoardsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<BoardUpdateWithoutCafeBoardsInput, BoardUncheckedUpdateWithoutCafeBoardsInput>
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeBoardsNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeBoardsInput
    upsert?: CafeInfoUpsertWithoutCafeBoardsInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutCafeBoardsInput, CafeInfoUncheckedUpdateWithoutCafeBoardsInput>
  }

  export type CafeInfoCreateNestedManyWithoutRegionCategoryInput = {
    create?: XOR<Enumerable<CafeInfoCreateWithoutRegionCategoryInput>, Enumerable<CafeInfoUncheckedCreateWithoutRegionCategoryInput>>
    connectOrCreate?: Enumerable<CafeInfoCreateOrConnectWithoutRegionCategoryInput>
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    connect?: Enumerable<CafeInfoWhereUniqueInput>
  }

  export type ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
  }

  export type ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
  }

  export type CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput = {
    create?: XOR<Enumerable<CafeInfoCreateWithoutRegionCategoryInput>, Enumerable<CafeInfoUncheckedCreateWithoutRegionCategoryInput>>
    connectOrCreate?: Enumerable<CafeInfoCreateOrConnectWithoutRegionCategoryInput>
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    connect?: Enumerable<CafeInfoWhereUniqueInput>
  }

  export type ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
  }

  export type ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
  }

  export type EnumGovermentTypeFieldUpdateOperationsInput = {
    set?: GovermentType
  }

  export type CafeInfoUpdateManyWithoutRegionCategoryNestedInput = {
    create?: XOR<Enumerable<CafeInfoCreateWithoutRegionCategoryInput>, Enumerable<CafeInfoUncheckedCreateWithoutRegionCategoryInput>>
    connectOrCreate?: Enumerable<CafeInfoCreateOrConnectWithoutRegionCategoryInput>
    upsert?: Enumerable<CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput>
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    set?: Enumerable<CafeInfoWhereUniqueInput>
    disconnect?: Enumerable<CafeInfoWhereUniqueInput>
    delete?: Enumerable<CafeInfoWhereUniqueInput>
    connect?: Enumerable<CafeInfoWhereUniqueInput>
    update?: Enumerable<CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput>
    updateMany?: Enumerable<CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput>
    deleteMany?: Enumerable<CafeInfoScalarWhereInput>
  }

  export type ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput>
    upsert?: Enumerable<ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    set?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    update?: Enumerable<ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput>
    updateMany?: Enumerable<ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput>
    deleteMany?: Enumerable<ClosureRegionCategoryScalarWhereInput>
  }

  export type ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput>
    upsert?: Enumerable<ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    set?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    update?: Enumerable<ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput>
    updateMany?: Enumerable<ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput>
    deleteMany?: Enumerable<ClosureRegionCategoryScalarWhereInput>
  }

  export type CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput = {
    create?: XOR<Enumerable<CafeInfoCreateWithoutRegionCategoryInput>, Enumerable<CafeInfoUncheckedCreateWithoutRegionCategoryInput>>
    connectOrCreate?: Enumerable<CafeInfoCreateOrConnectWithoutRegionCategoryInput>
    upsert?: Enumerable<CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput>
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    set?: Enumerable<CafeInfoWhereUniqueInput>
    disconnect?: Enumerable<CafeInfoWhereUniqueInput>
    delete?: Enumerable<CafeInfoWhereUniqueInput>
    connect?: Enumerable<CafeInfoWhereUniqueInput>
    update?: Enumerable<CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput>
    updateMany?: Enumerable<CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput>
    deleteMany?: Enumerable<CafeInfoScalarWhereInput>
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput>
    upsert?: Enumerable<ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    set?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    update?: Enumerable<ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput>
    updateMany?: Enumerable<ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput>
    deleteMany?: Enumerable<ClosureRegionCategoryScalarWhereInput>
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureRegionCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput>
    upsert?: Enumerable<ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput>
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    set?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureRegionCategoryWhereUniqueInput>
    update?: Enumerable<ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput>
    updateMany?: Enumerable<ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput>
    deleteMany?: Enumerable<ClosureRegionCategoryScalarWhereInput>
  }

  export type RegionCategoryCreateNestedOneWithoutAncestorCategoriesInput = {
    create?: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutAncestorCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
  }

  export type RegionCategoryCreateNestedOneWithoutDescendantCategoriesInput = {
    create?: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutDescendantCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
  }

  export type RegionCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput = {
    create?: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutAncestorCategoriesInput
    upsert?: RegionCategoryUpsertWithoutAncestorCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
    update?: XOR<RegionCategoryUpdateWithoutAncestorCategoriesInput, RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
  }

  export type RegionCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput = {
    create?: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutDescendantCategoriesInput
    upsert?: RegionCategoryUpsertWithoutDescendantCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
    update?: XOR<RegionCategoryUpdateWithoutDescendantCategoriesInput, RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryCreateNestedOneWithoutCafeInfosInput = {
    create?: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutCafeInfosInput
    connect?: RegionCategoryWhereUniqueInput
  }

  export type CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeVirtualLinkCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeVirtualLinkWhereUniqueInput>
  }

  export type CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeThumbnailImageCreateWithoutCafeInfoInput>, Enumerable<CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeThumbnailImageWhereUniqueInput>
  }

  export type CafeVirtualImageCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeVirtualImageCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualImageCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeVirtualImageWhereUniqueInput>
  }

  export type CafeRealImageCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeRealImageCreateWithoutCafeInfoInput>, Enumerable<CafeRealImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeRealImageCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeRealImageWhereUniqueInput>
  }

  export type CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeInfoInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
  }

  export type CafeBoardCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutCafeInfoInput>, Enumerable<CafeBoardUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeBoardWhereUniqueInput>
  }

  export type MetaViewerInfoCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<MetaViewerInfoCreateWithoutCafeInfoInput>, Enumerable<MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerInfoCreateOrConnectWithoutCafeInfoInput>
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<MetaViewerInfoWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCafeInfoInput>, Enumerable<ProductUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCafeInfoInput>
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeVirtualLinkCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeVirtualLinkWhereUniqueInput>
  }

  export type CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeThumbnailImageCreateWithoutCafeInfoInput>, Enumerable<CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeThumbnailImageWhereUniqueInput>
  }

  export type CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeVirtualImageCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualImageCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeVirtualImageWhereUniqueInput>
  }

  export type CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeRealImageCreateWithoutCafeInfoInput>, Enumerable<CafeRealImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeRealImageCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeRealImageWhereUniqueInput>
  }

  export type CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeInfoInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
  }

  export type CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutCafeInfoInput>, Enumerable<CafeBoardUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutCafeInfoInput>
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<CafeBoardWhereUniqueInput>
  }

  export type MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<MetaViewerInfoCreateWithoutCafeInfoInput>, Enumerable<MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerInfoCreateOrConnectWithoutCafeInfoInput>
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<MetaViewerInfoWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCafeInfoInput>, Enumerable<ProductUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCafeInfoInput>
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput = {
    create?: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutCafeInfosInput
    upsert?: RegionCategoryUpsertWithoutCafeInfosInput
    connect?: RegionCategoryWhereUniqueInput
    update?: XOR<RegionCategoryUpdateWithoutCafeInfosInput, RegionCategoryUncheckedUpdateWithoutCafeInfosInput>
  }

  export type CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeVirtualLinkCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    disconnect?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    delete?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    connect?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    update?: Enumerable<CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeVirtualLinkScalarWhereInput>
  }

  export type CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeThumbnailImageCreateWithoutCafeInfoInput>, Enumerable<CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    disconnect?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    delete?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    connect?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    update?: Enumerable<CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeThumbnailImageScalarWhereInput>
  }

  export type CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeVirtualImageCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualImageCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeVirtualImageWhereUniqueInput>
    disconnect?: Enumerable<CafeVirtualImageWhereUniqueInput>
    delete?: Enumerable<CafeVirtualImageWhereUniqueInput>
    connect?: Enumerable<CafeVirtualImageWhereUniqueInput>
    update?: Enumerable<CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeVirtualImageScalarWhereInput>
  }

  export type CafeRealImageUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeRealImageCreateWithoutCafeInfoInput>, Enumerable<CafeRealImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeRealImageCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeRealImageWhereUniqueInput>
    disconnect?: Enumerable<CafeRealImageWhereUniqueInput>
    delete?: Enumerable<CafeRealImageWhereUniqueInput>
    connect?: Enumerable<CafeRealImageWhereUniqueInput>
    update?: Enumerable<CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeRealImageScalarWhereInput>
  }

  export type CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeInfoInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    delete?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    update?: Enumerable<CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
  }

  export type CafeBoardUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutCafeInfoInput>, Enumerable<CafeBoardUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeBoardWhereUniqueInput>
    disconnect?: Enumerable<CafeBoardWhereUniqueInput>
    delete?: Enumerable<CafeBoardWhereUniqueInput>
    connect?: Enumerable<CafeBoardWhereUniqueInput>
    update?: Enumerable<CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeBoardUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeBoardScalarWhereInput>
  }

  export type MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<MetaViewerInfoCreateWithoutCafeInfoInput>, Enumerable<MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerInfoCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    set?: Enumerable<MetaViewerInfoWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerInfoWhereUniqueInput>
    delete?: Enumerable<MetaViewerInfoWhereUniqueInput>
    connect?: Enumerable<MetaViewerInfoWhereUniqueInput>
    update?: Enumerable<MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<MetaViewerInfoScalarWhereInput>
  }

  export type ProductUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCafeInfoInput>, Enumerable<ProductUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeVirtualLinkCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    disconnect?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    delete?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    connect?: Enumerable<CafeVirtualLinkWhereUniqueInput>
    update?: Enumerable<CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeVirtualLinkScalarWhereInput>
  }

  export type CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeThumbnailImageCreateWithoutCafeInfoInput>, Enumerable<CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    disconnect?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    delete?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    connect?: Enumerable<CafeThumbnailImageWhereUniqueInput>
    update?: Enumerable<CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeThumbnailImageScalarWhereInput>
  }

  export type CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeVirtualImageCreateWithoutCafeInfoInput>, Enumerable<CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeVirtualImageCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeVirtualImageWhereUniqueInput>
    disconnect?: Enumerable<CafeVirtualImageWhereUniqueInput>
    delete?: Enumerable<CafeVirtualImageWhereUniqueInput>
    connect?: Enumerable<CafeVirtualImageWhereUniqueInput>
    update?: Enumerable<CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeVirtualImageScalarWhereInput>
  }

  export type CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeRealImageCreateWithoutCafeInfoInput>, Enumerable<CafeRealImageUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeRealImageCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeRealImageWhereUniqueInput>
    disconnect?: Enumerable<CafeRealImageWhereUniqueInput>
    delete?: Enumerable<CafeRealImageWhereUniqueInput>
    connect?: Enumerable<CafeRealImageWhereUniqueInput>
    update?: Enumerable<CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeRealImageScalarWhereInput>
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeInfoInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    delete?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    update?: Enumerable<CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
  }

  export type CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<CafeBoardCreateWithoutCafeInfoInput>, Enumerable<CafeBoardUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<CafeBoardCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    set?: Enumerable<CafeBoardWhereUniqueInput>
    disconnect?: Enumerable<CafeBoardWhereUniqueInput>
    delete?: Enumerable<CafeBoardWhereUniqueInput>
    connect?: Enumerable<CafeBoardWhereUniqueInput>
    update?: Enumerable<CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<CafeBoardUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<CafeBoardScalarWhereInput>
  }

  export type MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<MetaViewerInfoCreateWithoutCafeInfoInput>, Enumerable<MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerInfoCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    set?: Enumerable<MetaViewerInfoWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerInfoWhereUniqueInput>
    delete?: Enumerable<MetaViewerInfoWhereUniqueInput>
    connect?: Enumerable<MetaViewerInfoWhereUniqueInput>
    update?: Enumerable<MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<MetaViewerInfoScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCafeInfoInput>, Enumerable<ProductUncheckedCreateWithoutCafeInfoInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCafeInfoInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCafeInfoInput>
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCafeInfoInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCafeInfoInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeThumbnailImagesInput = {
    create?: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeThumbnailImagesInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeThumbnailImagesNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeThumbnailImagesInput
    upsert?: CafeInfoUpsertWithoutCafeThumbnailImagesInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeVirtualImagesInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualImagesInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeVirtualImagesNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualImagesInput
    upsert?: CafeInfoUpsertWithoutCafeVirtualImagesInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutCafeVirtualImagesInput, CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeRealImagesInput = {
    create?: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeRealImagesInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeRealImagesNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeRealImagesInput
    upsert?: CafeInfoUpsertWithoutCafeRealImagesInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutCafeRealImagesInput, CafeInfoUncheckedUpdateWithoutCafeRealImagesInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeVirtualLinksInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualLinksInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeVirtualLinkThumbnailImageCreateNestedOneWithoutCafeVirtualLinkInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  export type CafeVirtualLinkThumbnailImageUncheckedCreateNestedOneWithoutCafeVirtualLinkInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeVirtualLinksNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualLinksInput
    upsert?: CafeInfoUpsertWithoutCafeVirtualLinksInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutCafeVirtualLinksInput, CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput>
  }

  export type CafeVirtualLinkThumbnailImageUpdateOneWithoutCafeVirtualLinkNestedInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    upsert?: CafeVirtualLinkThumbnailImageUpsertWithoutCafeVirtualLinkInput
    disconnect?: boolean
    delete?: boolean
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    update?: XOR<CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateOneWithoutCafeVirtualLinkNestedInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    upsert?: CafeVirtualLinkThumbnailImageUpsertWithoutCafeVirtualLinkInput
    disconnect?: boolean
    delete?: boolean
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    update?: XOR<CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
  }

  export type CafeVirtualLinkCreateNestedOneWithoutCafeVirtualLinkThumbnailImageInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeVirtualLinkThumbnailImageInput
    connect?: CafeVirtualLinkWhereUniqueInput
  }

  export type CafeVirtualLinkUpdateOneRequiredWithoutCafeVirtualLinkThumbnailImageNestedInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeVirtualLinkThumbnailImageInput
    upsert?: CafeVirtualLinkUpsertWithoutCafeVirtualLinkThumbnailImageInput
    connect?: CafeVirtualLinkWhereUniqueInput
    update?: XOR<CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput>
  }

  export type CafeCouponCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutCafeCouponGroupInput>
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    connect?: Enumerable<CafeCouponWhereUniqueInput>
  }

  export type CafeCouponGoupPartnerCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
  }

  export type CafeCouponUncheckedCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutCafeCouponGroupInput>
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    connect?: Enumerable<CafeCouponWhereUniqueInput>
  }

  export type CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
  }

  export type CafeCouponUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutCafeCouponGroupInput>
    upsert?: Enumerable<CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput>
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    set?: Enumerable<CafeCouponWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponWhereUniqueInput>
    delete?: Enumerable<CafeCouponWhereUniqueInput>
    connect?: Enumerable<CafeCouponWhereUniqueInput>
    update?: Enumerable<CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput>
    updateMany?: Enumerable<CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput>
    deleteMany?: Enumerable<CafeCouponScalarWhereInput>
  }

  export type CafeCouponGoupPartnerUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput>
    upsert?: Enumerable<CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    set?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    delete?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    update?: Enumerable<CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput>
    updateMany?: Enumerable<CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput>
    deleteMany?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
  }

  export type CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutCafeCouponGroupInput>
    upsert?: Enumerable<CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput>
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    set?: Enumerable<CafeCouponWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponWhereUniqueInput>
    delete?: Enumerable<CafeCouponWhereUniqueInput>
    connect?: Enumerable<CafeCouponWhereUniqueInput>
    update?: Enumerable<CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput>
    updateMany?: Enumerable<CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput>
    deleteMany?: Enumerable<CafeCouponScalarWhereInput>
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<Enumerable<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput>, Enumerable<CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>>
    connectOrCreate?: Enumerable<CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput>
    upsert?: Enumerable<CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput>
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    set?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    delete?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    connect?: Enumerable<CafeCouponGoupPartnerWhereUniqueInput>
    update?: Enumerable<CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput>
    updateMany?: Enumerable<CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput>
    deleteMany?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
  }

  export type CafeCouponGroupCreateNestedOneWithoutCafeCouponGoupPartnersInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponGoupPartnersInput
    connect?: CafeCouponGroupWhereUniqueInput
  }

  export type CafeInfoCreateNestedOneWithoutCafeCouponGroupPartnersInput = {
    create?: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeCouponGroupPartnersInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeCouponGroupUpdateOneRequiredWithoutCafeCouponGoupPartnersNestedInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponGoupPartnersInput
    upsert?: CafeCouponGroupUpsertWithoutCafeCouponGoupPartnersInput
    connect?: CafeCouponGroupWhereUniqueInput
    update?: XOR<CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeCouponGroupPartnersNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeCouponGroupPartnersInput
    upsert?: CafeInfoUpsertWithoutCafeCouponGroupPartnersInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput>
  }

  export type UserCreateNestedOneWithoutProxyUsersInput = {
    create?: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyUsersInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCouponCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutProxyUserInput>, Enumerable<CafeCouponUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutProxyUserInput>
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    connect?: Enumerable<CafeCouponWhereUniqueInput>
  }

  export type WishlistProductCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProxyUserInput>, Enumerable<WishlistProductUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProxyUserInput>
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    connect?: Enumerable<WishlistProductWhereUniqueInput>
  }

  export type CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutProxyUserInput>, Enumerable<CafeCouponUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutProxyUserInput>
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    connect?: Enumerable<CafeCouponWhereUniqueInput>
  }

  export type WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProxyUserInput>, Enumerable<WishlistProductUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProxyUserInput>
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    connect?: Enumerable<WishlistProductWhereUniqueInput>
  }

  export type EnumProxyUserTypeFieldUpdateOperationsInput = {
    set?: ProxyUserType
  }

  export type UserUpdateOneWithoutProxyUsersNestedInput = {
    create?: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyUsersInput
    upsert?: UserUpsertWithoutProxyUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProxyUsersInput, UserUncheckedUpdateWithoutProxyUsersInput>
  }

  export type CafeCouponUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutProxyUserInput>, Enumerable<CafeCouponUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutProxyUserInput>
    upsert?: Enumerable<CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput>
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    set?: Enumerable<CafeCouponWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponWhereUniqueInput>
    delete?: Enumerable<CafeCouponWhereUniqueInput>
    connect?: Enumerable<CafeCouponWhereUniqueInput>
    update?: Enumerable<CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput>
    updateMany?: Enumerable<CafeCouponUpdateManyWithWhereWithoutProxyUserInput>
    deleteMany?: Enumerable<CafeCouponScalarWhereInput>
  }

  export type WishlistProductUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProxyUserInput>, Enumerable<WishlistProductUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProxyUserInput>
    upsert?: Enumerable<WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput>
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    set?: Enumerable<WishlistProductWhereUniqueInput>
    disconnect?: Enumerable<WishlistProductWhereUniqueInput>
    delete?: Enumerable<WishlistProductWhereUniqueInput>
    connect?: Enumerable<WishlistProductWhereUniqueInput>
    update?: Enumerable<WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput>
    updateMany?: Enumerable<WishlistProductUpdateManyWithWhereWithoutProxyUserInput>
    deleteMany?: Enumerable<WishlistProductScalarWhereInput>
  }

  export type CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<Enumerable<CafeCouponCreateWithoutProxyUserInput>, Enumerable<CafeCouponUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<CafeCouponCreateOrConnectWithoutProxyUserInput>
    upsert?: Enumerable<CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput>
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    set?: Enumerable<CafeCouponWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponWhereUniqueInput>
    delete?: Enumerable<CafeCouponWhereUniqueInput>
    connect?: Enumerable<CafeCouponWhereUniqueInput>
    update?: Enumerable<CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput>
    updateMany?: Enumerable<CafeCouponUpdateManyWithWhereWithoutProxyUserInput>
    deleteMany?: Enumerable<CafeCouponScalarWhereInput>
  }

  export type WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProxyUserInput>, Enumerable<WishlistProductUncheckedCreateWithoutProxyUserInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProxyUserInput>
    upsert?: Enumerable<WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput>
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    set?: Enumerable<WishlistProductWhereUniqueInput>
    disconnect?: Enumerable<WishlistProductWhereUniqueInput>
    delete?: Enumerable<WishlistProductWhereUniqueInput>
    connect?: Enumerable<WishlistProductWhereUniqueInput>
    update?: Enumerable<WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput>
    updateMany?: Enumerable<WishlistProductUpdateManyWithWhereWithoutProxyUserInput>
    deleteMany?: Enumerable<WishlistProductScalarWhereInput>
  }

  export type ProxyUserCreateNestedOneWithoutCafeCouponsInput = {
    create?: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutCafeCouponsInput
    connect?: ProxyUserWhereUniqueInput
  }

  export type CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponsInput
    connect?: CafeCouponGroupWhereUniqueInput
  }

  export type CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<Enumerable<CafeCouponQRCodeCreateWithoutCafeCouponInput>, Enumerable<CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput>
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    connect?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
  }

  export type CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutCafeCouponInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput>
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
  }

  export type CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<Enumerable<CafeCouponQRCodeCreateWithoutCafeCouponInput>, Enumerable<CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput>
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    connect?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
  }

  export type CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutCafeCouponInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput>
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
  }

  export type ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput = {
    create?: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutCafeCouponsInput
    upsert?: ProxyUserUpsertWithoutCafeCouponsInput
    connect?: ProxyUserWhereUniqueInput
    update?: XOR<ProxyUserUpdateWithoutCafeCouponsInput, ProxyUserUncheckedUpdateWithoutCafeCouponsInput>
  }

  export type CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponsInput
    upsert?: CafeCouponGroupUpsertWithoutCafeCouponsInput
    connect?: CafeCouponGroupWhereUniqueInput
    update?: XOR<CafeCouponGroupUpdateWithoutCafeCouponsInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput>
  }

  export type CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<Enumerable<CafeCouponQRCodeCreateWithoutCafeCouponInput>, Enumerable<CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput>
    upsert?: Enumerable<CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput>
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    set?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    delete?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    connect?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    update?: Enumerable<CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput>
    updateMany?: Enumerable<CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput>
    deleteMany?: Enumerable<CafeCouponQRCodeScalarWhereInput>
  }

  export type CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutCafeCouponInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput>
    upsert?: Enumerable<CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput>
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    set?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    delete?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    update?: Enumerable<CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput>
    updateMany?: Enumerable<CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput>
    deleteMany?: Enumerable<CafeCouponHistoryScalarWhereInput>
  }

  export type CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<Enumerable<CafeCouponQRCodeCreateWithoutCafeCouponInput>, Enumerable<CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput>
    upsert?: Enumerable<CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput>
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    set?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    delete?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    connect?: Enumerable<CafeCouponQRCodeWhereUniqueInput>
    update?: Enumerable<CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput>
    updateMany?: Enumerable<CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput>
    deleteMany?: Enumerable<CafeCouponQRCodeScalarWhereInput>
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<Enumerable<CafeCouponHistoryCreateWithoutCafeCouponInput>, Enumerable<CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>>
    connectOrCreate?: Enumerable<CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput>
    upsert?: Enumerable<CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput>
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    set?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    disconnect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    delete?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    connect?: Enumerable<CafeCouponHistoryWhereUniqueInput>
    update?: Enumerable<CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput>
    updateMany?: Enumerable<CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput>
    deleteMany?: Enumerable<CafeCouponHistoryScalarWhereInput>
  }

  export type CafeCouponCreateNestedOneWithoutCafeCouponHistoriesInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponHistoriesInput
    connect?: CafeCouponWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCafeCouponHistoriesInput = {
    create?: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCafeCouponHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCouponUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponHistoriesInput
    upsert?: CafeCouponUpsertWithoutCafeCouponHistoriesInput
    connect?: CafeCouponWhereUniqueInput
    update?: XOR<CafeCouponUpdateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput>
  }

  export type EnumCafeCouponEventTypeFieldUpdateOperationsInput = {
    set?: CafeCouponEventType
  }

  export type UserUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCafeCouponHistoriesInput
    upsert?: UserUpsertWithoutCafeCouponHistoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCafeCouponHistoriesInput, UserUncheckedUpdateWithoutCafeCouponHistoriesInput>
  }

  export type NullableEnumCafeCouponStatusFieldUpdateOperationsInput = {
    set?: CafeCouponStatus | null
  }

  export type CafeCouponCreateNestedOneWithoutCafeCouponQRCodesInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponQRCodesInput
    connect?: CafeCouponWhereUniqueInput
  }

  export type CafeCouponUpdateOneWithoutCafeCouponQRCodesNestedInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponQRCodesInput
    upsert?: CafeCouponUpsertWithoutCafeCouponQRCodesInput
    disconnect?: boolean
    delete?: boolean
    connect?: CafeCouponWhereUniqueInput
    update?: XOR<CafeCouponUpdateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput>
  }

  export type CafeInfoCreateNestedOneWithoutMetaViewerInfosInput = {
    create?: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutMetaViewerInfosInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput = {
    create?: XOR<Enumerable<MetaViewerMapCreateWithoutMetaViewerInfoInput>, Enumerable<MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput>
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    connect?: Enumerable<MetaViewerMapWhereUniqueInput>
  }

  export type MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    connect?: MetaViewerActiveMapWhereUniqueInput
  }

  export type MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput = {
    create?: XOR<Enumerable<MetaViewerMapCreateWithoutMetaViewerInfoInput>, Enumerable<MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput>
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    connect?: Enumerable<MetaViewerMapWhereUniqueInput>
  }

  export type MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    connect?: MetaViewerActiveMapWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput = {
    create?: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutMetaViewerInfosInput
    upsert?: CafeInfoUpsertWithoutMetaViewerInfosInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutMetaViewerInfosInput, CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput>
  }

  export type MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput = {
    create?: XOR<Enumerable<MetaViewerMapCreateWithoutMetaViewerInfoInput>, Enumerable<MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput>
    upsert?: Enumerable<MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput>
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    set?: Enumerable<MetaViewerMapWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerMapWhereUniqueInput>
    delete?: Enumerable<MetaViewerMapWhereUniqueInput>
    connect?: Enumerable<MetaViewerMapWhereUniqueInput>
    update?: Enumerable<MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput>
    updateMany?: Enumerable<MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput>
    deleteMany?: Enumerable<MetaViewerMapScalarWhereInput>
  }

  export type MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    upsert?: MetaViewerActiveMapUpsertWithoutMetaViewerInfoInput
    disconnect?: boolean
    delete?: boolean
    connect?: MetaViewerActiveMapWhereUniqueInput
    update?: XOR<MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput = {
    create?: XOR<Enumerable<MetaViewerMapCreateWithoutMetaViewerInfoInput>, Enumerable<MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>>
    connectOrCreate?: Enumerable<MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput>
    upsert?: Enumerable<MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput>
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    set?: Enumerable<MetaViewerMapWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerMapWhereUniqueInput>
    delete?: Enumerable<MetaViewerMapWhereUniqueInput>
    connect?: Enumerable<MetaViewerMapWhereUniqueInput>
    update?: Enumerable<MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput>
    updateMany?: Enumerable<MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput>
    deleteMany?: Enumerable<MetaViewerMapScalarWhereInput>
  }

  export type MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    upsert?: MetaViewerActiveMapUpsertWithoutMetaViewerInfoInput
    disconnect?: boolean
    delete?: boolean
    connect?: MetaViewerActiveMapWhereUniqueInput
    update?: XOR<MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput = {
    create?: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutMetaViewerMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
  }

  export type MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveRenderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
  }

  export type MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveColliderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
  }

  export type MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveRenderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
  }

  export type MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveColliderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
  }

  export type EnumMetaMapTypeFieldUpdateOperationsInput = {
    set?: MetaMapType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput = {
    create?: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutMetaViewerMapsInput
    upsert?: MetaViewerInfoUpsertWithoutMetaViewerMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
    update?: XOR<MetaViewerInfoUpdateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput>
  }

  export type MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveRenderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput>
    upsert?: Enumerable<MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    set?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    delete?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    update?: Enumerable<MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput>
    updateMany?: Enumerable<MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput>
    deleteMany?: Enumerable<MetaViewerActiveMapScalarWhereInput>
  }

  export type MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveColliderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput>
    upsert?: Enumerable<MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    set?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    delete?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    update?: Enumerable<MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput>
    updateMany?: Enumerable<MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput>
    deleteMany?: Enumerable<MetaViewerActiveMapScalarWhereInput>
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveRenderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput>
    upsert?: Enumerable<MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    set?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    delete?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    update?: Enumerable<MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput>
    updateMany?: Enumerable<MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput>
    deleteMany?: Enumerable<MetaViewerActiveMapScalarWhereInput>
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput = {
    create?: XOR<Enumerable<MetaViewerActiveMapCreateWithoutActiveColliderMapInput>, Enumerable<MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>>
    connectOrCreate?: Enumerable<MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput>
    upsert?: Enumerable<MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput>
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    set?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    disconnect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    delete?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    connect?: Enumerable<MetaViewerActiveMapWhereUniqueInput>
    update?: Enumerable<MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput>
    updateMany?: Enumerable<MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput>
    deleteMany?: Enumerable<MetaViewerActiveMapScalarWhereInput>
  }

  export type MetaViewerInfoCreateNestedOneWithoutActiveMapsInput = {
    create?: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutActiveMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
  }

  export type MetaViewerMapCreateNestedOneWithoutActiveRenderForInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveRenderForInput
    connect?: MetaViewerMapWhereUniqueInput
  }

  export type MetaViewerMapCreateNestedOneWithoutActiveColliderForInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveColliderForInput
    connect?: MetaViewerMapWhereUniqueInput
  }

  export type MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput = {
    create?: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutActiveMapsInput
    upsert?: MetaViewerInfoUpsertWithoutActiveMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
    update?: XOR<MetaViewerInfoUpdateWithoutActiveMapsInput, MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput>
  }

  export type MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveRenderForInput
    upsert?: MetaViewerMapUpsertWithoutActiveRenderForInput
    connect?: MetaViewerMapWhereUniqueInput
    update?: XOR<MetaViewerMapUpdateWithoutActiveRenderForInput, MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput>
  }

  export type MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveColliderForInput
    upsert?: MetaViewerMapUpsertWithoutActiveColliderForInput
    connect?: MetaViewerMapWhereUniqueInput
    update?: XOR<MetaViewerMapUpdateWithoutActiveColliderForInput, MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput>
  }

  export type ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput>
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
  }

  export type ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput>
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput>
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
  }

  export type ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput>
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput>
    upsert?: Enumerable<ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput>
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    set?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    update?: Enumerable<ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput>
    updateMany?: Enumerable<ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput>
    deleteMany?: Enumerable<ClosureProductCategoryScalarWhereInput>
  }

  export type ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput>
    upsert?: Enumerable<ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput>
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    set?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    update?: Enumerable<ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput>
    updateMany?: Enumerable<ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput>
    deleteMany?: Enumerable<ClosureProductCategoryScalarWhereInput>
  }

  export type ProductUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutAncestorCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput>
    upsert?: Enumerable<ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput>
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    set?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    update?: Enumerable<ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput>
    updateMany?: Enumerable<ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput>
    deleteMany?: Enumerable<ClosureProductCategoryScalarWhereInput>
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<Enumerable<ClosureProductCategoryCreateWithoutDescendantCategoryInput>, Enumerable<ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>>
    connectOrCreate?: Enumerable<ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput>
    upsert?: Enumerable<ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput>
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    set?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    disconnect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    delete?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    connect?: Enumerable<ClosureProductCategoryWhereUniqueInput>
    update?: Enumerable<ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput>
    updateMany?: Enumerable<ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput>
    deleteMany?: Enumerable<ClosureProductCategoryScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductCategoryCreateNestedOneWithoutAncestorCategoriesInput = {
    create?: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAncestorCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutDescendantCategoriesInput = {
    create?: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDescendantCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAncestorCategoriesInput
    upsert?: ProductCategoryUpsertWithoutAncestorCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<ProductCategoryUpdateWithoutAncestorCategoriesInput, ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDescendantCategoriesInput
    upsert?: ProductCategoryUpsertWithoutDescendantCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<ProductCategoryUpdateWithoutDescendantCategoriesInput, ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type CafeInfoCreateNestedOneWithoutProductsInput = {
    create?: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutProductsInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type WishlistProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProductInput>, Enumerable<WishlistProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProductInput>
    createMany?: WishlistProductCreateManyProductInputEnvelope
    connect?: Enumerable<WishlistProductWhereUniqueInput>
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: Enumerable<ProductImageWhereUniqueInput>
  }

  export type WishlistProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProductInput>, Enumerable<WishlistProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProductInput>
    createMany?: WishlistProductCreateManyProductInputEnvelope
    connect?: Enumerable<WishlistProductWhereUniqueInput>
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: Enumerable<ProductImageWhereUniqueInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CafeInfoUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutProductsInput
    upsert?: CafeInfoUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<CafeInfoUpdateWithoutProductsInput, CafeInfoUncheckedUpdateWithoutProductsInput>
  }

  export type WishlistProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProductInput>, Enumerable<WishlistProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<WishlistProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: WishlistProductCreateManyProductInputEnvelope
    set?: Enumerable<WishlistProductWhereUniqueInput>
    disconnect?: Enumerable<WishlistProductWhereUniqueInput>
    delete?: Enumerable<WishlistProductWhereUniqueInput>
    connect?: Enumerable<WishlistProductWhereUniqueInput>
    update?: Enumerable<WishlistProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<WishlistProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<WishlistProductScalarWhereInput>
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductImageUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: Enumerable<ProductImageWhereUniqueInput>
    disconnect?: Enumerable<ProductImageWhereUniqueInput>
    delete?: Enumerable<ProductImageWhereUniqueInput>
    connect?: Enumerable<ProductImageWhereUniqueInput>
    update?: Enumerable<ProductImageUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductImageUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductImageScalarWhereInput>
  }

  export type WishlistProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<WishlistProductCreateWithoutProductInput>, Enumerable<WishlistProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<WishlistProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: WishlistProductCreateManyProductInputEnvelope
    set?: Enumerable<WishlistProductWhereUniqueInput>
    disconnect?: Enumerable<WishlistProductWhereUniqueInput>
    delete?: Enumerable<WishlistProductWhereUniqueInput>
    connect?: Enumerable<WishlistProductWhereUniqueInput>
    update?: Enumerable<WishlistProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<WishlistProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<WishlistProductScalarWhereInput>
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductImageUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: Enumerable<ProductImageWhereUniqueInput>
    disconnect?: Enumerable<ProductImageWhereUniqueInput>
    delete?: Enumerable<ProductImageWhereUniqueInput>
    connect?: Enumerable<ProductImageWhereUniqueInput>
    update?: Enumerable<ProductImageUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductImageUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductImageScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutWishlistProductsInput = {
    create?: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProxyUserCreateNestedOneWithoutWishlistProductsInput = {
    create?: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutWishlistProductsInput
    connect?: ProxyUserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutWishlistProductsNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistProductsInput
    upsert?: ProductUpsertWithoutWishlistProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutWishlistProductsInput, ProductUncheckedUpdateWithoutWishlistProductsInput>
  }

  export type ProxyUserUpdateOneRequiredWithoutWishlistProductsNestedInput = {
    create?: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutWishlistProductsInput
    upsert?: ProxyUserUpsertWithoutWishlistProductsInput
    connect?: ProxyUserWhereUniqueInput
    update?: XOR<ProxyUserUpdateWithoutWishlistProductsInput, ProxyUserUncheckedUpdateWithoutWishlistProductsInput>
  }

  export type ProductCreateNestedOneWithoutProductImagesInput = {
    create?: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductImagesNestedInput = {
    create?: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImagesInput
    upsert?: ProductUpsertWithoutProductImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductImagesInput, ProductUncheckedUpdateWithoutProductImagesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumLoginTypeFilter = {
    equals?: LoginType
    in?: Enumerable<LoginType>
    notIn?: Enumerable<LoginType>
    not?: NestedEnumLoginTypeFilter | LoginType
  }

  export type NestedEnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumLoginTypeWithAggregatesFilter = {
    equals?: LoginType
    in?: Enumerable<LoginType>
    notIn?: Enumerable<LoginType>
    not?: NestedEnumLoginTypeWithAggregatesFilter | LoginType
    _count?: NestedIntFilter
    _min?: NestedEnumLoginTypeFilter
    _max?: NestedEnumLoginTypeFilter
  }

  export type NestedEnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumBoardTypeFilter = {
    equals?: BoardType
    in?: Enumerable<BoardType>
    notIn?: Enumerable<BoardType>
    not?: NestedEnumBoardTypeFilter | BoardType
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumBoardTypeWithAggregatesFilter = {
    equals?: BoardType
    in?: Enumerable<BoardType>
    notIn?: Enumerable<BoardType>
    not?: NestedEnumBoardTypeWithAggregatesFilter | BoardType
    _count?: NestedIntFilter
    _min?: NestedEnumBoardTypeFilter
    _max?: NestedEnumBoardTypeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumGovermentTypeFilter = {
    equals?: GovermentType
    in?: Enumerable<GovermentType>
    notIn?: Enumerable<GovermentType>
    not?: NestedEnumGovermentTypeFilter | GovermentType
  }

  export type NestedEnumGovermentTypeWithAggregatesFilter = {
    equals?: GovermentType
    in?: Enumerable<GovermentType>
    notIn?: Enumerable<GovermentType>
    not?: NestedEnumGovermentTypeWithAggregatesFilter | GovermentType
    _count?: NestedIntFilter
    _min?: NestedEnumGovermentTypeFilter
    _max?: NestedEnumGovermentTypeFilter
  }

  export type NestedEnumProxyUserTypeFilter = {
    equals?: ProxyUserType
    in?: Enumerable<ProxyUserType>
    notIn?: Enumerable<ProxyUserType>
    not?: NestedEnumProxyUserTypeFilter | ProxyUserType
  }

  export type NestedEnumProxyUserTypeWithAggregatesFilter = {
    equals?: ProxyUserType
    in?: Enumerable<ProxyUserType>
    notIn?: Enumerable<ProxyUserType>
    not?: NestedEnumProxyUserTypeWithAggregatesFilter | ProxyUserType
    _count?: NestedIntFilter
    _min?: NestedEnumProxyUserTypeFilter
    _max?: NestedEnumProxyUserTypeFilter
  }

  export type NestedEnumCafeCouponEventTypeFilter = {
    equals?: CafeCouponEventType
    in?: Enumerable<CafeCouponEventType>
    notIn?: Enumerable<CafeCouponEventType>
    not?: NestedEnumCafeCouponEventTypeFilter | CafeCouponEventType
  }

  export type NestedEnumCafeCouponStatusNullableFilter = {
    equals?: CafeCouponStatus | null
    in?: Enumerable<CafeCouponStatus> | null
    notIn?: Enumerable<CafeCouponStatus> | null
    not?: NestedEnumCafeCouponStatusNullableFilter | CafeCouponStatus | null
  }

  export type NestedEnumCafeCouponEventTypeWithAggregatesFilter = {
    equals?: CafeCouponEventType
    in?: Enumerable<CafeCouponEventType>
    notIn?: Enumerable<CafeCouponEventType>
    not?: NestedEnumCafeCouponEventTypeWithAggregatesFilter | CafeCouponEventType
    _count?: NestedIntFilter
    _min?: NestedEnumCafeCouponEventTypeFilter
    _max?: NestedEnumCafeCouponEventTypeFilter
  }

  export type NestedEnumCafeCouponStatusNullableWithAggregatesFilter = {
    equals?: CafeCouponStatus | null
    in?: Enumerable<CafeCouponStatus> | null
    notIn?: Enumerable<CafeCouponStatus> | null
    not?: NestedEnumCafeCouponStatusNullableWithAggregatesFilter | CafeCouponStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCafeCouponStatusNullableFilter
    _max?: NestedEnumCafeCouponStatusNullableFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumMetaMapTypeFilter = {
    equals?: MetaMapType
    in?: Enumerable<MetaMapType>
    notIn?: Enumerable<MetaMapType>
    not?: NestedEnumMetaMapTypeFilter | MetaMapType
  }

  export type NestedEnumMetaMapTypeWithAggregatesFilter = {
    equals?: MetaMapType
    in?: Enumerable<MetaMapType>
    notIn?: Enumerable<MetaMapType>
    not?: NestedEnumMetaMapTypeWithAggregatesFilter | MetaMapType
    _count?: NestedIntFilter
    _min?: NestedEnumMetaMapTypeFilter
    _max?: NestedEnumMetaMapTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type BoardCreateWithoutUserInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    boardType?: BoardType
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    boardType?: BoardType
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutUserInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput>
  }

  export type BoardCreateManyUserInputEnvelope = {
    data: Enumerable<BoardCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BoardReplyCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    boardId: number
    boardReplyId?: number | null
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyCreateOrConnectWithoutUserInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput>
  }

  export type BoardReplyCreateManyUserInputEnvelope = {
    data: Enumerable<BoardReplyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutUserInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
  }

  export type NoticeUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
  }

  export type NoticeCreateOrConnectWithoutUserInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput>
  }

  export type NoticeCreateManyUserInputEnvelope = {
    data: Enumerable<NoticeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProxyUserCreateWithoutUserInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    CafeCoupons?: CafeCouponCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateWithoutUserInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserCreateOrConnectWithoutUserInput = {
    where: ProxyUserWhereUniqueInput
    create: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput>
  }

  export type ProxyUserCreateManyUserInputEnvelope = {
    data: Enumerable<ProxyUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CafeCouponHistoryCreateWithoutActorInput = {
    createdAt?: Date | string
    CafeCoupon: CafeCouponCreateNestedOneWithoutCafeCouponHistoriesInput
    eventType: CafeCouponEventType
    description: string
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedCreateWithoutActorInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: CafeCouponEventType
    description: string
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryCreateOrConnectWithoutActorInput = {
    where: CafeCouponHistoryWhereUniqueInput
    create: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput>
  }

  export type CafeCouponHistoryCreateManyActorInputEnvelope = {
    data: Enumerable<CafeCouponHistoryCreateManyActorInput>
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithWhereUniqueWithoutUserInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutUserInput, BoardUncheckedUpdateWithoutUserInput>
    create: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutUserInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutUserInput, BoardUncheckedUpdateWithoutUserInput>
  }

  export type BoardUpdateManyWithWhereWithoutUserInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutBoardsInput>
  }

  export type BoardScalarWhereInput = {
    AND?: Enumerable<BoardScalarWhereInput>
    OR?: Enumerable<BoardScalarWhereInput>
    NOT?: Enumerable<BoardScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    startDay?: DateTimeFilter | Date | string
    endDay?: DateTimeNullableFilter | Date | string | null
    isDisable?: BoolFilter | boolean
    isReplyAvaliable?: BoolFilter | boolean
    userId?: IntFilter | number
    boardType?: EnumBoardTypeFilter | BoardType
  }

  export type BoardReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: BoardReplyWhereUniqueInput
    update: XOR<BoardReplyUpdateWithoutUserInput, BoardReplyUncheckedUpdateWithoutUserInput>
    create: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput>
  }

  export type BoardReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: BoardReplyWhereUniqueInput
    data: XOR<BoardReplyUpdateWithoutUserInput, BoardReplyUncheckedUpdateWithoutUserInput>
  }

  export type BoardReplyUpdateManyWithWhereWithoutUserInput = {
    where: BoardReplyScalarWhereInput
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyWithoutBoardRepliesInput>
  }

  export type BoardReplyScalarWhereInput = {
    AND?: Enumerable<BoardReplyScalarWhereInput>
    OR?: Enumerable<BoardReplyScalarWhereInput>
    NOT?: Enumerable<BoardReplyScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    content?: StringFilter | string
    isDisable?: BoolFilter | boolean
    userId?: IntFilter | number
    boardId?: IntFilter | number
    boardReplyId?: IntNullableFilter | number | null
  }

  export type NoticeUpsertWithWhereUniqueWithoutUserInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutUserInput, NoticeUncheckedUpdateWithoutUserInput>
    create: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutUserInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutUserInput, NoticeUncheckedUpdateWithoutUserInput>
  }

  export type NoticeUpdateManyWithWhereWithoutUserInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutNoticesInput>
  }

  export type NoticeScalarWhereInput = {
    AND?: Enumerable<NoticeScalarWhereInput>
    OR?: Enumerable<NoticeScalarWhereInput>
    NOT?: Enumerable<NoticeScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    userId?: IntFilter | number
  }

  export type ProxyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ProxyUserWhereUniqueInput
    update: XOR<ProxyUserUpdateWithoutUserInput, ProxyUserUncheckedUpdateWithoutUserInput>
    create: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput>
  }

  export type ProxyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ProxyUserWhereUniqueInput
    data: XOR<ProxyUserUpdateWithoutUserInput, ProxyUserUncheckedUpdateWithoutUserInput>
  }

  export type ProxyUserUpdateManyWithWhereWithoutUserInput = {
    where: ProxyUserScalarWhereInput
    data: XOR<ProxyUserUpdateManyMutationInput, ProxyUserUncheckedUpdateManyWithoutProxyUsersInput>
  }

  export type ProxyUserScalarWhereInput = {
    AND?: Enumerable<ProxyUserScalarWhereInput>
    OR?: Enumerable<ProxyUserScalarWhereInput>
    NOT?: Enumerable<ProxyUserScalarWhereInput>
    id?: IntFilter | number
    memberId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    proxyUserType?: EnumProxyUserTypeFilter | ProxyUserType
    name?: StringFilter | string
    token?: StringFilter | string
    userId?: IntNullableFilter | number | null
  }

  export type CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput = {
    where: CafeCouponHistoryWhereUniqueInput
    update: XOR<CafeCouponHistoryUpdateWithoutActorInput, CafeCouponHistoryUncheckedUpdateWithoutActorInput>
    create: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput>
  }

  export type CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput = {
    where: CafeCouponHistoryWhereUniqueInput
    data: XOR<CafeCouponHistoryUpdateWithoutActorInput, CafeCouponHistoryUncheckedUpdateWithoutActorInput>
  }

  export type CafeCouponHistoryUpdateManyWithWhereWithoutActorInput = {
    where: CafeCouponHistoryScalarWhereInput
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponHistoryScalarWhereInput = {
    AND?: Enumerable<CafeCouponHistoryScalarWhereInput>
    OR?: Enumerable<CafeCouponHistoryScalarWhereInput>
    NOT?: Enumerable<CafeCouponHistoryScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    cafeCouponId?: IntFilter | number
    eventType?: EnumCafeCouponEventTypeFilter | CafeCouponEventType
    description?: StringFilter | string
    actorId?: IntFilter | number
    statusBefore?: EnumCafeCouponStatusNullableFilter | CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableFilter | CafeCouponStatus | null
  }

  export type UserCreateWithoutNoticesInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutNoticesInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutNoticesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
  }

  export type UserUpsertWithoutNoticesInput = {
    update: XOR<UserUpdateWithoutNoticesInput, UserUncheckedUpdateWithoutNoticesInput>
    create: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
  }

  export type UserUpdateWithoutNoticesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type BoardImageCreateWithoutBoardInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
  }

  export type BoardImageUncheckedCreateWithoutBoardInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
  }

  export type BoardImageCreateOrConnectWithoutBoardInput = {
    where: BoardImageWhereUniqueInput
    create: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput>
  }

  export type BoardImageCreateManyBoardInputEnvelope = {
    data: Enumerable<BoardImageCreateManyBoardInput>
    skipDuplicates?: boolean
  }

  export type BoardReplyCreateWithoutBoardInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateWithoutBoardInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardReplyId?: number | null
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyCreateOrConnectWithoutBoardInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput>
  }

  export type BoardReplyCreateManyBoardInputEnvelope = {
    data: Enumerable<BoardReplyCreateManyBoardInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBoardsInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutBoardsInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutBoardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
  }

  export type CafeBoardCreateWithoutBoardInput = {
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeBoardsInput
    createdAt?: Date | string
  }

  export type CafeBoardUncheckedCreateWithoutBoardInput = {
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type CafeBoardCreateOrConnectWithoutBoardInput = {
    where: CafeBoardWhereUniqueInput
    create: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput>
  }

  export type CafeBoardCreateManyBoardInputEnvelope = {
    data: Enumerable<CafeBoardCreateManyBoardInput>
    skipDuplicates?: boolean
  }

  export type BoardImageUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardImageWhereUniqueInput
    update: XOR<BoardImageUpdateWithoutBoardInput, BoardImageUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput>
  }

  export type BoardImageUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardImageWhereUniqueInput
    data: XOR<BoardImageUpdateWithoutBoardInput, BoardImageUncheckedUpdateWithoutBoardInput>
  }

  export type BoardImageUpdateManyWithWhereWithoutBoardInput = {
    where: BoardImageScalarWhereInput
    data: XOR<BoardImageUpdateManyMutationInput, BoardImageUncheckedUpdateManyWithoutBoardImagesInput>
  }

  export type BoardImageScalarWhereInput = {
    AND?: Enumerable<BoardImageScalarWhereInput>
    OR?: Enumerable<BoardImageScalarWhereInput>
    NOT?: Enumerable<BoardImageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    thumbnailUrl?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    isThumb?: BoolFilter | boolean
    isDisable?: BoolFilter | boolean
    boardId?: IntFilter | number
  }

  export type BoardReplyUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardReplyWhereUniqueInput
    update: XOR<BoardReplyUpdateWithoutBoardInput, BoardReplyUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput>
  }

  export type BoardReplyUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardReplyWhereUniqueInput
    data: XOR<BoardReplyUpdateWithoutBoardInput, BoardReplyUncheckedUpdateWithoutBoardInput>
  }

  export type BoardReplyUpdateManyWithWhereWithoutBoardInput = {
    where: BoardReplyScalarWhereInput
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyWithoutBoardRepliesInput>
  }

  export type UserUpsertWithoutBoardsInput = {
    update: XOR<UserUpdateWithoutBoardsInput, UserUncheckedUpdateWithoutBoardsInput>
    create: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
  }

  export type UserUpdateWithoutBoardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CafeBoardUpsertWithWhereUniqueWithoutBoardInput = {
    where: CafeBoardWhereUniqueInput
    update: XOR<CafeBoardUpdateWithoutBoardInput, CafeBoardUncheckedUpdateWithoutBoardInput>
    create: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput>
  }

  export type CafeBoardUpdateWithWhereUniqueWithoutBoardInput = {
    where: CafeBoardWhereUniqueInput
    data: XOR<CafeBoardUpdateWithoutBoardInput, CafeBoardUncheckedUpdateWithoutBoardInput>
  }

  export type CafeBoardUpdateManyWithWhereWithoutBoardInput = {
    where: CafeBoardScalarWhereInput
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyWithoutCafeBoardsInput>
  }

  export type CafeBoardScalarWhereInput = {
    AND?: Enumerable<CafeBoardScalarWhereInput>
    OR?: Enumerable<CafeBoardScalarWhereInput>
    NOT?: Enumerable<CafeBoardScalarWhereInput>
    boardId?: IntFilter | number
    cafeInfoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type BoardCreateWithoutBoardImagesInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    boardType?: BoardType
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutBoardImagesInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    userId: number
    boardType?: BoardType
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutBoardImagesInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
  }

  export type BoardUpsertWithoutBoardImagesInput = {
    update: XOR<BoardUpdateWithoutBoardImagesInput, BoardUncheckedUpdateWithoutBoardImagesInput>
    create: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
  }

  export type BoardUpdateWithoutBoardImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutBoardImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type UserCreateWithoutBoardRepliesInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutBoardRepliesInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutBoardRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
  }

  export type BoardCreateWithoutBoardRepliesInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    boardType?: BoardType
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutBoardRepliesInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    userId: number
    boardType?: BoardType
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutBoardRepliesInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
  }

  export type BoardReplyCreateWithoutBoardNestedRepliesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
  }

  export type BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    boardReplyId?: number | null
  }

  export type BoardReplyCreateOrConnectWithoutBoardNestedRepliesInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
  }

  export type BoardReplyCreateWithoutBoardReplyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateWithoutBoardReplyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyCreateOrConnectWithoutBoardReplyInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput>
  }

  export type BoardReplyCreateManyBoardReplyInputEnvelope = {
    data: Enumerable<BoardReplyCreateManyBoardReplyInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBoardRepliesInput = {
    update: XOR<UserUpdateWithoutBoardRepliesInput, UserUncheckedUpdateWithoutBoardRepliesInput>
    create: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
  }

  export type UserUpdateWithoutBoardRepliesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutBoardRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type BoardUpsertWithoutBoardRepliesInput = {
    update: XOR<BoardUpdateWithoutBoardRepliesInput, BoardUncheckedUpdateWithoutBoardRepliesInput>
    create: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
  }

  export type BoardUpdateWithoutBoardRepliesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutBoardRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardReplyUpsertWithoutBoardNestedRepliesInput = {
    update: XOR<BoardReplyUpdateWithoutBoardNestedRepliesInput, BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput>
    create: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
  }

  export type BoardReplyUpdateWithoutBoardNestedRepliesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput = {
    where: BoardReplyWhereUniqueInput
    update: XOR<BoardReplyUpdateWithoutBoardReplyInput, BoardReplyUncheckedUpdateWithoutBoardReplyInput>
    create: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput>
  }

  export type BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput = {
    where: BoardReplyWhereUniqueInput
    data: XOR<BoardReplyUpdateWithoutBoardReplyInput, BoardReplyUncheckedUpdateWithoutBoardReplyInput>
  }

  export type BoardReplyUpdateManyWithWhereWithoutBoardReplyInput = {
    where: BoardReplyScalarWhereInput
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyWithoutBoardNestedRepliesInput>
  }

  export type BoardCreateWithoutCafeBoardsInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    boardType?: BoardType
  }

  export type BoardUncheckedCreateWithoutCafeBoardsInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    userId: number
    boardType?: BoardType
  }

  export type BoardCreateOrConnectWithoutCafeBoardsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
  }

  export type CafeInfoCreateWithoutCafeBoardsInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeBoardsInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeBoardsInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
  }

  export type BoardUpsertWithoutCafeBoardsInput = {
    update: XOR<BoardUpdateWithoutCafeBoardsInput, BoardUncheckedUpdateWithoutCafeBoardsInput>
    create: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
  }

  export type BoardUpdateWithoutCafeBoardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
  }

  export type BoardUncheckedUpdateWithoutCafeBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
  }

  export type CafeInfoUpsertWithoutCafeBoardsInput = {
    update: XOR<CafeInfoUpdateWithoutCafeBoardsInput, CafeInfoUncheckedUpdateWithoutCafeBoardsInput>
    create: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
  }

  export type CafeInfoUpdateWithoutCafeBoardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutRegionCategoryInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutRegionCategoryInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutRegionCategoryInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput>
  }

  export type CafeInfoCreateManyRegionCategoryInputEnvelope = {
    data: Enumerable<CafeInfoCreateManyRegionCategoryInput>
    skipDuplicates?: boolean
  }

  export type ClosureRegionCategoryCreateWithoutAncestorCategoryInput = {
    depth?: number
    DescendantCategory: RegionCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    create: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope = {
    data: Enumerable<ClosureRegionCategoryCreateManyAncestorCategoryInput>
    skipDuplicates?: boolean
  }

  export type ClosureRegionCategoryCreateWithoutDescendantCategoryInput = {
    depth?: number
    AncestorCategory: RegionCategoryCreateNestedOneWithoutAncestorCategoriesInput
  }

  export type ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    create: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope = {
    data: Enumerable<ClosureRegionCategoryCreateManyDescendantCategoryInput>
    skipDuplicates?: boolean
  }

  export type CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput = {
    where: CafeInfoWhereUniqueInput
    update: XOR<CafeInfoUpdateWithoutRegionCategoryInput, CafeInfoUncheckedUpdateWithoutRegionCategoryInput>
    create: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput>
  }

  export type CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput = {
    where: CafeInfoWhereUniqueInput
    data: XOR<CafeInfoUpdateWithoutRegionCategoryInput, CafeInfoUncheckedUpdateWithoutRegionCategoryInput>
  }

  export type CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput = {
    where: CafeInfoScalarWhereInput
    data: XOR<CafeInfoUpdateManyMutationInput, CafeInfoUncheckedUpdateManyWithoutCafeInfosInput>
  }

  export type CafeInfoScalarWhereInput = {
    AND?: Enumerable<CafeInfoScalarWhereInput>
    OR?: Enumerable<CafeInfoScalarWhereInput>
    NOT?: Enumerable<CafeInfoScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    isDisable?: BoolFilter | boolean
    name?: StringFilter | string
    code?: StringNullableFilter | string | null
    regionCategoryId?: IntFilter | number
    address?: StringFilter | string
    directions?: StringFilter | string
    businessNumber?: StringFilter | string
    ceoName?: StringFilter | string
  }

  export type ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    update: XOR<ClosureRegionCategoryUpdateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutAncestorCategoryInput>
    create: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    data: XOR<ClosureRegionCategoryUpdateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryScalarWhereInput
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoriesInput>
  }

  export type ClosureRegionCategoryScalarWhereInput = {
    AND?: Enumerable<ClosureRegionCategoryScalarWhereInput>
    OR?: Enumerable<ClosureRegionCategoryScalarWhereInput>
    NOT?: Enumerable<ClosureRegionCategoryScalarWhereInput>
    ancestor?: IntFilter | number
    descendant?: IntFilter | number
    depth?: IntFilter | number
  }

  export type ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    update: XOR<ClosureRegionCategoryUpdateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutDescendantCategoryInput>
    create: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    data: XOR<ClosureRegionCategoryUpdateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutDescendantCategoryInput>
  }

  export type ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryScalarWhereInput
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryCreateWithoutAncestorCategoriesInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    CafeInfos?: CafeInfoCreateNestedManyWithoutRegionCategoryInput
    DescendantCategories?: ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    CafeInfos?: CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput
    DescendantCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryCreateOrConnectWithoutAncestorCategoriesInput = {
    where: RegionCategoryWhereUniqueInput
    create: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
  }

  export type RegionCategoryCreateWithoutDescendantCategoriesInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    CafeInfos?: CafeInfoCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput
  }

  export type RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    CafeInfos?: CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
  }

  export type RegionCategoryCreateOrConnectWithoutDescendantCategoriesInput = {
    where: RegionCategoryWhereUniqueInput
    create: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryUpsertWithoutAncestorCategoriesInput = {
    update: XOR<RegionCategoryUpdateWithoutAncestorCategoriesInput, RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
    create: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
  }

  export type RegionCategoryUpdateWithoutAncestorCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    CafeInfos?: CafeInfoUpdateManyWithoutRegionCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    CafeInfos?: CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUpsertWithoutDescendantCategoriesInput = {
    update: XOR<RegionCategoryUpdateWithoutDescendantCategoriesInput, RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
    create: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryUpdateWithoutDescendantCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    CafeInfos?: CafeInfoUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    CafeInfos?: CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
  }

  export type RegionCategoryCreateWithoutCafeInfosInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    AncestorCategories?: ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUncheckedCreateWithoutCafeInfosInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: GovermentType
    AncestorCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryCreateOrConnectWithoutCafeInfosInput = {
    where: RegionCategoryWhereUniqueInput
    create: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
  }

  export type CafeVirtualLinkCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput = {
    where: CafeVirtualLinkWhereUniqueInput
    create: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<CafeVirtualLinkCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type CafeThumbnailImageCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput = {
    where: CafeThumbnailImageWhereUniqueInput
    create: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<CafeThumbnailImageCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type CafeVirtualImageCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeVirtualImageUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeVirtualImageCreateOrConnectWithoutCafeInfoInput = {
    where: CafeVirtualImageWhereUniqueInput
    create: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualImageCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<CafeVirtualImageCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type CafeRealImageCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeRealImageUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeRealImageCreateOrConnectWithoutCafeInfoInput = {
    where: CafeRealImageWhereUniqueInput
    create: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeRealImageCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<CafeRealImageCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type CafeCouponGoupPartnerCreateWithoutCafeInfoInput = {
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponGoupPartnersInput
  }

  export type CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput = {
    cafeCouponGroupId: number
  }

  export type CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<CafeCouponGoupPartnerCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type CafeBoardCreateWithoutCafeInfoInput = {
    Board: BoardCreateNestedOneWithoutCafeBoardsInput
    createdAt?: Date | string
  }

  export type CafeBoardUncheckedCreateWithoutCafeInfoInput = {
    boardId: number
    createdAt?: Date | string
  }

  export type CafeBoardCreateOrConnectWithoutCafeInfoInput = {
    where: CafeBoardWhereUniqueInput
    create: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeBoardCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<CafeBoardCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type MetaViewerInfoCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoCreateOrConnectWithoutCafeInfoInput = {
    where: MetaViewerInfoWhereUniqueInput
    create: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>
  }

  export type MetaViewerInfoCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<MetaViewerInfoCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductCreateOrConnectWithoutCafeInfoInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput>
  }

  export type ProductCreateManyCafeInfoInputEnvelope = {
    data: Enumerable<ProductCreateManyCafeInfoInput>
    skipDuplicates?: boolean
  }

  export type RegionCategoryUpsertWithoutCafeInfosInput = {
    update: XOR<RegionCategoryUpdateWithoutCafeInfosInput, RegionCategoryUncheckedUpdateWithoutCafeInfosInput>
    create: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
  }

  export type RegionCategoryUpdateWithoutCafeInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    AncestorCategories?: ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateWithoutCafeInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | GovermentType
    AncestorCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualLinkWhereUniqueInput
    update: XOR<CafeVirtualLinkUpdateWithoutCafeInfoInput, CafeVirtualLinkUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualLinkWhereUniqueInput
    data: XOR<CafeVirtualLinkUpdateWithoutCafeInfoInput, CafeVirtualLinkUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeVirtualLinkScalarWhereInput
    data: XOR<CafeVirtualLinkUpdateManyMutationInput, CafeVirtualLinkUncheckedUpdateManyWithoutCafeVirtualLinksInput>
  }

  export type CafeVirtualLinkScalarWhereInput = {
    AND?: Enumerable<CafeVirtualLinkScalarWhereInput>
    OR?: Enumerable<CafeVirtualLinkScalarWhereInput>
    NOT?: Enumerable<CafeVirtualLinkScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    url?: StringFilter | string
    type?: StringFilter | string
    isDisable?: BoolFilter | boolean
    isAvaliable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
  }

  export type CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeThumbnailImageWhereUniqueInput
    update: XOR<CafeThumbnailImageUpdateWithoutCafeInfoInput, CafeThumbnailImageUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeThumbnailImageWhereUniqueInput
    data: XOR<CafeThumbnailImageUpdateWithoutCafeInfoInput, CafeThumbnailImageUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeThumbnailImageScalarWhereInput
    data: XOR<CafeThumbnailImageUpdateManyMutationInput, CafeThumbnailImageUncheckedUpdateManyWithoutCafeThumbnailImagesInput>
  }

  export type CafeThumbnailImageScalarWhereInput = {
    AND?: Enumerable<CafeThumbnailImageScalarWhereInput>
    OR?: Enumerable<CafeThumbnailImageScalarWhereInput>
    NOT?: Enumerable<CafeThumbnailImageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    thumbnailUrl?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    priority?: IntFilter | number
    isDisable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
  }

  export type CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualImageWhereUniqueInput
    update: XOR<CafeVirtualImageUpdateWithoutCafeInfoInput, CafeVirtualImageUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualImageWhereUniqueInput
    data: XOR<CafeVirtualImageUpdateWithoutCafeInfoInput, CafeVirtualImageUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeVirtualImageScalarWhereInput
    data: XOR<CafeVirtualImageUpdateManyMutationInput, CafeVirtualImageUncheckedUpdateManyWithoutCafeVirtualImagesInput>
  }

  export type CafeVirtualImageScalarWhereInput = {
    AND?: Enumerable<CafeVirtualImageScalarWhereInput>
    OR?: Enumerable<CafeVirtualImageScalarWhereInput>
    NOT?: Enumerable<CafeVirtualImageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    priority?: IntFilter | number
    isDisable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
  }

  export type CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeRealImageWhereUniqueInput
    update: XOR<CafeRealImageUpdateWithoutCafeInfoInput, CafeRealImageUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeRealImageWhereUniqueInput
    data: XOR<CafeRealImageUpdateWithoutCafeInfoInput, CafeRealImageUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeRealImageScalarWhereInput
    data: XOR<CafeRealImageUpdateManyMutationInput, CafeRealImageUncheckedUpdateManyWithoutCafeRealImagesInput>
  }

  export type CafeRealImageScalarWhereInput = {
    AND?: Enumerable<CafeRealImageScalarWhereInput>
    OR?: Enumerable<CafeRealImageScalarWhereInput>
    NOT?: Enumerable<CafeRealImageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    priority?: IntFilter | number
    isDisable?: BoolFilter | boolean
    cafeInfoId?: IntFilter | number
  }

  export type CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    update: XOR<CafeCouponGoupPartnerUpdateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    data: XOR<CafeCouponGoupPartnerUpdateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerScalarWhereInput
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupPartnersInput>
  }

  export type CafeCouponGoupPartnerScalarWhereInput = {
    AND?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
    OR?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
    NOT?: Enumerable<CafeCouponGoupPartnerScalarWhereInput>
    cafeCouponGroupId?: IntFilter | number
    cafeInfoId?: IntFilter | number
  }

  export type CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeBoardWhereUniqueInput
    update: XOR<CafeBoardUpdateWithoutCafeInfoInput, CafeBoardUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeBoardWhereUniqueInput
    data: XOR<CafeBoardUpdateWithoutCafeInfoInput, CafeBoardUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeBoardUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeBoardScalarWhereInput
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyWithoutCafeBoardsInput>
  }

  export type MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: MetaViewerInfoWhereUniqueInput
    update: XOR<MetaViewerInfoUpdateWithoutCafeInfoInput, MetaViewerInfoUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>
  }

  export type MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: MetaViewerInfoWhereUniqueInput
    data: XOR<MetaViewerInfoUpdateWithoutCafeInfoInput, MetaViewerInfoUncheckedUpdateWithoutCafeInfoInput>
  }

  export type MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput = {
    where: MetaViewerInfoScalarWhereInput
    data: XOR<MetaViewerInfoUpdateManyMutationInput, MetaViewerInfoUncheckedUpdateManyWithoutMetaViewerInfosInput>
  }

  export type MetaViewerInfoScalarWhereInput = {
    AND?: Enumerable<MetaViewerInfoScalarWhereInput>
    OR?: Enumerable<MetaViewerInfoScalarWhereInput>
    NOT?: Enumerable<MetaViewerInfoScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    code?: StringFilter | string
    isDisable?: BoolFilter | boolean
    worldData?: JsonFilter
    cafeInfoId?: IntFilter | number
  }

  export type ProductUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCafeInfoInput, ProductUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCafeInfoInput, ProductUncheckedUpdateWithoutCafeInfoInput>
  }

  export type ProductUpdateManyWithWhereWithoutCafeInfoInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    code?: StringFilter | string
    description?: StringNullableFilter | string | null
    price?: IntFilter | number
    originalPrice?: IntNullableFilter | number | null
    stockQuantity?: IntFilter | number
    minOrderQuantity?: IntFilter | number
    isDisable?: BoolFilter | boolean
    isAvailable?: BoolFilter | boolean
    categoryId?: IntFilter | number
    cafeInfoId?: IntNullableFilter | number | null
    productRedirectUrl?: StringNullableFilter | string | null
    isSignature?: BoolFilter | boolean
  }

  export type CafeInfoCreateWithoutCafeThumbnailImagesInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeThumbnailImagesInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
  }

  export type CafeInfoUpsertWithoutCafeThumbnailImagesInput = {
    update: XOR<CafeInfoUpdateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput>
    create: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
  }

  export type CafeInfoUpdateWithoutCafeThumbnailImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutCafeVirtualImagesInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeVirtualImagesInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
  }

  export type CafeInfoUpsertWithoutCafeVirtualImagesInput = {
    update: XOR<CafeInfoUpdateWithoutCafeVirtualImagesInput, CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput>
    create: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
  }

  export type CafeInfoUpdateWithoutCafeVirtualImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutCafeRealImagesInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeRealImagesInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeRealImagesInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
  }

  export type CafeInfoUpsertWithoutCafeRealImagesInput = {
    update: XOR<CafeInfoUpdateWithoutCafeRealImagesInput, CafeInfoUncheckedUpdateWithoutCafeRealImagesInput>
    create: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
  }

  export type CafeInfoUpdateWithoutCafeRealImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeRealImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutCafeVirtualLinksInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeVirtualLinksInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
  }

  export type CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
  }

  export type CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
  }

  export type CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput = {
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
    create: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
  }

  export type CafeInfoUpsertWithoutCafeVirtualLinksInput = {
    update: XOR<CafeInfoUpdateWithoutCafeVirtualLinksInput, CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput>
    create: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
  }

  export type CafeInfoUpdateWithoutCafeVirtualLinksInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeVirtualLinkThumbnailImageUpsertWithoutCafeVirtualLinkInput = {
    update: XOR<CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
    create: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
  }

  export type CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput = {
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeVirtualLinksInput
  }

  export type CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualLinkCreateOrConnectWithoutCafeVirtualLinkThumbnailImageInput = {
    where: CafeVirtualLinkWhereUniqueInput
    create: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
  }

  export type CafeVirtualLinkUpsertWithoutCafeVirtualLinkThumbnailImageInput = {
    update: XOR<CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput>
    create: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
  }

  export type CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeVirtualLinksNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponCreateWithoutCafeCouponGroupInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutCafeCouponGroupInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutCafeCouponGroupInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponCreateManyCafeCouponGroupInputEnvelope = {
    data: Enumerable<CafeCouponCreateManyCafeCouponGroupInput>
    skipDuplicates?: boolean
  }

  export type CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput = {
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeCouponGroupPartnersInput
  }

  export type CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput = {
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope = {
    data: Enumerable<CafeCouponGoupPartnerCreateManyCafeCouponGroupInput>
    skipDuplicates?: boolean
  }

  export type CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponWhereUniqueInput
    update: XOR<CafeCouponUpdateWithoutCafeCouponGroupInput, CafeCouponUncheckedUpdateWithoutCafeCouponGroupInput>
    create: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponWhereUniqueInput
    data: XOR<CafeCouponUpdateWithoutCafeCouponGroupInput, CafeCouponUncheckedUpdateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput = {
    where: CafeCouponScalarWhereInput
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyWithoutCafeCouponsInput>
  }

  export type CafeCouponScalarWhereInput = {
    AND?: Enumerable<CafeCouponScalarWhereInput>
    OR?: Enumerable<CafeCouponScalarWhereInput>
    NOT?: Enumerable<CafeCouponScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    content?: StringFilter | string
    serialNumber?: StringFilter | string
    startDay?: DateTimeFilter | Date | string
    endDay?: DateTimeNullableFilter | Date | string | null
    isDisable?: BoolFilter | boolean
    proxyUserId?: IntFilter | number
    cafeCouponGroupId?: IntFilter | number
  }

  export type CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    update: XOR<CafeCouponGoupPartnerUpdateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeCouponGroupInput>
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    data: XOR<CafeCouponGoupPartnerUpdateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerScalarWhereInput
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput = {
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupCreateOrConnectWithoutCafeCouponGoupPartnersInput = {
    where: CafeCouponGroupWhereUniqueInput
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeInfoCreateWithoutCafeCouponGroupPartnersInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeCouponGroupPartnersInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
  }

  export type CafeCouponGroupUpsertWithoutCafeCouponGoupPartnersInput = {
    update: XOR<CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput>
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeInfoUpsertWithoutCafeCouponGroupPartnersInput = {
    update: XOR<CafeInfoUpdateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput>
    create: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
  }

  export type CafeInfoUpdateWithoutCafeCouponGroupPartnersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type UserCreateWithoutProxyUsersInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutProxyUsersInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutProxyUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
  }

  export type CafeCouponCreateWithoutProxyUserInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutProxyUserInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    cafeCouponGroupId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutProxyUserInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput>
  }

  export type CafeCouponCreateManyProxyUserInputEnvelope = {
    data: Enumerable<CafeCouponCreateManyProxyUserInput>
    skipDuplicates?: boolean
  }

  export type WishlistProductCreateWithoutProxyUserInput = {
    createdAt?: Date | string
    Product: ProductCreateNestedOneWithoutWishlistProductsInput
  }

  export type WishlistProductUncheckedCreateWithoutProxyUserInput = {
    id?: number
    createdAt?: Date | string
    productId: number
  }

  export type WishlistProductCreateOrConnectWithoutProxyUserInput = {
    where: WishlistProductWhereUniqueInput
    create: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput>
  }

  export type WishlistProductCreateManyProxyUserInputEnvelope = {
    data: Enumerable<WishlistProductCreateManyProxyUserInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProxyUsersInput = {
    update: XOR<UserUpdateWithoutProxyUsersInput, UserUncheckedUpdateWithoutProxyUsersInput>
    create: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
  }

  export type UserUpdateWithoutProxyUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutProxyUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput = {
    where: CafeCouponWhereUniqueInput
    update: XOR<CafeCouponUpdateWithoutProxyUserInput, CafeCouponUncheckedUpdateWithoutProxyUserInput>
    create: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput>
  }

  export type CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput = {
    where: CafeCouponWhereUniqueInput
    data: XOR<CafeCouponUpdateWithoutProxyUserInput, CafeCouponUncheckedUpdateWithoutProxyUserInput>
  }

  export type CafeCouponUpdateManyWithWhereWithoutProxyUserInput = {
    where: CafeCouponScalarWhereInput
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyWithoutCafeCouponsInput>
  }

  export type WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput = {
    where: WishlistProductWhereUniqueInput
    update: XOR<WishlistProductUpdateWithoutProxyUserInput, WishlistProductUncheckedUpdateWithoutProxyUserInput>
    create: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput>
  }

  export type WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput = {
    where: WishlistProductWhereUniqueInput
    data: XOR<WishlistProductUpdateWithoutProxyUserInput, WishlistProductUncheckedUpdateWithoutProxyUserInput>
  }

  export type WishlistProductUpdateManyWithWhereWithoutProxyUserInput = {
    where: WishlistProductScalarWhereInput
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyWithoutWishlistProductsInput>
  }

  export type WishlistProductScalarWhereInput = {
    AND?: Enumerable<WishlistProductScalarWhereInput>
    OR?: Enumerable<WishlistProductScalarWhereInput>
    NOT?: Enumerable<WishlistProductScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    productId?: IntFilter | number
    proxyUserId?: IntFilter | number
  }

  export type ProxyUserCreateWithoutCafeCouponsInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    User?: UserCreateNestedOneWithoutProxyUsersInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateWithoutCafeCouponsInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    userId?: number | null
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserCreateOrConnectWithoutCafeCouponsInput = {
    where: ProxyUserWhereUniqueInput
    create: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
  }

  export type CafeCouponGroupCreateWithoutCafeCouponsInput = {
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupCreateOrConnectWithoutCafeCouponsInput = {
    where: CafeCouponGroupWhereUniqueInput
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
  }

  export type CafeCouponQRCodeCreateWithoutCafeCouponInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput = {
    where: CafeCouponQRCodeWhereUniqueInput
    create: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeCreateManyCafeCouponInputEnvelope = {
    data: Enumerable<CafeCouponQRCodeCreateManyCafeCouponInput>
    skipDuplicates?: boolean
  }

  export type CafeCouponHistoryCreateWithoutCafeCouponInput = {
    createdAt?: Date | string
    eventType: CafeCouponEventType
    description: string
    Actor: UserCreateNestedOneWithoutCafeCouponHistoriesInput
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput = {
    id?: number
    createdAt?: Date | string
    eventType: CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput = {
    where: CafeCouponHistoryWhereUniqueInput
    create: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponHistoryCreateManyCafeCouponInputEnvelope = {
    data: Enumerable<CafeCouponHistoryCreateManyCafeCouponInput>
    skipDuplicates?: boolean
  }

  export type ProxyUserUpsertWithoutCafeCouponsInput = {
    update: XOR<ProxyUserUpdateWithoutCafeCouponsInput, ProxyUserUncheckedUpdateWithoutCafeCouponsInput>
    create: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
  }

  export type ProxyUserUpdateWithoutCafeCouponsInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutProxyUsersNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateWithoutCafeCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type CafeCouponGroupUpsertWithoutCafeCouponsInput = {
    update: XOR<CafeCouponGroupUpdateWithoutCafeCouponsInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput>
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
  }

  export type CafeCouponGroupUpdateWithoutCafeCouponsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponQRCodeWhereUniqueInput
    update: XOR<CafeCouponQRCodeUpdateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedUpdateWithoutCafeCouponInput>
    create: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponQRCodeWhereUniqueInput
    data: XOR<CafeCouponQRCodeUpdateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedUpdateWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput = {
    where: CafeCouponQRCodeScalarWhereInput
    data: XOR<CafeCouponQRCodeUpdateManyMutationInput, CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponQRCodesInput>
  }

  export type CafeCouponQRCodeScalarWhereInput = {
    AND?: Enumerable<CafeCouponQRCodeScalarWhereInput>
    OR?: Enumerable<CafeCouponQRCodeScalarWhereInput>
    NOT?: Enumerable<CafeCouponQRCodeScalarWhereInput>
    serialNumber?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    isDisable?: BoolFilter | boolean
    cafeCouponId?: IntNullableFilter | number | null
    size?: IntFilter | number
    base64Data?: StringFilter | string
  }

  export type CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponHistoryWhereUniqueInput
    update: XOR<CafeCouponHistoryUpdateWithoutCafeCouponInput, CafeCouponHistoryUncheckedUpdateWithoutCafeCouponInput>
    create: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponHistoryWhereUniqueInput
    data: XOR<CafeCouponHistoryUpdateWithoutCafeCouponInput, CafeCouponHistoryUncheckedUpdateWithoutCafeCouponInput>
  }

  export type CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput = {
    where: CafeCouponHistoryScalarWhereInput
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponCreateWithoutCafeCouponHistoriesInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutCafeCouponHistoriesInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
  }

  export type UserCreateWithoutCafeCouponHistoriesInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCafeCouponHistoriesInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: LoginType
    userType: UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCafeCouponHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponUpsertWithoutCafeCouponHistoriesInput = {
    update: XOR<CafeCouponUpdateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput>
    create: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponUpdateWithoutCafeCouponHistoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type UserUpsertWithoutCafeCouponHistoriesInput = {
    update: XOR<UserUpdateWithoutCafeCouponHistoriesInput, UserUncheckedUpdateWithoutCafeCouponHistoriesInput>
    create: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
  }

  export type UserUpdateWithoutCafeCouponHistoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCafeCouponHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CafeCouponCreateWithoutCafeCouponQRCodesInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutCafeCouponQRCodesInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
  }

  export type CafeCouponUpsertWithoutCafeCouponQRCodesInput = {
    update: XOR<CafeCouponUpdateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput>
    create: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
  }

  export type CafeCouponUpdateWithoutCafeCouponQRCodesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeInfoCreateWithoutMetaViewerInfosInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutMetaViewerInfosInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutMetaViewerInfosInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
  }

  export type MetaViewerMapCreateWithoutMetaViewerInfoInput = {
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    ActiveRenderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput = {
    id?: number
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    ActiveRenderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput = {
    where: MetaViewerMapWhereUniqueInput
    create: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapCreateManyMetaViewerInfoInputEnvelope = {
    data: Enumerable<MetaViewerMapCreateManyMetaViewerInfoInput>
    skipDuplicates?: boolean
  }

  export type MetaViewerActiveMapCreateWithoutMetaViewerInfoInput = {
    updatedAt?: Date | string
    ActiveRenderMap: MetaViewerMapCreateNestedOneWithoutActiveRenderForInput
    ActiveColliderMap: MetaViewerMapCreateNestedOneWithoutActiveColliderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput = {
    id?: number
    updatedAt?: Date | string
    activeRenderMapId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    create: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type CafeInfoUpsertWithoutMetaViewerInfosInput = {
    update: XOR<CafeInfoUpdateWithoutMetaViewerInfosInput, CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput>
    create: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
  }

  export type CafeInfoUpdateWithoutMetaViewerInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput = {
    where: MetaViewerMapWhereUniqueInput
    update: XOR<MetaViewerMapUpdateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedUpdateWithoutMetaViewerInfoInput>
    create: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput = {
    where: MetaViewerMapWhereUniqueInput
    data: XOR<MetaViewerMapUpdateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput = {
    where: MetaViewerMapScalarWhereInput
    data: XOR<MetaViewerMapUpdateManyMutationInput, MetaViewerMapUncheckedUpdateManyWithoutMetaViewerMapsInput>
  }

  export type MetaViewerMapScalarWhereInput = {
    AND?: Enumerable<MetaViewerMapScalarWhereInput>
    OR?: Enumerable<MetaViewerMapScalarWhereInput>
    NOT?: Enumerable<MetaViewerMapScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    type?: EnumMetaMapTypeFilter | MetaMapType
    version?: FloatFilter | number
    url?: StringFilter | string
    size?: IntFilter | number
    contentKey?: StringNullableFilter | string | null
    isDraco?: BoolFilter | boolean
    metaViewerInfoId?: IntFilter | number
  }

  export type MetaViewerActiveMapUpsertWithoutMetaViewerInfoInput = {
    update: XOR<MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
    create: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActiveRenderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput
    ActiveColliderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerInfoCreateWithoutMetaViewerMapsInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    CafeInfo: CafeInfoCreateNestedOneWithoutMetaViewerInfosInput
    ActiveMaps?: MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
    ActiveMaps?: MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoCreateOrConnectWithoutMetaViewerMapsInput = {
    where: MetaViewerInfoWhereUniqueInput
    create: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
  }

  export type MetaViewerActiveMapCreateWithoutActiveRenderMapInput = {
    updatedAt?: Date | string
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutActiveMapsInput
    ActiveColliderMap: MetaViewerMapCreateNestedOneWithoutActiveColliderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    create: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope = {
    data: Enumerable<MetaViewerActiveMapCreateManyActiveRenderMapInput>
    skipDuplicates?: boolean
  }

  export type MetaViewerActiveMapCreateWithoutActiveColliderMapInput = {
    updatedAt?: Date | string
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutActiveMapsInput
    ActiveRenderMap: MetaViewerMapCreateNestedOneWithoutActiveRenderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
  }

  export type MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    create: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>
  }

  export type MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope = {
    data: Enumerable<MetaViewerActiveMapCreateManyActiveColliderMapInput>
    skipDuplicates?: boolean
  }

  export type MetaViewerInfoUpsertWithoutMetaViewerMapsInput = {
    update: XOR<MetaViewerInfoUpdateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput>
    create: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
  }

  export type MetaViewerInfoUpdateWithoutMetaViewerMapsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput
    ActiveMaps?: MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    ActiveMaps?: MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    update: XOR<MetaViewerActiveMapUpdateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveRenderMapInput>
    create: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    data: XOR<MetaViewerActiveMapUpdateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapScalarWhereInput
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderForInput>
  }

  export type MetaViewerActiveMapScalarWhereInput = {
    AND?: Enumerable<MetaViewerActiveMapScalarWhereInput>
    OR?: Enumerable<MetaViewerActiveMapScalarWhereInput>
    NOT?: Enumerable<MetaViewerActiveMapScalarWhereInput>
    id?: IntFilter | number
    updatedAt?: DateTimeFilter | Date | string
    metaViewerInfoId?: IntFilter | number
    activeRenderMapId?: IntFilter | number
    activeColliderMapId?: IntFilter | number
  }

  export type MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    update: XOR<MetaViewerActiveMapUpdateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveColliderMapInput>
    create: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>
  }

  export type MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    data: XOR<MetaViewerActiveMapUpdateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveColliderMapInput>
  }

  export type MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapScalarWhereInput
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderForInput>
  }

  export type MetaViewerInfoCreateWithoutActiveMapsInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    CafeInfo: CafeInfoCreateNestedOneWithoutMetaViewerInfosInput
    MetaViewerMaps?: MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateWithoutActiveMapsInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
    MetaViewerMaps?: MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoCreateOrConnectWithoutActiveMapsInput = {
    where: MetaViewerInfoWhereUniqueInput
    create: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
  }

  export type MetaViewerMapCreateWithoutActiveRenderForInput = {
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput
    ActiveColliderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUncheckedCreateWithoutActiveRenderForInput = {
    id?: number
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
    ActiveColliderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapCreateOrConnectWithoutActiveRenderForInput = {
    where: MetaViewerMapWhereUniqueInput
    create: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
  }

  export type MetaViewerMapCreateWithoutActiveColliderForInput = {
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput
    ActiveRenderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput
  }

  export type MetaViewerMapUncheckedCreateWithoutActiveColliderForInput = {
    id?: number
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput
  }

  export type MetaViewerMapCreateOrConnectWithoutActiveColliderForInput = {
    where: MetaViewerMapWhereUniqueInput
    create: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
  }

  export type MetaViewerInfoUpsertWithoutActiveMapsInput = {
    update: XOR<MetaViewerInfoUpdateWithoutActiveMapsInput, MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput>
    create: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
  }

  export type MetaViewerInfoUpdateWithoutActiveMapsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput
    MetaViewerMaps?: MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    MetaViewerMaps?: MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerMapUpsertWithoutActiveRenderForInput = {
    update: XOR<MetaViewerMapUpdateWithoutActiveRenderForInput, MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput>
    create: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
  }

  export type MetaViewerMapUpdateWithoutActiveRenderForInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    ActiveColliderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUpsertWithoutActiveColliderForInput = {
    update: XOR<MetaViewerMapUpdateWithoutActiveColliderForInput, MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput>
    create: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
  }

  export type MetaViewerMapUpdateWithoutActiveColliderForInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput
    ActiveRenderFor?: MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput
  }

  export type ClosureProductCategoryCreateWithoutAncestorCategoryInput = {
    depth?: number
    DescendantCategory: ProductCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    create: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope = {
    data: Enumerable<ClosureProductCategoryCreateManyAncestorCategoryInput>
    skipDuplicates?: boolean
  }

  export type ClosureProductCategoryCreateWithoutDescendantCategoryInput = {
    depth?: number
    AncestorCategory: ProductCategoryCreateNestedOneWithoutAncestorCategoriesInput
  }

  export type ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    create: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope = {
    data: Enumerable<ClosureProductCategoryCreateManyDescendantCategoryInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutProductCategoryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    cafeInfoId?: number | null
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductCreateManyProductCategoryInputEnvelope = {
    data: Enumerable<ProductCreateManyProductCategoryInput>
    skipDuplicates?: boolean
  }

  export type ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    update: XOR<ClosureProductCategoryUpdateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutAncestorCategoryInput>
    create: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    data: XOR<ClosureProductCategoryUpdateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryScalarWhereInput
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoriesInput>
  }

  export type ClosureProductCategoryScalarWhereInput = {
    AND?: Enumerable<ClosureProductCategoryScalarWhereInput>
    OR?: Enumerable<ClosureProductCategoryScalarWhereInput>
    NOT?: Enumerable<ClosureProductCategoryScalarWhereInput>
    ancestor?: IntFilter | number
    descendant?: IntFilter | number
    depth?: IntFilter | number
  }

  export type ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    update: XOR<ClosureProductCategoryUpdateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutDescendantCategoryInput>
    create: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    data: XOR<ClosureProductCategoryUpdateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutDescendantCategoryInput>
  }

  export type ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryScalarWhereInput
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoriesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutAncestorCategoriesInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    DescendantCategories?: ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    DescendantCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutAncestorCategoriesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
  }

  export type ProductCategoryCreateWithoutDescendantCategoriesInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput
    Products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    Products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutDescendantCategoriesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
  }

  export type ProductCategoryUpsertWithoutAncestorCategoriesInput = {
    update: XOR<ProductCategoryUpdateWithoutAncestorCategoriesInput, ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
    create: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
  }

  export type ProductCategoryUpdateWithoutAncestorCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    DescendantCategories?: ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    DescendantCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUpsertWithoutDescendantCategoriesInput = {
    update: XOR<ProductCategoryUpdateWithoutDescendantCategoriesInput, ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
    create: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
  }

  export type ProductCategoryUpdateWithoutDescendantCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput
    Products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    Products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CafeInfoCreateWithoutProductsInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutProductsInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutProductsInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
  }

  export type WishlistProductCreateWithoutProductInput = {
    createdAt?: Date | string
    ProxyUser: ProxyUserCreateNestedOneWithoutWishlistProductsInput
  }

  export type WishlistProductUncheckedCreateWithoutProductInput = {
    id?: number
    createdAt?: Date | string
    proxyUserId: number
  }

  export type WishlistProductCreateOrConnectWithoutProductInput = {
    where: WishlistProductWhereUniqueInput
    create: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput>
  }

  export type WishlistProductCreateManyProductInputEnvelope = {
    data: Enumerable<WishlistProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: Enumerable<ProductImageCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type CafeInfoUpsertWithoutProductsInput = {
    update: XOR<CafeInfoUpdateWithoutProductsInput, CafeInfoUncheckedUpdateWithoutProductsInput>
    create: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
  }

  export type CafeInfoUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type WishlistProductUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistProductWhereUniqueInput
    update: XOR<WishlistProductUpdateWithoutProductInput, WishlistProductUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput>
  }

  export type WishlistProductUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistProductWhereUniqueInput
    data: XOR<WishlistProductUpdateWithoutProductInput, WishlistProductUncheckedUpdateWithoutProductInput>
  }

  export type WishlistProductUpdateManyWithWhereWithoutProductInput = {
    where: WishlistProductScalarWhereInput
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyWithoutWishlistProductsInput>
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductImagesInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: Enumerable<ProductImageScalarWhereInput>
    OR?: Enumerable<ProductImageScalarWhereInput>
    NOT?: Enumerable<ProductImageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    url?: StringFilter | string
    thumbnailUrl?: StringFilter | string
    width?: IntFilter | number
    height?: IntFilter | number
    size?: IntFilter | number
    isDisable?: BoolFilter | boolean
    isThumb?: BoolFilter | boolean
    productId?: IntFilter | number
  }

  export type ProductCreateWithoutWishlistProductsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUncheckedCreateWithoutWishlistProductsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductCreateOrConnectWithoutWishlistProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
  }

  export type ProxyUserCreateWithoutWishlistProductsInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    User?: UserCreateNestedOneWithoutProxyUsersInput
    CafeCoupons?: CafeCouponCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateWithoutWishlistProductsInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
    userId?: number | null
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserCreateOrConnectWithoutWishlistProductsInput = {
    where: ProxyUserWhereUniqueInput
    create: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
  }

  export type ProductUpsertWithoutWishlistProductsInput = {
    update: XOR<ProductUpdateWithoutWishlistProductsInput, ProductUncheckedUpdateWithoutWishlistProductsInput>
    create: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
  }

  export type ProductUpdateWithoutWishlistProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateWithoutWishlistProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProxyUserUpsertWithoutWishlistProductsInput = {
    update: XOR<ProxyUserUpdateWithoutWishlistProductsInput, ProxyUserUncheckedUpdateWithoutWishlistProductsInput>
    create: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
  }

  export type ProxyUserUpdateWithoutWishlistProductsInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutProxyUsersNestedInput
    CafeCoupons?: CafeCouponUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateWithoutWishlistProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type ProductCreateWithoutProductImagesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUncheckedCreateWithoutProductImagesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductCreateOrConnectWithoutProductImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductUpsertWithoutProductImagesInput = {
    update: XOR<ProductUpdateWithoutProductImagesInput, ProductUncheckedUpdateWithoutProductImagesInput>
    create: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductUpdateWithoutProductImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: BoardType
  }

  export type BoardReplyCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    boardId: number
    boardReplyId?: number | null
  }

  export type NoticeCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
  }

  export type ProxyUserCreateManyUserInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: ProxyUserType
    name: string
    token: string
  }

  export type CafeCouponHistoryCreateManyActorInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: CafeCouponEventType
    description: string
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type BoardUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | BoardType
  }

  export type BoardReplyUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoticeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateManyWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProxyUserUpdateWithoutUserInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    CafeCoupons?: CafeCouponUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateManyWithoutProxyUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponHistoryUpdateWithoutActorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupon?: CafeCouponUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type BoardImageCreateManyBoardInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
  }

  export type BoardReplyCreateManyBoardInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardReplyId?: number | null
  }

  export type CafeBoardCreateManyBoardInput = {
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type BoardImageUpdateWithoutBoardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardImageUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardImageUncheckedUpdateManyWithoutBoardImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardReplyUpdateWithoutBoardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type CafeBoardUpdateWithoutBoardInput = {
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeBoardsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateWithoutBoardInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateManyWithoutCafeBoardsInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardReplyCreateManyBoardReplyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
  }

  export type BoardReplyUpdateWithoutBoardReplyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutBoardReplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardNestedRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeInfoCreateManyRegionCategoryInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
  }

  export type ClosureRegionCategoryCreateManyAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryCreateManyDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type CafeInfoUpdateWithoutRegionCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutRegionCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateManyWithoutCafeInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
  }

  export type ClosureRegionCategoryUpdateWithoutAncestorCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    DescendantCategory?: RegionCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureRegionCategoryUncheckedUpdateWithoutAncestorCategoryInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoriesInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUpdateWithoutDescendantCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: RegionCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
  }

  export type ClosureRegionCategoryUncheckedUpdateWithoutDescendantCategoryInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoriesInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
  }

  export type CafeThumbnailImageCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeVirtualImageCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeRealImageCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeCouponGoupPartnerCreateManyCafeInfoInput = {
    cafeCouponGroupId: number
  }

  export type CafeBoardCreateManyCafeInfoInput = {
    boardId: number
    createdAt?: Date | string
  }

  export type MetaViewerInfoCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
  }

  export type ProductCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type CafeVirtualLinkUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateManyWithoutCafeVirtualLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUncheckedUpdateManyWithoutCafeThumbnailImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUncheckedUpdateManyWithoutCafeVirtualImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUncheckedUpdateManyWithoutCafeRealImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeCouponGoupPartnerUpdateWithoutCafeInfoInput = {
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponGoupPartnersNestedInput
  }

  export type CafeCouponGoupPartnerUncheckedUpdateWithoutCafeInfoInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupPartnersInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeBoardUpdateWithoutCafeInfoInput = {
    Board?: BoardUpdateOneRequiredWithoutCafeBoardsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateWithoutCafeInfoInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaViewerInfoUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateManyWithoutMetaViewerInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeCouponCreateManyCafeCouponGroupInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
  }

  export type CafeCouponGoupPartnerCreateManyCafeCouponGroupInput = {
    cafeInfoId: number
  }

  export type CafeCouponUpdateWithoutCafeCouponGroupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutCafeCouponGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateManyWithoutCafeCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerUpdateWithoutCafeCouponGroupInput = {
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeCouponGroupPartnersNestedInput
  }

  export type CafeCouponGoupPartnerUncheckedUpdateWithoutCafeCouponGroupInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGoupPartnersInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponCreateManyProxyUserInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    cafeCouponGroupId: number
  }

  export type WishlistProductCreateManyProxyUserInput = {
    id?: number
    createdAt?: Date | string
    productId: number
  }

  export type CafeCouponUpdateWithoutProxyUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutProxyUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type WishlistProductUpdateWithoutProxyUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutWishlistProductsNestedInput
  }

  export type WishlistProductUncheckedUpdateWithoutProxyUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistProductUncheckedUpdateManyWithoutWishlistProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponQRCodeCreateManyCafeCouponInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
  }

  export type CafeCouponHistoryCreateManyCafeCouponInput = {
    id?: number
    createdAt?: Date | string
    eventType: CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: CafeCouponStatus | null
    statusAfter?: CafeCouponStatus | null
  }

  export type CafeCouponQRCodeUpdateWithoutCafeCouponInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateWithoutCafeCouponInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponQRCodesInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponHistoryUpdateWithoutCafeCouponInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    Actor?: UserUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateWithoutCafeCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | CafeCouponStatus | null
  }

  export type MetaViewerMapCreateManyMetaViewerInfoInput = {
    id?: number
    createdAt?: Date | string
    type: MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
  }

  export type MetaViewerMapUpdateWithoutMetaViewerInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    ActiveRenderFor?: MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateWithoutMetaViewerInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    ActiveRenderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateManyWithoutMetaViewerMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MetaViewerActiveMapCreateManyActiveRenderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapCreateManyActiveColliderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
  }

  export type MetaViewerActiveMapUpdateWithoutActiveRenderMapInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput
    ActiveColliderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateWithoutActiveRenderMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderForInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapUpdateWithoutActiveColliderMapInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput
    ActiveRenderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateWithoutActiveColliderMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderForInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryCreateManyAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryCreateManyDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type ProductCreateManyProductCategoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ClosureProductCategoryUpdateWithoutAncestorCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    DescendantCategory?: ProductCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureProductCategoryUncheckedUpdateWithoutAncestorCategoryInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoriesInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUpdateWithoutDescendantCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: ProductCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
  }

  export type ClosureProductCategoryUncheckedUpdateWithoutDescendantCategoryInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoriesInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WishlistProductCreateManyProductInput = {
    id?: number
    createdAt?: Date | string
    proxyUserId: number
  }

  export type ProductImageCreateManyProductInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
  }

  export type WishlistProductUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutWishlistProductsNestedInput
  }

  export type WishlistProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateManyWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}