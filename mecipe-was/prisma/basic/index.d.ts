
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model BoardImage
 * 
 */
export type BoardImage = $Result.DefaultSelection<Prisma.$BoardImagePayload>
/**
 * Model BoardReply
 * 
 */
export type BoardReply = $Result.DefaultSelection<Prisma.$BoardReplyPayload>
/**
 * Model CafeBoard
 * 
 */
export type CafeBoard = $Result.DefaultSelection<Prisma.$CafeBoardPayload>
/**
 * Model RegionCategory
 * 
 */
export type RegionCategory = $Result.DefaultSelection<Prisma.$RegionCategoryPayload>
/**
 * Model ClosureRegionCategory
 * 
 */
export type ClosureRegionCategory = $Result.DefaultSelection<Prisma.$ClosureRegionCategoryPayload>
/**
 * Model CafeInfo
 * 
 */
export type CafeInfo = $Result.DefaultSelection<Prisma.$CafeInfoPayload>
/**
 * Model CafeThumbnailImage
 * 
 */
export type CafeThumbnailImage = $Result.DefaultSelection<Prisma.$CafeThumbnailImagePayload>
/**
 * Model CafeVirtualImage
 * 
 */
export type CafeVirtualImage = $Result.DefaultSelection<Prisma.$CafeVirtualImagePayload>
/**
 * Model CafeRealImage
 * 
 */
export type CafeRealImage = $Result.DefaultSelection<Prisma.$CafeRealImagePayload>
/**
 * Model CafeVirtualLink
 * 
 */
export type CafeVirtualLink = $Result.DefaultSelection<Prisma.$CafeVirtualLinkPayload>
/**
 * Model CafeVirtualLinkThumbnailImage
 * 
 */
export type CafeVirtualLinkThumbnailImage = $Result.DefaultSelection<Prisma.$CafeVirtualLinkThumbnailImagePayload>
/**
 * Model CafeCouponGroup
 * 
 */
export type CafeCouponGroup = $Result.DefaultSelection<Prisma.$CafeCouponGroupPayload>
/**
 * Model CafeCouponGoupPartner
 * 
 */
export type CafeCouponGoupPartner = $Result.DefaultSelection<Prisma.$CafeCouponGoupPartnerPayload>
/**
 * Model ProxyUser
 * 
 */
export type ProxyUser = $Result.DefaultSelection<Prisma.$ProxyUserPayload>
/**
 * Model CafeCoupon
 * 
 */
export type CafeCoupon = $Result.DefaultSelection<Prisma.$CafeCouponPayload>
/**
 * Model CafeCouponHistory
 * 
 */
export type CafeCouponHistory = $Result.DefaultSelection<Prisma.$CafeCouponHistoryPayload>
/**
 * Model CafeCouponQRCode
 * 
 */
export type CafeCouponQRCode = $Result.DefaultSelection<Prisma.$CafeCouponQRCodePayload>
/**
 * Model MetaViewerInfo
 * 
 */
export type MetaViewerInfo = $Result.DefaultSelection<Prisma.$MetaViewerInfoPayload>
/**
 * Model MetaViewerMap
 * 
 */
export type MetaViewerMap = $Result.DefaultSelection<Prisma.$MetaViewerMapPayload>
/**
 * Model MetaViewerActiveMap
 * 
 */
export type MetaViewerActiveMap = $Result.DefaultSelection<Prisma.$MetaViewerActiveMapPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ClosureProductCategory
 * 
 */
export type ClosureProductCategory = $Result.DefaultSelection<Prisma.$ClosureProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model WishlistProduct
 * 
 */
export type WishlistProduct = $Result.DefaultSelection<Prisma.$WishlistProductPayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LoginType: {
  LOCAL: 'LOCAL',
  ADMIN: 'ADMIN',
  KAKAO: 'KAKAO',
  NAVER: 'NAVER',
  GOOGLE: 'GOOGLE',
  APPLE: 'APPLE',
  ZEPETO: 'ZEPETO'
};

export type LoginType = (typeof LoginType)[keyof typeof LoginType]


export const UserType: {
  GENERAL: 'GENERAL',
  BUSINESS: 'BUSINESS',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const BoardType: {
  BTALK: 'BTALK',
  BINFORM: 'BINFORM',
  BQUESTION: 'BQUESTION',
  BEVENT: 'BEVENT'
};

export type BoardType = (typeof BoardType)[keyof typeof BoardType]


export const GovermentType: {
  SPECIAL_CITY: 'SPECIAL_CITY',
  METROPOLITAN_CITY: 'METROPOLITAN_CITY',
  SPECIAL_SELF_GOVERNING_CITY: 'SPECIAL_SELF_GOVERNING_CITY',
  PROVINCE: 'PROVINCE',
  SPECIAL_SELF_GOVERNING_PROVINCE: 'SPECIAL_SELF_GOVERNING_PROVINCE',
  DISTRICT: 'DISTRICT',
  CITY: 'CITY',
  COUNTY: 'COUNTY',
  TOWN: 'TOWN',
  TOWNSHIP: 'TOWNSHIP',
  NEIGHBORHOOD: 'NEIGHBORHOOD',
  PLACENAME: 'PLACENAME'
};

export type GovermentType = (typeof GovermentType)[keyof typeof GovermentType]


export const ProxyUserType: {
  ETC: 'ETC',
  WEB: 'WEB',
  ZEPETO: 'ZEPETO',
  WEV_VIEWER: 'WEV_VIEWER'
};

export type ProxyUserType = (typeof ProxyUserType)[keyof typeof ProxyUserType]


export const CafeCouponEventType: {
  CREATED: 'CREATED',
  USED: 'USED',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED',
  UPDATE: 'UPDATE'
};

export type CafeCouponEventType = (typeof CafeCouponEventType)[keyof typeof CafeCouponEventType]


export const CafeCouponStatus: {
  ACTIVE: 'ACTIVE',
  USED: 'USED',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED'
};

export type CafeCouponStatus = (typeof CafeCouponStatus)[keyof typeof CafeCouponStatus]


export const MetaMapType: {
  RENDER: 'RENDER',
  COLLIDER: 'COLLIDER'
};

export type MetaMapType = (typeof MetaMapType)[keyof typeof MetaMapType]

}

export type LoginType = $Enums.LoginType

export const LoginType: typeof $Enums.LoginType

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type BoardType = $Enums.BoardType

export const BoardType: typeof $Enums.BoardType

export type GovermentType = $Enums.GovermentType

export const GovermentType: typeof $Enums.GovermentType

export type ProxyUserType = $Enums.ProxyUserType

export const ProxyUserType: typeof $Enums.ProxyUserType

export type CafeCouponEventType = $Enums.CafeCouponEventType

export const CafeCouponEventType: typeof $Enums.CafeCouponEventType

export type CafeCouponStatus = $Enums.CafeCouponStatus

export const CafeCouponStatus: typeof $Enums.CafeCouponStatus

export type MetaMapType = $Enums.MetaMapType

export const MetaMapType: typeof $Enums.MetaMapType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boardImage`: Exposes CRUD operations for the **BoardImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardImages
    * const boardImages = await prisma.boardImage.findMany()
    * ```
    */
  get boardImage(): Prisma.BoardImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boardReply`: Exposes CRUD operations for the **BoardReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardReplies
    * const boardReplies = await prisma.boardReply.findMany()
    * ```
    */
  get boardReply(): Prisma.BoardReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeBoard`: Exposes CRUD operations for the **CafeBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeBoards
    * const cafeBoards = await prisma.cafeBoard.findMany()
    * ```
    */
  get cafeBoard(): Prisma.CafeBoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regionCategory`: Exposes CRUD operations for the **RegionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionCategories
    * const regionCategories = await prisma.regionCategory.findMany()
    * ```
    */
  get regionCategory(): Prisma.RegionCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.closureRegionCategory`: Exposes CRUD operations for the **ClosureRegionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClosureRegionCategories
    * const closureRegionCategories = await prisma.closureRegionCategory.findMany()
    * ```
    */
  get closureRegionCategory(): Prisma.ClosureRegionCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeInfo`: Exposes CRUD operations for the **CafeInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeInfos
    * const cafeInfos = await prisma.cafeInfo.findMany()
    * ```
    */
  get cafeInfo(): Prisma.CafeInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeThumbnailImage`: Exposes CRUD operations for the **CafeThumbnailImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeThumbnailImages
    * const cafeThumbnailImages = await prisma.cafeThumbnailImage.findMany()
    * ```
    */
  get cafeThumbnailImage(): Prisma.CafeThumbnailImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeVirtualImage`: Exposes CRUD operations for the **CafeVirtualImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeVirtualImages
    * const cafeVirtualImages = await prisma.cafeVirtualImage.findMany()
    * ```
    */
  get cafeVirtualImage(): Prisma.CafeVirtualImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeRealImage`: Exposes CRUD operations for the **CafeRealImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeRealImages
    * const cafeRealImages = await prisma.cafeRealImage.findMany()
    * ```
    */
  get cafeRealImage(): Prisma.CafeRealImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeVirtualLink`: Exposes CRUD operations for the **CafeVirtualLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeVirtualLinks
    * const cafeVirtualLinks = await prisma.cafeVirtualLink.findMany()
    * ```
    */
  get cafeVirtualLink(): Prisma.CafeVirtualLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeVirtualLinkThumbnailImage`: Exposes CRUD operations for the **CafeVirtualLinkThumbnailImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeVirtualLinkThumbnailImages
    * const cafeVirtualLinkThumbnailImages = await prisma.cafeVirtualLinkThumbnailImage.findMany()
    * ```
    */
  get cafeVirtualLinkThumbnailImage(): Prisma.CafeVirtualLinkThumbnailImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeCouponGroup`: Exposes CRUD operations for the **CafeCouponGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponGroups
    * const cafeCouponGroups = await prisma.cafeCouponGroup.findMany()
    * ```
    */
  get cafeCouponGroup(): Prisma.CafeCouponGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeCouponGoupPartner`: Exposes CRUD operations for the **CafeCouponGoupPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponGoupPartners
    * const cafeCouponGoupPartners = await prisma.cafeCouponGoupPartner.findMany()
    * ```
    */
  get cafeCouponGoupPartner(): Prisma.CafeCouponGoupPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxyUser`: Exposes CRUD operations for the **ProxyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxyUsers
    * const proxyUsers = await prisma.proxyUser.findMany()
    * ```
    */
  get proxyUser(): Prisma.ProxyUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeCoupon`: Exposes CRUD operations for the **CafeCoupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCoupons
    * const cafeCoupons = await prisma.cafeCoupon.findMany()
    * ```
    */
  get cafeCoupon(): Prisma.CafeCouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeCouponHistory`: Exposes CRUD operations for the **CafeCouponHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponHistories
    * const cafeCouponHistories = await prisma.cafeCouponHistory.findMany()
    * ```
    */
  get cafeCouponHistory(): Prisma.CafeCouponHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeCouponQRCode`: Exposes CRUD operations for the **CafeCouponQRCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeCouponQRCodes
    * const cafeCouponQRCodes = await prisma.cafeCouponQRCode.findMany()
    * ```
    */
  get cafeCouponQRCode(): Prisma.CafeCouponQRCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metaViewerInfo`: Exposes CRUD operations for the **MetaViewerInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaViewerInfos
    * const metaViewerInfos = await prisma.metaViewerInfo.findMany()
    * ```
    */
  get metaViewerInfo(): Prisma.MetaViewerInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metaViewerMap`: Exposes CRUD operations for the **MetaViewerMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaViewerMaps
    * const metaViewerMaps = await prisma.metaViewerMap.findMany()
    * ```
    */
  get metaViewerMap(): Prisma.MetaViewerMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metaViewerActiveMap`: Exposes CRUD operations for the **MetaViewerActiveMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaViewerActiveMaps
    * const metaViewerActiveMaps = await prisma.metaViewerActiveMap.findMany()
    * ```
    */
  get metaViewerActiveMap(): Prisma.MetaViewerActiveMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.closureProductCategory`: Exposes CRUD operations for the **ClosureProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClosureProductCategories
    * const closureProductCategories = await prisma.closureProductCategory.findMany()
    * ```
    */
  get closureProductCategory(): Prisma.ClosureProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlistProduct`: Exposes CRUD operations for the **WishlistProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistProducts
    * const wishlistProducts = await prisma.wishlistProduct.findMany()
    * ```
    */
  get wishlistProduct(): Prisma.WishlistProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Notice: 'Notice',
    Board: 'Board',
    BoardImage: 'BoardImage',
    BoardReply: 'BoardReply',
    CafeBoard: 'CafeBoard',
    RegionCategory: 'RegionCategory',
    ClosureRegionCategory: 'ClosureRegionCategory',
    CafeInfo: 'CafeInfo',
    CafeThumbnailImage: 'CafeThumbnailImage',
    CafeVirtualImage: 'CafeVirtualImage',
    CafeRealImage: 'CafeRealImage',
    CafeVirtualLink: 'CafeVirtualLink',
    CafeVirtualLinkThumbnailImage: 'CafeVirtualLinkThumbnailImage',
    CafeCouponGroup: 'CafeCouponGroup',
    CafeCouponGoupPartner: 'CafeCouponGoupPartner',
    ProxyUser: 'ProxyUser',
    CafeCoupon: 'CafeCoupon',
    CafeCouponHistory: 'CafeCouponHistory',
    CafeCouponQRCode: 'CafeCouponQRCode',
    MetaViewerInfo: 'MetaViewerInfo',
    MetaViewerMap: 'MetaViewerMap',
    MetaViewerActiveMap: 'MetaViewerActiveMap',
    ProductCategory: 'ProductCategory',
    ClosureProductCategory: 'ClosureProductCategory',
    Product: 'Product',
    WishlistProduct: 'WishlistProduct',
    ProductImage: 'ProductImage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "notice" | "board" | "boardImage" | "boardReply" | "cafeBoard" | "regionCategory" | "closureRegionCategory" | "cafeInfo" | "cafeThumbnailImage" | "cafeVirtualImage" | "cafeRealImage" | "cafeVirtualLink" | "cafeVirtualLinkThumbnailImage" | "cafeCouponGroup" | "cafeCouponGoupPartner" | "proxyUser" | "cafeCoupon" | "cafeCouponHistory" | "cafeCouponQRCode" | "metaViewerInfo" | "metaViewerMap" | "metaViewerActiveMap" | "productCategory" | "closureProductCategory" | "product" | "wishlistProduct" | "productImage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoticeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoticeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      BoardImage: {
        payload: Prisma.$BoardImagePayload<ExtArgs>
        fields: Prisma.BoardImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>
          }
          findFirst: {
            args: Prisma.BoardImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>
          }
          findMany: {
            args: Prisma.BoardImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>[]
          }
          create: {
            args: Prisma.BoardImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>
          }
          createMany: {
            args: Prisma.BoardImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>[]
          }
          delete: {
            args: Prisma.BoardImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>
          }
          update: {
            args: Prisma.BoardImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>
          }
          deleteMany: {
            args: Prisma.BoardImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>[]
          }
          upsert: {
            args: Prisma.BoardImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardImagePayload>
          }
          aggregate: {
            args: Prisma.BoardImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoardImage>
          }
          groupBy: {
            args: Prisma.BoardImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardImageCountArgs<ExtArgs>
            result: $Utils.Optional<BoardImageCountAggregateOutputType> | number
          }
        }
      }
      BoardReply: {
        payload: Prisma.$BoardReplyPayload<ExtArgs>
        fields: Prisma.BoardReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>
          }
          findFirst: {
            args: Prisma.BoardReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>
          }
          findMany: {
            args: Prisma.BoardReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>[]
          }
          create: {
            args: Prisma.BoardReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>
          }
          createMany: {
            args: Prisma.BoardReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>[]
          }
          delete: {
            args: Prisma.BoardReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>
          }
          update: {
            args: Prisma.BoardReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>
          }
          deleteMany: {
            args: Prisma.BoardReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>[]
          }
          upsert: {
            args: Prisma.BoardReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardReplyPayload>
          }
          aggregate: {
            args: Prisma.BoardReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoardReply>
          }
          groupBy: {
            args: Prisma.BoardReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardReplyCountArgs<ExtArgs>
            result: $Utils.Optional<BoardReplyCountAggregateOutputType> | number
          }
        }
      }
      CafeBoard: {
        payload: Prisma.$CafeBoardPayload<ExtArgs>
        fields: Prisma.CafeBoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeBoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeBoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>
          }
          findFirst: {
            args: Prisma.CafeBoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeBoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>
          }
          findMany: {
            args: Prisma.CafeBoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>[]
          }
          create: {
            args: Prisma.CafeBoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>
          }
          createMany: {
            args: Prisma.CafeBoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeBoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>[]
          }
          delete: {
            args: Prisma.CafeBoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>
          }
          update: {
            args: Prisma.CafeBoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>
          }
          deleteMany: {
            args: Prisma.CafeBoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeBoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeBoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>[]
          }
          upsert: {
            args: Prisma.CafeBoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeBoardPayload>
          }
          aggregate: {
            args: Prisma.CafeBoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeBoard>
          }
          groupBy: {
            args: Prisma.CafeBoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeBoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeBoardCountArgs<ExtArgs>
            result: $Utils.Optional<CafeBoardCountAggregateOutputType> | number
          }
        }
      }
      RegionCategory: {
        payload: Prisma.$RegionCategoryPayload<ExtArgs>
        fields: Prisma.RegionCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>
          }
          findFirst: {
            args: Prisma.RegionCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>
          }
          findMany: {
            args: Prisma.RegionCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>[]
          }
          create: {
            args: Prisma.RegionCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>
          }
          createMany: {
            args: Prisma.RegionCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>[]
          }
          delete: {
            args: Prisma.RegionCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>
          }
          update: {
            args: Prisma.RegionCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>
          }
          deleteMany: {
            args: Prisma.RegionCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>[]
          }
          upsert: {
            args: Prisma.RegionCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionCategoryPayload>
          }
          aggregate: {
            args: Prisma.RegionCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegionCategory>
          }
          groupBy: {
            args: Prisma.RegionCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCategoryCountAggregateOutputType> | number
          }
        }
      }
      ClosureRegionCategory: {
        payload: Prisma.$ClosureRegionCategoryPayload<ExtArgs>
        fields: Prisma.ClosureRegionCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClosureRegionCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClosureRegionCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>
          }
          findFirst: {
            args: Prisma.ClosureRegionCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClosureRegionCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>
          }
          findMany: {
            args: Prisma.ClosureRegionCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>[]
          }
          create: {
            args: Prisma.ClosureRegionCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>
          }
          createMany: {
            args: Prisma.ClosureRegionCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClosureRegionCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>[]
          }
          delete: {
            args: Prisma.ClosureRegionCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>
          }
          update: {
            args: Prisma.ClosureRegionCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ClosureRegionCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClosureRegionCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClosureRegionCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ClosureRegionCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureRegionCategoryPayload>
          }
          aggregate: {
            args: Prisma.ClosureRegionCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClosureRegionCategory>
          }
          groupBy: {
            args: Prisma.ClosureRegionCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClosureRegionCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClosureRegionCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ClosureRegionCategoryCountAggregateOutputType> | number
          }
        }
      }
      CafeInfo: {
        payload: Prisma.$CafeInfoPayload<ExtArgs>
        fields: Prisma.CafeInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>
          }
          findFirst: {
            args: Prisma.CafeInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>
          }
          findMany: {
            args: Prisma.CafeInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>[]
          }
          create: {
            args: Prisma.CafeInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>
          }
          createMany: {
            args: Prisma.CafeInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>[]
          }
          delete: {
            args: Prisma.CafeInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>
          }
          update: {
            args: Prisma.CafeInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>
          }
          deleteMany: {
            args: Prisma.CafeInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>[]
          }
          upsert: {
            args: Prisma.CafeInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeInfoPayload>
          }
          aggregate: {
            args: Prisma.CafeInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeInfo>
          }
          groupBy: {
            args: Prisma.CafeInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeInfoCountArgs<ExtArgs>
            result: $Utils.Optional<CafeInfoCountAggregateOutputType> | number
          }
        }
      }
      CafeThumbnailImage: {
        payload: Prisma.$CafeThumbnailImagePayload<ExtArgs>
        fields: Prisma.CafeThumbnailImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeThumbnailImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeThumbnailImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>
          }
          findFirst: {
            args: Prisma.CafeThumbnailImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeThumbnailImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>
          }
          findMany: {
            args: Prisma.CafeThumbnailImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>[]
          }
          create: {
            args: Prisma.CafeThumbnailImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>
          }
          createMany: {
            args: Prisma.CafeThumbnailImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeThumbnailImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>[]
          }
          delete: {
            args: Prisma.CafeThumbnailImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>
          }
          update: {
            args: Prisma.CafeThumbnailImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>
          }
          deleteMany: {
            args: Prisma.CafeThumbnailImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeThumbnailImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeThumbnailImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>[]
          }
          upsert: {
            args: Prisma.CafeThumbnailImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeThumbnailImagePayload>
          }
          aggregate: {
            args: Prisma.CafeThumbnailImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeThumbnailImage>
          }
          groupBy: {
            args: Prisma.CafeThumbnailImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeThumbnailImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeThumbnailImageCountArgs<ExtArgs>
            result: $Utils.Optional<CafeThumbnailImageCountAggregateOutputType> | number
          }
        }
      }
      CafeVirtualImage: {
        payload: Prisma.$CafeVirtualImagePayload<ExtArgs>
        fields: Prisma.CafeVirtualImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeVirtualImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeVirtualImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>
          }
          findFirst: {
            args: Prisma.CafeVirtualImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeVirtualImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>
          }
          findMany: {
            args: Prisma.CafeVirtualImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>[]
          }
          create: {
            args: Prisma.CafeVirtualImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>
          }
          createMany: {
            args: Prisma.CafeVirtualImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeVirtualImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>[]
          }
          delete: {
            args: Prisma.CafeVirtualImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>
          }
          update: {
            args: Prisma.CafeVirtualImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>
          }
          deleteMany: {
            args: Prisma.CafeVirtualImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeVirtualImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeVirtualImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>[]
          }
          upsert: {
            args: Prisma.CafeVirtualImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualImagePayload>
          }
          aggregate: {
            args: Prisma.CafeVirtualImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeVirtualImage>
          }
          groupBy: {
            args: Prisma.CafeVirtualImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeVirtualImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeVirtualImageCountArgs<ExtArgs>
            result: $Utils.Optional<CafeVirtualImageCountAggregateOutputType> | number
          }
        }
      }
      CafeRealImage: {
        payload: Prisma.$CafeRealImagePayload<ExtArgs>
        fields: Prisma.CafeRealImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeRealImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeRealImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>
          }
          findFirst: {
            args: Prisma.CafeRealImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeRealImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>
          }
          findMany: {
            args: Prisma.CafeRealImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>[]
          }
          create: {
            args: Prisma.CafeRealImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>
          }
          createMany: {
            args: Prisma.CafeRealImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeRealImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>[]
          }
          delete: {
            args: Prisma.CafeRealImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>
          }
          update: {
            args: Prisma.CafeRealImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>
          }
          deleteMany: {
            args: Prisma.CafeRealImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeRealImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeRealImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>[]
          }
          upsert: {
            args: Prisma.CafeRealImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeRealImagePayload>
          }
          aggregate: {
            args: Prisma.CafeRealImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeRealImage>
          }
          groupBy: {
            args: Prisma.CafeRealImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeRealImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeRealImageCountArgs<ExtArgs>
            result: $Utils.Optional<CafeRealImageCountAggregateOutputType> | number
          }
        }
      }
      CafeVirtualLink: {
        payload: Prisma.$CafeVirtualLinkPayload<ExtArgs>
        fields: Prisma.CafeVirtualLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeVirtualLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeVirtualLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>
          }
          findFirst: {
            args: Prisma.CafeVirtualLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeVirtualLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>
          }
          findMany: {
            args: Prisma.CafeVirtualLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>[]
          }
          create: {
            args: Prisma.CafeVirtualLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>
          }
          createMany: {
            args: Prisma.CafeVirtualLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeVirtualLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>[]
          }
          delete: {
            args: Prisma.CafeVirtualLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>
          }
          update: {
            args: Prisma.CafeVirtualLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>
          }
          deleteMany: {
            args: Prisma.CafeVirtualLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeVirtualLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeVirtualLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>[]
          }
          upsert: {
            args: Prisma.CafeVirtualLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkPayload>
          }
          aggregate: {
            args: Prisma.CafeVirtualLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeVirtualLink>
          }
          groupBy: {
            args: Prisma.CafeVirtualLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeVirtualLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeVirtualLinkCountArgs<ExtArgs>
            result: $Utils.Optional<CafeVirtualLinkCountAggregateOutputType> | number
          }
        }
      }
      CafeVirtualLinkThumbnailImage: {
        payload: Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>
        fields: Prisma.CafeVirtualLinkThumbnailImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeVirtualLinkThumbnailImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>
          }
          findFirst: {
            args: Prisma.CafeVirtualLinkThumbnailImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>
          }
          findMany: {
            args: Prisma.CafeVirtualLinkThumbnailImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>[]
          }
          create: {
            args: Prisma.CafeVirtualLinkThumbnailImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>
          }
          createMany: {
            args: Prisma.CafeVirtualLinkThumbnailImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeVirtualLinkThumbnailImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>[]
          }
          delete: {
            args: Prisma.CafeVirtualLinkThumbnailImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>
          }
          update: {
            args: Prisma.CafeVirtualLinkThumbnailImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>
          }
          deleteMany: {
            args: Prisma.CafeVirtualLinkThumbnailImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeVirtualLinkThumbnailImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeVirtualLinkThumbnailImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>[]
          }
          upsert: {
            args: Prisma.CafeVirtualLinkThumbnailImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeVirtualLinkThumbnailImagePayload>
          }
          aggregate: {
            args: Prisma.CafeVirtualLinkThumbnailImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeVirtualLinkThumbnailImage>
          }
          groupBy: {
            args: Prisma.CafeVirtualLinkThumbnailImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeVirtualLinkThumbnailImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeVirtualLinkThumbnailImageCountArgs<ExtArgs>
            result: $Utils.Optional<CafeVirtualLinkThumbnailImageCountAggregateOutputType> | number
          }
        }
      }
      CafeCouponGroup: {
        payload: Prisma.$CafeCouponGroupPayload<ExtArgs>
        fields: Prisma.CafeCouponGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeCouponGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeCouponGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>
          }
          findFirst: {
            args: Prisma.CafeCouponGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeCouponGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>
          }
          findMany: {
            args: Prisma.CafeCouponGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>[]
          }
          create: {
            args: Prisma.CafeCouponGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>
          }
          createMany: {
            args: Prisma.CafeCouponGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeCouponGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>[]
          }
          delete: {
            args: Prisma.CafeCouponGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>
          }
          update: {
            args: Prisma.CafeCouponGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>
          }
          deleteMany: {
            args: Prisma.CafeCouponGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeCouponGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeCouponGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>[]
          }
          upsert: {
            args: Prisma.CafeCouponGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGroupPayload>
          }
          aggregate: {
            args: Prisma.CafeCouponGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeCouponGroup>
          }
          groupBy: {
            args: Prisma.CafeCouponGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeCouponGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponGroupCountAggregateOutputType> | number
          }
        }
      }
      CafeCouponGoupPartner: {
        payload: Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>
        fields: Prisma.CafeCouponGoupPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeCouponGoupPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeCouponGoupPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>
          }
          findFirst: {
            args: Prisma.CafeCouponGoupPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeCouponGoupPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>
          }
          findMany: {
            args: Prisma.CafeCouponGoupPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>[]
          }
          create: {
            args: Prisma.CafeCouponGoupPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>
          }
          createMany: {
            args: Prisma.CafeCouponGoupPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeCouponGoupPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>[]
          }
          delete: {
            args: Prisma.CafeCouponGoupPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>
          }
          update: {
            args: Prisma.CafeCouponGoupPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>
          }
          deleteMany: {
            args: Prisma.CafeCouponGoupPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeCouponGoupPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeCouponGoupPartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>[]
          }
          upsert: {
            args: Prisma.CafeCouponGoupPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponGoupPartnerPayload>
          }
          aggregate: {
            args: Prisma.CafeCouponGoupPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeCouponGoupPartner>
          }
          groupBy: {
            args: Prisma.CafeCouponGoupPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponGoupPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeCouponGoupPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponGoupPartnerCountAggregateOutputType> | number
          }
        }
      }
      ProxyUser: {
        payload: Prisma.$ProxyUserPayload<ExtArgs>
        fields: Prisma.ProxyUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>
          }
          findFirst: {
            args: Prisma.ProxyUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>
          }
          findMany: {
            args: Prisma.ProxyUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>[]
          }
          create: {
            args: Prisma.ProxyUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>
          }
          createMany: {
            args: Prisma.ProxyUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxyUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>[]
          }
          delete: {
            args: Prisma.ProxyUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>
          }
          update: {
            args: Prisma.ProxyUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>
          }
          deleteMany: {
            args: Prisma.ProxyUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxyUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>[]
          }
          upsert: {
            args: Prisma.ProxyUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyUserPayload>
          }
          aggregate: {
            args: Prisma.ProxyUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxyUser>
          }
          groupBy: {
            args: Prisma.ProxyUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyUserCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyUserCountAggregateOutputType> | number
          }
        }
      }
      CafeCoupon: {
        payload: Prisma.$CafeCouponPayload<ExtArgs>
        fields: Prisma.CafeCouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeCouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeCouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>
          }
          findFirst: {
            args: Prisma.CafeCouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeCouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>
          }
          findMany: {
            args: Prisma.CafeCouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>[]
          }
          create: {
            args: Prisma.CafeCouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>
          }
          createMany: {
            args: Prisma.CafeCouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeCouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>[]
          }
          delete: {
            args: Prisma.CafeCouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>
          }
          update: {
            args: Prisma.CafeCouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>
          }
          deleteMany: {
            args: Prisma.CafeCouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeCouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeCouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>[]
          }
          upsert: {
            args: Prisma.CafeCouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponPayload>
          }
          aggregate: {
            args: Prisma.CafeCouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeCoupon>
          }
          groupBy: {
            args: Prisma.CafeCouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeCouponCountArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponCountAggregateOutputType> | number
          }
        }
      }
      CafeCouponHistory: {
        payload: Prisma.$CafeCouponHistoryPayload<ExtArgs>
        fields: Prisma.CafeCouponHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeCouponHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeCouponHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>
          }
          findFirst: {
            args: Prisma.CafeCouponHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeCouponHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>
          }
          findMany: {
            args: Prisma.CafeCouponHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>[]
          }
          create: {
            args: Prisma.CafeCouponHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>
          }
          createMany: {
            args: Prisma.CafeCouponHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeCouponHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>[]
          }
          delete: {
            args: Prisma.CafeCouponHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>
          }
          update: {
            args: Prisma.CafeCouponHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CafeCouponHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeCouponHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeCouponHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>[]
          }
          upsert: {
            args: Prisma.CafeCouponHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponHistoryPayload>
          }
          aggregate: {
            args: Prisma.CafeCouponHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeCouponHistory>
          }
          groupBy: {
            args: Prisma.CafeCouponHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeCouponHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponHistoryCountAggregateOutputType> | number
          }
        }
      }
      CafeCouponQRCode: {
        payload: Prisma.$CafeCouponQRCodePayload<ExtArgs>
        fields: Prisma.CafeCouponQRCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeCouponQRCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeCouponQRCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>
          }
          findFirst: {
            args: Prisma.CafeCouponQRCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeCouponQRCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>
          }
          findMany: {
            args: Prisma.CafeCouponQRCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>[]
          }
          create: {
            args: Prisma.CafeCouponQRCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>
          }
          createMany: {
            args: Prisma.CafeCouponQRCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeCouponQRCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>[]
          }
          delete: {
            args: Prisma.CafeCouponQRCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>
          }
          update: {
            args: Prisma.CafeCouponQRCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>
          }
          deleteMany: {
            args: Prisma.CafeCouponQRCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeCouponQRCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeCouponQRCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>[]
          }
          upsert: {
            args: Prisma.CafeCouponQRCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeCouponQRCodePayload>
          }
          aggregate: {
            args: Prisma.CafeCouponQRCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeCouponQRCode>
          }
          groupBy: {
            args: Prisma.CafeCouponQRCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponQRCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeCouponQRCodeCountArgs<ExtArgs>
            result: $Utils.Optional<CafeCouponQRCodeCountAggregateOutputType> | number
          }
        }
      }
      MetaViewerInfo: {
        payload: Prisma.$MetaViewerInfoPayload<ExtArgs>
        fields: Prisma.MetaViewerInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetaViewerInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetaViewerInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>
          }
          findFirst: {
            args: Prisma.MetaViewerInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetaViewerInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>
          }
          findMany: {
            args: Prisma.MetaViewerInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>[]
          }
          create: {
            args: Prisma.MetaViewerInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>
          }
          createMany: {
            args: Prisma.MetaViewerInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetaViewerInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>[]
          }
          delete: {
            args: Prisma.MetaViewerInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>
          }
          update: {
            args: Prisma.MetaViewerInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>
          }
          deleteMany: {
            args: Prisma.MetaViewerInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetaViewerInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetaViewerInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>[]
          }
          upsert: {
            args: Prisma.MetaViewerInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerInfoPayload>
          }
          aggregate: {
            args: Prisma.MetaViewerInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetaViewerInfo>
          }
          groupBy: {
            args: Prisma.MetaViewerInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetaViewerInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetaViewerInfoCountArgs<ExtArgs>
            result: $Utils.Optional<MetaViewerInfoCountAggregateOutputType> | number
          }
        }
      }
      MetaViewerMap: {
        payload: Prisma.$MetaViewerMapPayload<ExtArgs>
        fields: Prisma.MetaViewerMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetaViewerMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetaViewerMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>
          }
          findFirst: {
            args: Prisma.MetaViewerMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetaViewerMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>
          }
          findMany: {
            args: Prisma.MetaViewerMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>[]
          }
          create: {
            args: Prisma.MetaViewerMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>
          }
          createMany: {
            args: Prisma.MetaViewerMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetaViewerMapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>[]
          }
          delete: {
            args: Prisma.MetaViewerMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>
          }
          update: {
            args: Prisma.MetaViewerMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>
          }
          deleteMany: {
            args: Prisma.MetaViewerMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetaViewerMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetaViewerMapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>[]
          }
          upsert: {
            args: Prisma.MetaViewerMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerMapPayload>
          }
          aggregate: {
            args: Prisma.MetaViewerMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetaViewerMap>
          }
          groupBy: {
            args: Prisma.MetaViewerMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetaViewerMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetaViewerMapCountArgs<ExtArgs>
            result: $Utils.Optional<MetaViewerMapCountAggregateOutputType> | number
          }
        }
      }
      MetaViewerActiveMap: {
        payload: Prisma.$MetaViewerActiveMapPayload<ExtArgs>
        fields: Prisma.MetaViewerActiveMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetaViewerActiveMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetaViewerActiveMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>
          }
          findFirst: {
            args: Prisma.MetaViewerActiveMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetaViewerActiveMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>
          }
          findMany: {
            args: Prisma.MetaViewerActiveMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>[]
          }
          create: {
            args: Prisma.MetaViewerActiveMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>
          }
          createMany: {
            args: Prisma.MetaViewerActiveMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetaViewerActiveMapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>[]
          }
          delete: {
            args: Prisma.MetaViewerActiveMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>
          }
          update: {
            args: Prisma.MetaViewerActiveMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>
          }
          deleteMany: {
            args: Prisma.MetaViewerActiveMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetaViewerActiveMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetaViewerActiveMapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>[]
          }
          upsert: {
            args: Prisma.MetaViewerActiveMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaViewerActiveMapPayload>
          }
          aggregate: {
            args: Prisma.MetaViewerActiveMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetaViewerActiveMap>
          }
          groupBy: {
            args: Prisma.MetaViewerActiveMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetaViewerActiveMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetaViewerActiveMapCountArgs<ExtArgs>
            result: $Utils.Optional<MetaViewerActiveMapCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ClosureProductCategory: {
        payload: Prisma.$ClosureProductCategoryPayload<ExtArgs>
        fields: Prisma.ClosureProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClosureProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClosureProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ClosureProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClosureProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ClosureProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ClosureProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ClosureProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClosureProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ClosureProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>
          }
          update: {
            args: Prisma.ClosureProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ClosureProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClosureProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClosureProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ClosureProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosureProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ClosureProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClosureProductCategory>
          }
          groupBy: {
            args: Prisma.ClosureProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClosureProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClosureProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ClosureProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      WishlistProduct: {
        payload: Prisma.$WishlistProductPayload<ExtArgs>
        fields: Prisma.WishlistProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>
          }
          findFirst: {
            args: Prisma.WishlistProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>
          }
          findMany: {
            args: Prisma.WishlistProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>[]
          }
          create: {
            args: Prisma.WishlistProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>
          }
          createMany: {
            args: Prisma.WishlistProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>[]
          }
          delete: {
            args: Prisma.WishlistProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>
          }
          update: {
            args: Prisma.WishlistProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>
          }
          deleteMany: {
            args: Prisma.WishlistProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WishlistProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>[]
          }
          upsert: {
            args: Prisma.WishlistProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistProductPayload>
          }
          aggregate: {
            args: Prisma.WishlistProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlistProduct>
          }
          groupBy: {
            args: Prisma.WishlistProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistProductCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistProductCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    notice?: NoticeOmit
    board?: BoardOmit
    boardImage?: BoardImageOmit
    boardReply?: BoardReplyOmit
    cafeBoard?: CafeBoardOmit
    regionCategory?: RegionCategoryOmit
    closureRegionCategory?: ClosureRegionCategoryOmit
    cafeInfo?: CafeInfoOmit
    cafeThumbnailImage?: CafeThumbnailImageOmit
    cafeVirtualImage?: CafeVirtualImageOmit
    cafeRealImage?: CafeRealImageOmit
    cafeVirtualLink?: CafeVirtualLinkOmit
    cafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageOmit
    cafeCouponGroup?: CafeCouponGroupOmit
    cafeCouponGoupPartner?: CafeCouponGoupPartnerOmit
    proxyUser?: ProxyUserOmit
    cafeCoupon?: CafeCouponOmit
    cafeCouponHistory?: CafeCouponHistoryOmit
    cafeCouponQRCode?: CafeCouponQRCodeOmit
    metaViewerInfo?: MetaViewerInfoOmit
    metaViewerMap?: MetaViewerMapOmit
    metaViewerActiveMap?: MetaViewerActiveMapOmit
    productCategory?: ProductCategoryOmit
    closureProductCategory?: ClosureProductCategoryOmit
    product?: ProductOmit
    wishlistProduct?: WishlistProductOmit
    productImage?: ProductImageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Boards: number
    BoardReplies: number
    Notices: number
    ProxyUsers: number
    CafeCouponHistories: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Boards?: boolean | UserCountOutputTypeCountBoardsArgs
    BoardReplies?: boolean | UserCountOutputTypeCountBoardRepliesArgs
    Notices?: boolean | UserCountOutputTypeCountNoticesArgs
    ProxyUsers?: boolean | UserCountOutputTypeCountProxyUsersArgs
    CafeCouponHistories?: boolean | UserCountOutputTypeCountCafeCouponHistoriesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBoardRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProxyUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCafeCouponHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponHistoryWhereInput
  }


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    BoardImages: number
    BoardReplies: number
    CafeBoards: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BoardImages?: boolean | BoardCountOutputTypeCountBoardImagesArgs
    BoardReplies?: boolean | BoardCountOutputTypeCountBoardRepliesArgs
    CafeBoards?: boolean | BoardCountOutputTypeCountCafeBoardsArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountBoardImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardImageWhereInput
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountBoardRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardReplyWhereInput
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountCafeBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeBoardWhereInput
  }


  /**
   * Count Type BoardReplyCountOutputType
   */

  export type BoardReplyCountOutputType = {
    BoardNestedReplies: number
  }

  export type BoardReplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BoardNestedReplies?: boolean | BoardReplyCountOutputTypeCountBoardNestedRepliesArgs
  }

  // Custom InputTypes
  /**
   * BoardReplyCountOutputType without action
   */
  export type BoardReplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReplyCountOutputType
     */
    select?: BoardReplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardReplyCountOutputType without action
   */
  export type BoardReplyCountOutputTypeCountBoardNestedRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardReplyWhereInput
  }


  /**
   * Count Type RegionCategoryCountOutputType
   */

  export type RegionCategoryCountOutputType = {
    CafeInfos: number
    AncestorCategories: number
    DescendantCategories: number
  }

  export type RegionCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfos?: boolean | RegionCategoryCountOutputTypeCountCafeInfosArgs
    AncestorCategories?: boolean | RegionCategoryCountOutputTypeCountAncestorCategoriesArgs
    DescendantCategories?: boolean | RegionCategoryCountOutputTypeCountDescendantCategoriesArgs
  }

  // Custom InputTypes
  /**
   * RegionCategoryCountOutputType without action
   */
  export type RegionCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategoryCountOutputType
     */
    select?: RegionCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCategoryCountOutputType without action
   */
  export type RegionCategoryCountOutputTypeCountCafeInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeInfoWhereInput
  }

  /**
   * RegionCategoryCountOutputType without action
   */
  export type RegionCategoryCountOutputTypeCountAncestorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosureRegionCategoryWhereInput
  }

  /**
   * RegionCategoryCountOutputType without action
   */
  export type RegionCategoryCountOutputTypeCountDescendantCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosureRegionCategoryWhereInput
  }


  /**
   * Count Type CafeInfoCountOutputType
   */

  export type CafeInfoCountOutputType = {
    CafeVirtualLinks: number
    CafeThumbnailImages: number
    CafeVirtualImages: number
    CafeRealImages: number
    CafeCouponGroupPartners: number
    CafeBoards: number
    MetaViewerInfos: number
    Products: number
  }

  export type CafeInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeVirtualLinks?: boolean | CafeInfoCountOutputTypeCountCafeVirtualLinksArgs
    CafeThumbnailImages?: boolean | CafeInfoCountOutputTypeCountCafeThumbnailImagesArgs
    CafeVirtualImages?: boolean | CafeInfoCountOutputTypeCountCafeVirtualImagesArgs
    CafeRealImages?: boolean | CafeInfoCountOutputTypeCountCafeRealImagesArgs
    CafeCouponGroupPartners?: boolean | CafeInfoCountOutputTypeCountCafeCouponGroupPartnersArgs
    CafeBoards?: boolean | CafeInfoCountOutputTypeCountCafeBoardsArgs
    MetaViewerInfos?: boolean | CafeInfoCountOutputTypeCountMetaViewerInfosArgs
    Products?: boolean | CafeInfoCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfoCountOutputType
     */
    select?: CafeInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountCafeVirtualLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeVirtualLinkWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountCafeThumbnailImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeThumbnailImageWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountCafeVirtualImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeVirtualImageWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountCafeRealImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeRealImageWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountCafeCouponGroupPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponGoupPartnerWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountCafeBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeBoardWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountMetaViewerInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerInfoWhereInput
  }

  /**
   * CafeInfoCountOutputType without action
   */
  export type CafeInfoCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type CafeCouponGroupCountOutputType
   */

  export type CafeCouponGroupCountOutputType = {
    CafeCoupons: number
    CafeCouponGoupPartners: number
  }

  export type CafeCouponGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupons?: boolean | CafeCouponGroupCountOutputTypeCountCafeCouponsArgs
    CafeCouponGoupPartners?: boolean | CafeCouponGroupCountOutputTypeCountCafeCouponGoupPartnersArgs
  }

  // Custom InputTypes
  /**
   * CafeCouponGroupCountOutputType without action
   */
  export type CafeCouponGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroupCountOutputType
     */
    select?: CafeCouponGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CafeCouponGroupCountOutputType without action
   */
  export type CafeCouponGroupCountOutputTypeCountCafeCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponWhereInput
  }

  /**
   * CafeCouponGroupCountOutputType without action
   */
  export type CafeCouponGroupCountOutputTypeCountCafeCouponGoupPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponGoupPartnerWhereInput
  }


  /**
   * Count Type ProxyUserCountOutputType
   */

  export type ProxyUserCountOutputType = {
    CafeCoupons: number
    WishlistProducts: number
  }

  export type ProxyUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupons?: boolean | ProxyUserCountOutputTypeCountCafeCouponsArgs
    WishlistProducts?: boolean | ProxyUserCountOutputTypeCountWishlistProductsArgs
  }

  // Custom InputTypes
  /**
   * ProxyUserCountOutputType without action
   */
  export type ProxyUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUserCountOutputType
     */
    select?: ProxyUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProxyUserCountOutputType without action
   */
  export type ProxyUserCountOutputTypeCountCafeCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponWhereInput
  }

  /**
   * ProxyUserCountOutputType without action
   */
  export type ProxyUserCountOutputTypeCountWishlistProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistProductWhereInput
  }


  /**
   * Count Type CafeCouponCountOutputType
   */

  export type CafeCouponCountOutputType = {
    CafeCouponQRCodes: number
    CafeCouponHistories: number
  }

  export type CafeCouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCouponQRCodes?: boolean | CafeCouponCountOutputTypeCountCafeCouponQRCodesArgs
    CafeCouponHistories?: boolean | CafeCouponCountOutputTypeCountCafeCouponHistoriesArgs
  }

  // Custom InputTypes
  /**
   * CafeCouponCountOutputType without action
   */
  export type CafeCouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponCountOutputType
     */
    select?: CafeCouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CafeCouponCountOutputType without action
   */
  export type CafeCouponCountOutputTypeCountCafeCouponQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponQRCodeWhereInput
  }

  /**
   * CafeCouponCountOutputType without action
   */
  export type CafeCouponCountOutputTypeCountCafeCouponHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponHistoryWhereInput
  }


  /**
   * Count Type MetaViewerInfoCountOutputType
   */

  export type MetaViewerInfoCountOutputType = {
    MetaViewerMaps: number
  }

  export type MetaViewerInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerMaps?: boolean | MetaViewerInfoCountOutputTypeCountMetaViewerMapsArgs
  }

  // Custom InputTypes
  /**
   * MetaViewerInfoCountOutputType without action
   */
  export type MetaViewerInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfoCountOutputType
     */
    select?: MetaViewerInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetaViewerInfoCountOutputType without action
   */
  export type MetaViewerInfoCountOutputTypeCountMetaViewerMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerMapWhereInput
  }


  /**
   * Count Type MetaViewerMapCountOutputType
   */

  export type MetaViewerMapCountOutputType = {
    ActiveRenderFor: number
    ActiveColliderFor: number
  }

  export type MetaViewerMapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActiveRenderFor?: boolean | MetaViewerMapCountOutputTypeCountActiveRenderForArgs
    ActiveColliderFor?: boolean | MetaViewerMapCountOutputTypeCountActiveColliderForArgs
  }

  // Custom InputTypes
  /**
   * MetaViewerMapCountOutputType without action
   */
  export type MetaViewerMapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMapCountOutputType
     */
    select?: MetaViewerMapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetaViewerMapCountOutputType without action
   */
  export type MetaViewerMapCountOutputTypeCountActiveRenderForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerActiveMapWhereInput
  }

  /**
   * MetaViewerMapCountOutputType without action
   */
  export type MetaViewerMapCountOutputTypeCountActiveColliderForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerActiveMapWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    AncestorCategories: number
    DescendantCategories: number
    Products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategories?: boolean | ProductCategoryCountOutputTypeCountAncestorCategoriesArgs
    DescendantCategories?: boolean | ProductCategoryCountOutputTypeCountDescendantCategoriesArgs
    Products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountAncestorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosureProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountDescendantCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosureProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    WishlistProducts: number
    ProductImages: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WishlistProducts?: boolean | ProductCountOutputTypeCountWishlistProductsArgs
    ProductImages?: boolean | ProductCountOutputTypeCountProductImagesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    loginId: string | null
    loginPw: string | null
    username: string | null
    loginType: $Enums.LoginType | null
    userType: $Enums.UserType | null
    nickname: string | null
    email: string | null
    isDisable: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    loginId: string | null
    loginPw: string | null
    username: string | null
    loginType: $Enums.LoginType | null
    userType: $Enums.UserType | null
    nickname: string | null
    email: string | null
    isDisable: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    loginId: number
    loginPw: number
    username: number
    loginType: number
    userType: number
    nickname: number
    email: number
    isDisable: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    loginId?: true
    loginPw?: true
    username?: true
    loginType?: true
    userType?: true
    nickname?: true
    email?: true
    isDisable?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    loginId?: true
    loginPw?: true
    username?: true
    loginType?: true
    userType?: true
    nickname?: true
    email?: true
    isDisable?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    loginId?: true
    loginPw?: true
    username?: true
    loginType?: true
    userType?: true
    nickname?: true
    email?: true
    isDisable?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    loginId: string
    loginPw: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    loginId?: boolean
    loginPw?: boolean
    username?: boolean
    loginType?: boolean
    userType?: boolean
    nickname?: boolean
    email?: boolean
    isDisable?: boolean
    Boards?: boolean | User$BoardsArgs<ExtArgs>
    BoardReplies?: boolean | User$BoardRepliesArgs<ExtArgs>
    Notices?: boolean | User$NoticesArgs<ExtArgs>
    ProxyUsers?: boolean | User$ProxyUsersArgs<ExtArgs>
    CafeCouponHistories?: boolean | User$CafeCouponHistoriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    loginId?: boolean
    loginPw?: boolean
    username?: boolean
    loginType?: boolean
    userType?: boolean
    nickname?: boolean
    email?: boolean
    isDisable?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    loginId?: boolean
    loginPw?: boolean
    username?: boolean
    loginType?: boolean
    userType?: boolean
    nickname?: boolean
    email?: boolean
    isDisable?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    loginId?: boolean
    loginPw?: boolean
    username?: boolean
    loginType?: boolean
    userType?: boolean
    nickname?: boolean
    email?: boolean
    isDisable?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "loginId" | "loginPw" | "username" | "loginType" | "userType" | "nickname" | "email" | "isDisable", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Boards?: boolean | User$BoardsArgs<ExtArgs>
    BoardReplies?: boolean | User$BoardRepliesArgs<ExtArgs>
    Notices?: boolean | User$NoticesArgs<ExtArgs>
    ProxyUsers?: boolean | User$ProxyUsersArgs<ExtArgs>
    CafeCouponHistories?: boolean | User$CafeCouponHistoriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Boards: Prisma.$BoardPayload<ExtArgs>[]
      BoardReplies: Prisma.$BoardReplyPayload<ExtArgs>[]
      Notices: Prisma.$NoticePayload<ExtArgs>[]
      ProxyUsers: Prisma.$ProxyUserPayload<ExtArgs>[]
      CafeCouponHistories: Prisma.$CafeCouponHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      loginId: string
      loginPw: string | null
      username: string
      loginType: $Enums.LoginType
      userType: $Enums.UserType
      nickname: string
      email: string
      isDisable: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Boards<T extends User$BoardsArgs<ExtArgs> = {}>(args?: Subset<T, User$BoardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BoardReplies<T extends User$BoardRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$BoardRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notices<T extends User$NoticesArgs<ExtArgs> = {}>(args?: Subset<T, User$NoticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProxyUsers<T extends User$ProxyUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$ProxyUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeCouponHistories<T extends User$CafeCouponHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$CafeCouponHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly loginId: FieldRef<"User", 'String'>
    readonly loginPw: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly loginType: FieldRef<"User", 'LoginType'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly isDisable: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Boards
   */
  export type User$BoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    cursor?: BoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * User.BoardReplies
   */
  export type User$BoardRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    where?: BoardReplyWhereInput
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    cursor?: BoardReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardReplyScalarFieldEnum | BoardReplyScalarFieldEnum[]
  }

  /**
   * User.Notices
   */
  export type User$NoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    cursor?: NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * User.ProxyUsers
   */
  export type User$ProxyUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    where?: ProxyUserWhereInput
    orderBy?: ProxyUserOrderByWithRelationInput | ProxyUserOrderByWithRelationInput[]
    cursor?: ProxyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxyUserScalarFieldEnum | ProxyUserScalarFieldEnum[]
  }

  /**
   * User.CafeCouponHistories
   */
  export type User$CafeCouponHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    where?: CafeCouponHistoryWhereInput
    orderBy?: CafeCouponHistoryOrderByWithRelationInput | CafeCouponHistoryOrderByWithRelationInput[]
    cursor?: CafeCouponHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponHistoryScalarFieldEnum | CafeCouponHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    userId: number | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    userId: number | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    content: number
    link: number
    userId: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    userId?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    userId?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    userId?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: number
    createdAt: Date
    title: string
    content: string | null
    link: string | null
    userId: number
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    userId?: boolean
  }

  export type NoticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "title" | "content" | "link" | "userId", ExtArgs["result"]["notice"]>
  export type NoticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoticeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoticeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      title: string
      content: string | null
      link: string | null
      userId: number
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notices and returns the data saved in the database.
     * @param {NoticeCreateManyAndReturnArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoticeCreateManyAndReturnArgs>(args?: SelectSubset<T, NoticeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices and returns the data updated in the database.
     * @param {NoticeUpdateManyAndReturnArgs} args - Arguments to update many Notices.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoticeUpdateManyAndReturnArgs>(args: SelectSubset<T, NoticeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'Int'>
    readonly createdAt: FieldRef<"Notice", 'DateTime'>
    readonly title: FieldRef<"Notice", 'String'>
    readonly content: FieldRef<"Notice", 'String'>
    readonly link: FieldRef<"Notice", 'String'>
    readonly userId: FieldRef<"Notice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice createManyAndReturn
   */
  export type NoticeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice updateManyAndReturn
   */
  export type NoticeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to delete.
     */
    limit?: number
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
  }


  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BoardSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type BoardMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    isReplyAvaliable: boolean | null
    userId: number | null
    boardType: $Enums.BoardType | null
  }

  export type BoardMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    title: string | null
    content: string | null
    link: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    isReplyAvaliable: boolean | null
    userId: number | null
    boardType: $Enums.BoardType | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    content: number
    link: number
    startDay: number
    endDay: number
    isDisable: number
    isReplyAvaliable: number
    userId: number
    boardType: number
    _all: number
  }


  export type BoardAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BoardSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type BoardMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    isReplyAvaliable?: true
    userId?: true
    boardType?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    isReplyAvaliable?: true
    userId?: true
    boardType?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    link?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    isReplyAvaliable?: true
    userId?: true
    boardType?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _avg?: BoardAvgAggregateInputType
    _sum?: BoardSumAggregateInputType
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: number
    createdAt: Date
    title: string
    content: string | null
    link: string | null
    startDay: Date
    endDay: Date | null
    isDisable: boolean
    isReplyAvaliable: boolean
    userId: number
    boardType: $Enums.BoardType
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId?: boolean
    boardType?: boolean
    BoardImages?: boolean | Board$BoardImagesArgs<ExtArgs>
    BoardReplies?: boolean | Board$BoardRepliesArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    CafeBoards?: boolean | Board$CafeBoardsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId?: boolean
    boardType?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId?: boolean
    boardType?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId?: boolean
    boardType?: boolean
  }

  export type BoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "title" | "content" | "link" | "startDay" | "endDay" | "isDisable" | "isReplyAvaliable" | "userId" | "boardType", ExtArgs["result"]["board"]>
  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BoardImages?: boolean | Board$BoardImagesArgs<ExtArgs>
    BoardReplies?: boolean | Board$BoardRepliesArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    CafeBoards?: boolean | Board$CafeBoardsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      BoardImages: Prisma.$BoardImagePayload<ExtArgs>[]
      BoardReplies: Prisma.$BoardReplyPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
      CafeBoards: Prisma.$CafeBoardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      title: string
      content: string | null
      link: string | null
      startDay: Date
      endDay: Date | null
      isDisable: boolean
      isReplyAvaliable: boolean
      userId: number
      boardType: $Enums.BoardType
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards and returns the data updated in the database.
     * @param {BoardUpdateManyAndReturnArgs} args - Arguments to update many Boards.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BoardImages<T extends Board$BoardImagesArgs<ExtArgs> = {}>(args?: Subset<T, Board$BoardImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BoardReplies<T extends Board$BoardRepliesArgs<ExtArgs> = {}>(args?: Subset<T, Board$BoardRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeBoards<T extends Board$CafeBoardsArgs<ExtArgs> = {}>(args?: Subset<T, Board$CafeBoardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'Int'>
    readonly createdAt: FieldRef<"Board", 'DateTime'>
    readonly title: FieldRef<"Board", 'String'>
    readonly content: FieldRef<"Board", 'String'>
    readonly link: FieldRef<"Board", 'String'>
    readonly startDay: FieldRef<"Board", 'DateTime'>
    readonly endDay: FieldRef<"Board", 'DateTime'>
    readonly isDisable: FieldRef<"Board", 'Boolean'>
    readonly isReplyAvaliable: FieldRef<"Board", 'Boolean'>
    readonly userId: FieldRef<"Board", 'Int'>
    readonly boardType: FieldRef<"Board", 'BoardType'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board updateManyAndReturn
   */
  export type BoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to delete.
     */
    limit?: number
  }

  /**
   * Board.BoardImages
   */
  export type Board$BoardImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    where?: BoardImageWhereInput
    orderBy?: BoardImageOrderByWithRelationInput | BoardImageOrderByWithRelationInput[]
    cursor?: BoardImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardImageScalarFieldEnum | BoardImageScalarFieldEnum[]
  }

  /**
   * Board.BoardReplies
   */
  export type Board$BoardRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    where?: BoardReplyWhereInput
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    cursor?: BoardReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardReplyScalarFieldEnum | BoardReplyScalarFieldEnum[]
  }

  /**
   * Board.CafeBoards
   */
  export type Board$CafeBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    where?: CafeBoardWhereInput
    orderBy?: CafeBoardOrderByWithRelationInput | CafeBoardOrderByWithRelationInput[]
    cursor?: CafeBoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeBoardScalarFieldEnum | CafeBoardScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model BoardImage
   */

  export type AggregateBoardImage = {
    _count: BoardImageCountAggregateOutputType | null
    _avg: BoardImageAvgAggregateOutputType | null
    _sum: BoardImageSumAggregateOutputType | null
    _min: BoardImageMinAggregateOutputType | null
    _max: BoardImageMaxAggregateOutputType | null
  }

  export type BoardImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    boardId: number | null
  }

  export type BoardImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    boardId: number | null
  }

  export type BoardImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isThumb: boolean | null
    isDisable: boolean | null
    boardId: number | null
  }

  export type BoardImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isThumb: boolean | null
    isDisable: boolean | null
    boardId: number | null
  }

  export type BoardImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    thumbnailUrl: number
    width: number
    height: number
    size: number
    isThumb: number
    isDisable: number
    boardId: number
    _all: number
  }


  export type BoardImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    boardId?: true
  }

  export type BoardImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    boardId?: true
  }

  export type BoardImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isThumb?: true
    isDisable?: true
    boardId?: true
  }

  export type BoardImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isThumb?: true
    isDisable?: true
    boardId?: true
  }

  export type BoardImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isThumb?: true
    isDisable?: true
    boardId?: true
    _all?: true
  }

  export type BoardImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardImage to aggregate.
     */
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     */
    orderBy?: BoardImageOrderByWithRelationInput | BoardImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardImages
    **/
    _count?: true | BoardImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardImageMaxAggregateInputType
  }

  export type GetBoardImageAggregateType<T extends BoardImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardImage[P]>
      : GetScalarType<T[P], AggregateBoardImage[P]>
  }




  export type BoardImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardImageWhereInput
    orderBy?: BoardImageOrderByWithAggregationInput | BoardImageOrderByWithAggregationInput[]
    by: BoardImageScalarFieldEnum[] | BoardImageScalarFieldEnum
    having?: BoardImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardImageCountAggregateInputType | true
    _avg?: BoardImageAvgAggregateInputType
    _sum?: BoardImageSumAggregateInputType
    _min?: BoardImageMinAggregateInputType
    _max?: BoardImageMaxAggregateInputType
  }

  export type BoardImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb: boolean
    isDisable: boolean
    boardId: number
    _count: BoardImageCountAggregateOutputType | null
    _avg: BoardImageAvgAggregateOutputType | null
    _sum: BoardImageSumAggregateOutputType | null
    _min: BoardImageMinAggregateOutputType | null
    _max: BoardImageMaxAggregateOutputType | null
  }

  type GetBoardImageGroupByPayload<T extends BoardImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardImageGroupByOutputType[P]>
            : GetScalarType<T[P], BoardImageGroupByOutputType[P]>
        }
      >
    >


  export type BoardImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isThumb?: boolean
    isDisable?: boolean
    boardId?: boolean
    Board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardImage"]>

  export type BoardImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isThumb?: boolean
    isDisable?: boolean
    boardId?: boolean
    Board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardImage"]>

  export type BoardImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isThumb?: boolean
    isDisable?: boolean
    boardId?: boolean
    Board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardImage"]>

  export type BoardImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isThumb?: boolean
    isDisable?: boolean
    boardId?: boolean
  }

  export type BoardImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "url" | "thumbnailUrl" | "width" | "height" | "size" | "isThumb" | "isDisable" | "boardId", ExtArgs["result"]["boardImage"]>
  export type BoardImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type BoardImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type BoardImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $BoardImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoardImage"
    objects: {
      Board: Prisma.$BoardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      url: string
      thumbnailUrl: string
      width: number
      height: number
      size: number
      isThumb: boolean
      isDisable: boolean
      boardId: number
    }, ExtArgs["result"]["boardImage"]>
    composites: {}
  }

  type BoardImageGetPayload<S extends boolean | null | undefined | BoardImageDefaultArgs> = $Result.GetResult<Prisma.$BoardImagePayload, S>

  type BoardImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardImageCountAggregateInputType | true
    }

  export interface BoardImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoardImage'], meta: { name: 'BoardImage' } }
    /**
     * Find zero or one BoardImage that matches the filter.
     * @param {BoardImageFindUniqueArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardImageFindUniqueArgs>(args: SelectSubset<T, BoardImageFindUniqueArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BoardImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardImageFindUniqueOrThrowArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardImageFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageFindFirstArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardImageFindFirstArgs>(args?: SelectSubset<T, BoardImageFindFirstArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageFindFirstOrThrowArgs} args - Arguments to find a BoardImage
     * @example
     * // Get one BoardImage
     * const boardImage = await prisma.boardImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardImageFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BoardImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardImages
     * const boardImages = await prisma.boardImage.findMany()
     * 
     * // Get first 10 BoardImages
     * const boardImages = await prisma.boardImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardImageWithIdOnly = await prisma.boardImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardImageFindManyArgs>(args?: SelectSubset<T, BoardImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BoardImage.
     * @param {BoardImageCreateArgs} args - Arguments to create a BoardImage.
     * @example
     * // Create one BoardImage
     * const BoardImage = await prisma.boardImage.create({
     *   data: {
     *     // ... data to create a BoardImage
     *   }
     * })
     * 
     */
    create<T extends BoardImageCreateArgs>(args: SelectSubset<T, BoardImageCreateArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BoardImages.
     * @param {BoardImageCreateManyArgs} args - Arguments to create many BoardImages.
     * @example
     * // Create many BoardImages
     * const boardImage = await prisma.boardImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardImageCreateManyArgs>(args?: SelectSubset<T, BoardImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BoardImages and returns the data saved in the database.
     * @param {BoardImageCreateManyAndReturnArgs} args - Arguments to create many BoardImages.
     * @example
     * // Create many BoardImages
     * const boardImage = await prisma.boardImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BoardImages and only return the `id`
     * const boardImageWithIdOnly = await prisma.boardImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardImageCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BoardImage.
     * @param {BoardImageDeleteArgs} args - Arguments to delete one BoardImage.
     * @example
     * // Delete one BoardImage
     * const BoardImage = await prisma.boardImage.delete({
     *   where: {
     *     // ... filter to delete one BoardImage
     *   }
     * })
     * 
     */
    delete<T extends BoardImageDeleteArgs>(args: SelectSubset<T, BoardImageDeleteArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BoardImage.
     * @param {BoardImageUpdateArgs} args - Arguments to update one BoardImage.
     * @example
     * // Update one BoardImage
     * const boardImage = await prisma.boardImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardImageUpdateArgs>(args: SelectSubset<T, BoardImageUpdateArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BoardImages.
     * @param {BoardImageDeleteManyArgs} args - Arguments to filter BoardImages to delete.
     * @example
     * // Delete a few BoardImages
     * const { count } = await prisma.boardImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardImageDeleteManyArgs>(args?: SelectSubset<T, BoardImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardImages
     * const boardImage = await prisma.boardImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardImageUpdateManyArgs>(args: SelectSubset<T, BoardImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardImages and returns the data updated in the database.
     * @param {BoardImageUpdateManyAndReturnArgs} args - Arguments to update many BoardImages.
     * @example
     * // Update many BoardImages
     * const boardImage = await prisma.boardImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BoardImages and only return the `id`
     * const boardImageWithIdOnly = await prisma.boardImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardImageUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BoardImage.
     * @param {BoardImageUpsertArgs} args - Arguments to update or create a BoardImage.
     * @example
     * // Update or create a BoardImage
     * const boardImage = await prisma.boardImage.upsert({
     *   create: {
     *     // ... data to create a BoardImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardImage we want to update
     *   }
     * })
     */
    upsert<T extends BoardImageUpsertArgs>(args: SelectSubset<T, BoardImageUpsertArgs<ExtArgs>>): Prisma__BoardImageClient<$Result.GetResult<Prisma.$BoardImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BoardImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageCountArgs} args - Arguments to filter BoardImages to count.
     * @example
     * // Count the number of BoardImages
     * const count = await prisma.boardImage.count({
     *   where: {
     *     // ... the filter for the BoardImages we want to count
     *   }
     * })
    **/
    count<T extends BoardImageCountArgs>(
      args?: Subset<T, BoardImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardImageAggregateArgs>(args: Subset<T, BoardImageAggregateArgs>): Prisma.PrismaPromise<GetBoardImageAggregateType<T>>

    /**
     * Group by BoardImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardImageGroupByArgs['orderBy'] }
        : { orderBy?: BoardImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoardImage model
   */
  readonly fields: BoardImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoardImage model
   */
  interface BoardImageFieldRefs {
    readonly id: FieldRef<"BoardImage", 'Int'>
    readonly createdAt: FieldRef<"BoardImage", 'DateTime'>
    readonly url: FieldRef<"BoardImage", 'String'>
    readonly thumbnailUrl: FieldRef<"BoardImage", 'String'>
    readonly width: FieldRef<"BoardImage", 'Int'>
    readonly height: FieldRef<"BoardImage", 'Int'>
    readonly size: FieldRef<"BoardImage", 'Int'>
    readonly isThumb: FieldRef<"BoardImage", 'Boolean'>
    readonly isDisable: FieldRef<"BoardImage", 'Boolean'>
    readonly boardId: FieldRef<"BoardImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BoardImage findUnique
   */
  export type BoardImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * Filter, which BoardImage to fetch.
     */
    where: BoardImageWhereUniqueInput
  }

  /**
   * BoardImage findUniqueOrThrow
   */
  export type BoardImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * Filter, which BoardImage to fetch.
     */
    where: BoardImageWhereUniqueInput
  }

  /**
   * BoardImage findFirst
   */
  export type BoardImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * Filter, which BoardImage to fetch.
     */
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     */
    orderBy?: BoardImageOrderByWithRelationInput | BoardImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardImages.
     */
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardImages.
     */
    distinct?: BoardImageScalarFieldEnum | BoardImageScalarFieldEnum[]
  }

  /**
   * BoardImage findFirstOrThrow
   */
  export type BoardImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * Filter, which BoardImage to fetch.
     */
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     */
    orderBy?: BoardImageOrderByWithRelationInput | BoardImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardImages.
     */
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardImages.
     */
    distinct?: BoardImageScalarFieldEnum | BoardImageScalarFieldEnum[]
  }

  /**
   * BoardImage findMany
   */
  export type BoardImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * Filter, which BoardImages to fetch.
     */
    where?: BoardImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardImages to fetch.
     */
    orderBy?: BoardImageOrderByWithRelationInput | BoardImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardImages.
     */
    cursor?: BoardImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardImages.
     */
    skip?: number
    distinct?: BoardImageScalarFieldEnum | BoardImageScalarFieldEnum[]
  }

  /**
   * BoardImage create
   */
  export type BoardImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * The data needed to create a BoardImage.
     */
    data: XOR<BoardImageCreateInput, BoardImageUncheckedCreateInput>
  }

  /**
   * BoardImage createMany
   */
  export type BoardImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoardImages.
     */
    data: BoardImageCreateManyInput | BoardImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoardImage createManyAndReturn
   */
  export type BoardImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * The data used to create many BoardImages.
     */
    data: BoardImageCreateManyInput | BoardImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardImage update
   */
  export type BoardImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * The data needed to update a BoardImage.
     */
    data: XOR<BoardImageUpdateInput, BoardImageUncheckedUpdateInput>
    /**
     * Choose, which BoardImage to update.
     */
    where: BoardImageWhereUniqueInput
  }

  /**
   * BoardImage updateMany
   */
  export type BoardImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoardImages.
     */
    data: XOR<BoardImageUpdateManyMutationInput, BoardImageUncheckedUpdateManyInput>
    /**
     * Filter which BoardImages to update
     */
    where?: BoardImageWhereInput
    /**
     * Limit how many BoardImages to update.
     */
    limit?: number
  }

  /**
   * BoardImage updateManyAndReturn
   */
  export type BoardImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * The data used to update BoardImages.
     */
    data: XOR<BoardImageUpdateManyMutationInput, BoardImageUncheckedUpdateManyInput>
    /**
     * Filter which BoardImages to update
     */
    where?: BoardImageWhereInput
    /**
     * Limit how many BoardImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardImage upsert
   */
  export type BoardImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * The filter to search for the BoardImage to update in case it exists.
     */
    where: BoardImageWhereUniqueInput
    /**
     * In case the BoardImage found by the `where` argument doesn't exist, create a new BoardImage with this data.
     */
    create: XOR<BoardImageCreateInput, BoardImageUncheckedCreateInput>
    /**
     * In case the BoardImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardImageUpdateInput, BoardImageUncheckedUpdateInput>
  }

  /**
   * BoardImage delete
   */
  export type BoardImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
    /**
     * Filter which BoardImage to delete.
     */
    where: BoardImageWhereUniqueInput
  }

  /**
   * BoardImage deleteMany
   */
  export type BoardImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardImages to delete
     */
    where?: BoardImageWhereInput
    /**
     * Limit how many BoardImages to delete.
     */
    limit?: number
  }

  /**
   * BoardImage without action
   */
  export type BoardImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardImage
     */
    select?: BoardImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardImage
     */
    omit?: BoardImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardImageInclude<ExtArgs> | null
  }


  /**
   * Model BoardReply
   */

  export type AggregateBoardReply = {
    _count: BoardReplyCountAggregateOutputType | null
    _avg: BoardReplyAvgAggregateOutputType | null
    _sum: BoardReplySumAggregateOutputType | null
    _min: BoardReplyMinAggregateOutputType | null
    _max: BoardReplyMaxAggregateOutputType | null
  }

  export type BoardReplyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplySumAggregateOutputType = {
    id: number | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplyMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    isDisable: boolean | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplyMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    content: string | null
    isDisable: boolean | null
    userId: number | null
    boardId: number | null
    boardReplyId: number | null
  }

  export type BoardReplyCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    content: number
    isDisable: number
    userId: number
    boardId: number
    boardReplyId: number
    _all: number
  }


  export type BoardReplyAvgAggregateInputType = {
    id?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplySumAggregateInputType = {
    id?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplyMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    isDisable?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    isDisable?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
  }

  export type BoardReplyCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    content?: true
    isDisable?: true
    userId?: true
    boardId?: true
    boardReplyId?: true
    _all?: true
  }

  export type BoardReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardReply to aggregate.
     */
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     */
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardReplies
    **/
    _count?: true | BoardReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardReplyMaxAggregateInputType
  }

  export type GetBoardReplyAggregateType<T extends BoardReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardReply[P]>
      : GetScalarType<T[P], AggregateBoardReply[P]>
  }




  export type BoardReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardReplyWhereInput
    orderBy?: BoardReplyOrderByWithAggregationInput | BoardReplyOrderByWithAggregationInput[]
    by: BoardReplyScalarFieldEnum[] | BoardReplyScalarFieldEnum
    having?: BoardReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardReplyCountAggregateInputType | true
    _avg?: BoardReplyAvgAggregateInputType
    _sum?: BoardReplySumAggregateInputType
    _min?: BoardReplyMinAggregateInputType
    _max?: BoardReplyMaxAggregateInputType
  }

  export type BoardReplyGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date | null
    content: string
    isDisable: boolean
    userId: number
    boardId: number
    boardReplyId: number | null
    _count: BoardReplyCountAggregateOutputType | null
    _avg: BoardReplyAvgAggregateOutputType | null
    _sum: BoardReplySumAggregateOutputType | null
    _min: BoardReplyMinAggregateOutputType | null
    _max: BoardReplyMaxAggregateOutputType | null
  }

  type GetBoardReplyGroupByPayload<T extends BoardReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardReplyGroupByOutputType[P]>
            : GetScalarType<T[P], BoardReplyGroupByOutputType[P]>
        }
      >
    >


  export type BoardReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    isDisable?: boolean
    userId?: boolean
    boardId?: boolean
    boardReplyId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    BoardReply?: boolean | BoardReply$BoardReplyArgs<ExtArgs>
    BoardNestedReplies?: boolean | BoardReply$BoardNestedRepliesArgs<ExtArgs>
    _count?: boolean | BoardReplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardReply"]>

  export type BoardReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    isDisable?: boolean
    userId?: boolean
    boardId?: boolean
    boardReplyId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    BoardReply?: boolean | BoardReply$BoardReplyArgs<ExtArgs>
  }, ExtArgs["result"]["boardReply"]>

  export type BoardReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    isDisable?: boolean
    userId?: boolean
    boardId?: boolean
    boardReplyId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    BoardReply?: boolean | BoardReply$BoardReplyArgs<ExtArgs>
  }, ExtArgs["result"]["boardReply"]>

  export type BoardReplySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean
    isDisable?: boolean
    userId?: boolean
    boardId?: boolean
    boardReplyId?: boolean
  }

  export type BoardReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "content" | "isDisable" | "userId" | "boardId" | "boardReplyId", ExtArgs["result"]["boardReply"]>
  export type BoardReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    BoardReply?: boolean | BoardReply$BoardReplyArgs<ExtArgs>
    BoardNestedReplies?: boolean | BoardReply$BoardNestedRepliesArgs<ExtArgs>
    _count?: boolean | BoardReplyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    BoardReply?: boolean | BoardReply$BoardReplyArgs<ExtArgs>
  }
  export type BoardReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    BoardReply?: boolean | BoardReply$BoardReplyArgs<ExtArgs>
  }

  export type $BoardReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoardReply"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Board: Prisma.$BoardPayload<ExtArgs>
      BoardReply: Prisma.$BoardReplyPayload<ExtArgs> | null
      BoardNestedReplies: Prisma.$BoardReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date | null
      content: string
      isDisable: boolean
      userId: number
      boardId: number
      boardReplyId: number | null
    }, ExtArgs["result"]["boardReply"]>
    composites: {}
  }

  type BoardReplyGetPayload<S extends boolean | null | undefined | BoardReplyDefaultArgs> = $Result.GetResult<Prisma.$BoardReplyPayload, S>

  type BoardReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardReplyCountAggregateInputType | true
    }

  export interface BoardReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoardReply'], meta: { name: 'BoardReply' } }
    /**
     * Find zero or one BoardReply that matches the filter.
     * @param {BoardReplyFindUniqueArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardReplyFindUniqueArgs>(args: SelectSubset<T, BoardReplyFindUniqueArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BoardReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardReplyFindUniqueOrThrowArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyFindFirstArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardReplyFindFirstArgs>(args?: SelectSubset<T, BoardReplyFindFirstArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyFindFirstOrThrowArgs} args - Arguments to find a BoardReply
     * @example
     * // Get one BoardReply
     * const boardReply = await prisma.boardReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BoardReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardReplies
     * const boardReplies = await prisma.boardReply.findMany()
     * 
     * // Get first 10 BoardReplies
     * const boardReplies = await prisma.boardReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardReplyWithIdOnly = await prisma.boardReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardReplyFindManyArgs>(args?: SelectSubset<T, BoardReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BoardReply.
     * @param {BoardReplyCreateArgs} args - Arguments to create a BoardReply.
     * @example
     * // Create one BoardReply
     * const BoardReply = await prisma.boardReply.create({
     *   data: {
     *     // ... data to create a BoardReply
     *   }
     * })
     * 
     */
    create<T extends BoardReplyCreateArgs>(args: SelectSubset<T, BoardReplyCreateArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BoardReplies.
     * @param {BoardReplyCreateManyArgs} args - Arguments to create many BoardReplies.
     * @example
     * // Create many BoardReplies
     * const boardReply = await prisma.boardReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardReplyCreateManyArgs>(args?: SelectSubset<T, BoardReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BoardReplies and returns the data saved in the database.
     * @param {BoardReplyCreateManyAndReturnArgs} args - Arguments to create many BoardReplies.
     * @example
     * // Create many BoardReplies
     * const boardReply = await prisma.boardReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BoardReplies and only return the `id`
     * const boardReplyWithIdOnly = await prisma.boardReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BoardReply.
     * @param {BoardReplyDeleteArgs} args - Arguments to delete one BoardReply.
     * @example
     * // Delete one BoardReply
     * const BoardReply = await prisma.boardReply.delete({
     *   where: {
     *     // ... filter to delete one BoardReply
     *   }
     * })
     * 
     */
    delete<T extends BoardReplyDeleteArgs>(args: SelectSubset<T, BoardReplyDeleteArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BoardReply.
     * @param {BoardReplyUpdateArgs} args - Arguments to update one BoardReply.
     * @example
     * // Update one BoardReply
     * const boardReply = await prisma.boardReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardReplyUpdateArgs>(args: SelectSubset<T, BoardReplyUpdateArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BoardReplies.
     * @param {BoardReplyDeleteManyArgs} args - Arguments to filter BoardReplies to delete.
     * @example
     * // Delete a few BoardReplies
     * const { count } = await prisma.boardReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardReplyDeleteManyArgs>(args?: SelectSubset<T, BoardReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardReplies
     * const boardReply = await prisma.boardReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardReplyUpdateManyArgs>(args: SelectSubset<T, BoardReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardReplies and returns the data updated in the database.
     * @param {BoardReplyUpdateManyAndReturnArgs} args - Arguments to update many BoardReplies.
     * @example
     * // Update many BoardReplies
     * const boardReply = await prisma.boardReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BoardReplies and only return the `id`
     * const boardReplyWithIdOnly = await prisma.boardReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BoardReply.
     * @param {BoardReplyUpsertArgs} args - Arguments to update or create a BoardReply.
     * @example
     * // Update or create a BoardReply
     * const boardReply = await prisma.boardReply.upsert({
     *   create: {
     *     // ... data to create a BoardReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardReply we want to update
     *   }
     * })
     */
    upsert<T extends BoardReplyUpsertArgs>(args: SelectSubset<T, BoardReplyUpsertArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BoardReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyCountArgs} args - Arguments to filter BoardReplies to count.
     * @example
     * // Count the number of BoardReplies
     * const count = await prisma.boardReply.count({
     *   where: {
     *     // ... the filter for the BoardReplies we want to count
     *   }
     * })
    **/
    count<T extends BoardReplyCountArgs>(
      args?: Subset<T, BoardReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardReplyAggregateArgs>(args: Subset<T, BoardReplyAggregateArgs>): Prisma.PrismaPromise<GetBoardReplyAggregateType<T>>

    /**
     * Group by BoardReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardReplyGroupByArgs['orderBy'] }
        : { orderBy?: BoardReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoardReply model
   */
  readonly fields: BoardReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    BoardReply<T extends BoardReply$BoardReplyArgs<ExtArgs> = {}>(args?: Subset<T, BoardReply$BoardReplyArgs<ExtArgs>>): Prisma__BoardReplyClient<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    BoardNestedReplies<T extends BoardReply$BoardNestedRepliesArgs<ExtArgs> = {}>(args?: Subset<T, BoardReply$BoardNestedRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoardReply model
   */
  interface BoardReplyFieldRefs {
    readonly id: FieldRef<"BoardReply", 'Int'>
    readonly createdAt: FieldRef<"BoardReply", 'DateTime'>
    readonly updatedAt: FieldRef<"BoardReply", 'DateTime'>
    readonly content: FieldRef<"BoardReply", 'String'>
    readonly isDisable: FieldRef<"BoardReply", 'Boolean'>
    readonly userId: FieldRef<"BoardReply", 'Int'>
    readonly boardId: FieldRef<"BoardReply", 'Int'>
    readonly boardReplyId: FieldRef<"BoardReply", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BoardReply findUnique
   */
  export type BoardReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * Filter, which BoardReply to fetch.
     */
    where: BoardReplyWhereUniqueInput
  }

  /**
   * BoardReply findUniqueOrThrow
   */
  export type BoardReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * Filter, which BoardReply to fetch.
     */
    where: BoardReplyWhereUniqueInput
  }

  /**
   * BoardReply findFirst
   */
  export type BoardReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * Filter, which BoardReply to fetch.
     */
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     */
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardReplies.
     */
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardReplies.
     */
    distinct?: BoardReplyScalarFieldEnum | BoardReplyScalarFieldEnum[]
  }

  /**
   * BoardReply findFirstOrThrow
   */
  export type BoardReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * Filter, which BoardReply to fetch.
     */
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     */
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardReplies.
     */
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardReplies.
     */
    distinct?: BoardReplyScalarFieldEnum | BoardReplyScalarFieldEnum[]
  }

  /**
   * BoardReply findMany
   */
  export type BoardReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * Filter, which BoardReplies to fetch.
     */
    where?: BoardReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardReplies to fetch.
     */
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardReplies.
     */
    cursor?: BoardReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardReplies.
     */
    skip?: number
    distinct?: BoardReplyScalarFieldEnum | BoardReplyScalarFieldEnum[]
  }

  /**
   * BoardReply create
   */
  export type BoardReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a BoardReply.
     */
    data: XOR<BoardReplyCreateInput, BoardReplyUncheckedCreateInput>
  }

  /**
   * BoardReply createMany
   */
  export type BoardReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoardReplies.
     */
    data: BoardReplyCreateManyInput | BoardReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoardReply createManyAndReturn
   */
  export type BoardReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * The data used to create many BoardReplies.
     */
    data: BoardReplyCreateManyInput | BoardReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardReply update
   */
  export type BoardReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a BoardReply.
     */
    data: XOR<BoardReplyUpdateInput, BoardReplyUncheckedUpdateInput>
    /**
     * Choose, which BoardReply to update.
     */
    where: BoardReplyWhereUniqueInput
  }

  /**
   * BoardReply updateMany
   */
  export type BoardReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoardReplies.
     */
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyInput>
    /**
     * Filter which BoardReplies to update
     */
    where?: BoardReplyWhereInput
    /**
     * Limit how many BoardReplies to update.
     */
    limit?: number
  }

  /**
   * BoardReply updateManyAndReturn
   */
  export type BoardReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * The data used to update BoardReplies.
     */
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyInput>
    /**
     * Filter which BoardReplies to update
     */
    where?: BoardReplyWhereInput
    /**
     * Limit how many BoardReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardReply upsert
   */
  export type BoardReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the BoardReply to update in case it exists.
     */
    where: BoardReplyWhereUniqueInput
    /**
     * In case the BoardReply found by the `where` argument doesn't exist, create a new BoardReply with this data.
     */
    create: XOR<BoardReplyCreateInput, BoardReplyUncheckedCreateInput>
    /**
     * In case the BoardReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardReplyUpdateInput, BoardReplyUncheckedUpdateInput>
  }

  /**
   * BoardReply delete
   */
  export type BoardReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    /**
     * Filter which BoardReply to delete.
     */
    where: BoardReplyWhereUniqueInput
  }

  /**
   * BoardReply deleteMany
   */
  export type BoardReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardReplies to delete
     */
    where?: BoardReplyWhereInput
    /**
     * Limit how many BoardReplies to delete.
     */
    limit?: number
  }

  /**
   * BoardReply.BoardReply
   */
  export type BoardReply$BoardReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    where?: BoardReplyWhereInput
  }

  /**
   * BoardReply.BoardNestedReplies
   */
  export type BoardReply$BoardNestedRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
    where?: BoardReplyWhereInput
    orderBy?: BoardReplyOrderByWithRelationInput | BoardReplyOrderByWithRelationInput[]
    cursor?: BoardReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardReplyScalarFieldEnum | BoardReplyScalarFieldEnum[]
  }

  /**
   * BoardReply without action
   */
  export type BoardReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardReply
     */
    select?: BoardReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardReply
     */
    omit?: BoardReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardReplyInclude<ExtArgs> | null
  }


  /**
   * Model CafeBoard
   */

  export type AggregateCafeBoard = {
    _count: CafeBoardCountAggregateOutputType | null
    _avg: CafeBoardAvgAggregateOutputType | null
    _sum: CafeBoardSumAggregateOutputType | null
    _min: CafeBoardMinAggregateOutputType | null
    _max: CafeBoardMaxAggregateOutputType | null
  }

  export type CafeBoardAvgAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
  }

  export type CafeBoardSumAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
  }

  export type CafeBoardMinAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
    createdAt: Date | null
  }

  export type CafeBoardMaxAggregateOutputType = {
    boardId: number | null
    cafeInfoId: number | null
    createdAt: Date | null
  }

  export type CafeBoardCountAggregateOutputType = {
    boardId: number
    cafeInfoId: number
    createdAt: number
    _all: number
  }


  export type CafeBoardAvgAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
  }

  export type CafeBoardSumAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
  }

  export type CafeBoardMinAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
    createdAt?: true
  }

  export type CafeBoardMaxAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
    createdAt?: true
  }

  export type CafeBoardCountAggregateInputType = {
    boardId?: true
    cafeInfoId?: true
    createdAt?: true
    _all?: true
  }

  export type CafeBoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeBoard to aggregate.
     */
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     */
    orderBy?: CafeBoardOrderByWithRelationInput | CafeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeBoards
    **/
    _count?: true | CafeBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeBoardMaxAggregateInputType
  }

  export type GetCafeBoardAggregateType<T extends CafeBoardAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeBoard[P]>
      : GetScalarType<T[P], AggregateCafeBoard[P]>
  }




  export type CafeBoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeBoardWhereInput
    orderBy?: CafeBoardOrderByWithAggregationInput | CafeBoardOrderByWithAggregationInput[]
    by: CafeBoardScalarFieldEnum[] | CafeBoardScalarFieldEnum
    having?: CafeBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeBoardCountAggregateInputType | true
    _avg?: CafeBoardAvgAggregateInputType
    _sum?: CafeBoardSumAggregateInputType
    _min?: CafeBoardMinAggregateInputType
    _max?: CafeBoardMaxAggregateInputType
  }

  export type CafeBoardGroupByOutputType = {
    boardId: number
    cafeInfoId: number
    createdAt: Date
    _count: CafeBoardCountAggregateOutputType | null
    _avg: CafeBoardAvgAggregateOutputType | null
    _sum: CafeBoardSumAggregateOutputType | null
    _min: CafeBoardMinAggregateOutputType | null
    _max: CafeBoardMaxAggregateOutputType | null
  }

  type GetCafeBoardGroupByPayload<T extends CafeBoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeBoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeBoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeBoardGroupByOutputType[P]>
            : GetScalarType<T[P], CafeBoardGroupByOutputType[P]>
        }
      >
    >


  export type CafeBoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boardId?: boolean
    cafeInfoId?: boolean
    createdAt?: boolean
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeBoard"]>

  export type CafeBoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boardId?: boolean
    cafeInfoId?: boolean
    createdAt?: boolean
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeBoard"]>

  export type CafeBoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boardId?: boolean
    cafeInfoId?: boolean
    createdAt?: boolean
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeBoard"]>

  export type CafeBoardSelectScalar = {
    boardId?: boolean
    cafeInfoId?: boolean
    createdAt?: boolean
  }

  export type CafeBoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"boardId" | "cafeInfoId" | "createdAt", ExtArgs["result"]["cafeBoard"]>
  export type CafeBoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeBoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeBoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $CafeBoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeBoard"
    objects: {
      Board: Prisma.$BoardPayload<ExtArgs>
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      boardId: number
      cafeInfoId: number
      createdAt: Date
    }, ExtArgs["result"]["cafeBoard"]>
    composites: {}
  }

  type CafeBoardGetPayload<S extends boolean | null | undefined | CafeBoardDefaultArgs> = $Result.GetResult<Prisma.$CafeBoardPayload, S>

  type CafeBoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeBoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeBoardCountAggregateInputType | true
    }

  export interface CafeBoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeBoard'], meta: { name: 'CafeBoard' } }
    /**
     * Find zero or one CafeBoard that matches the filter.
     * @param {CafeBoardFindUniqueArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeBoardFindUniqueArgs>(args: SelectSubset<T, CafeBoardFindUniqueArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeBoard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeBoardFindUniqueOrThrowArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeBoardFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeBoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardFindFirstArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeBoardFindFirstArgs>(args?: SelectSubset<T, CafeBoardFindFirstArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeBoard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardFindFirstOrThrowArgs} args - Arguments to find a CafeBoard
     * @example
     * // Get one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeBoardFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeBoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeBoards
     * const cafeBoards = await prisma.cafeBoard.findMany()
     * 
     * // Get first 10 CafeBoards
     * const cafeBoards = await prisma.cafeBoard.findMany({ take: 10 })
     * 
     * // Only select the `boardId`
     * const cafeBoardWithBoardIdOnly = await prisma.cafeBoard.findMany({ select: { boardId: true } })
     * 
     */
    findMany<T extends CafeBoardFindManyArgs>(args?: SelectSubset<T, CafeBoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeBoard.
     * @param {CafeBoardCreateArgs} args - Arguments to create a CafeBoard.
     * @example
     * // Create one CafeBoard
     * const CafeBoard = await prisma.cafeBoard.create({
     *   data: {
     *     // ... data to create a CafeBoard
     *   }
     * })
     * 
     */
    create<T extends CafeBoardCreateArgs>(args: SelectSubset<T, CafeBoardCreateArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeBoards.
     * @param {CafeBoardCreateManyArgs} args - Arguments to create many CafeBoards.
     * @example
     * // Create many CafeBoards
     * const cafeBoard = await prisma.cafeBoard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeBoardCreateManyArgs>(args?: SelectSubset<T, CafeBoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeBoards and returns the data saved in the database.
     * @param {CafeBoardCreateManyAndReturnArgs} args - Arguments to create many CafeBoards.
     * @example
     * // Create many CafeBoards
     * const cafeBoard = await prisma.cafeBoard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeBoards and only return the `boardId`
     * const cafeBoardWithBoardIdOnly = await prisma.cafeBoard.createManyAndReturn({
     *   select: { boardId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeBoardCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeBoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeBoard.
     * @param {CafeBoardDeleteArgs} args - Arguments to delete one CafeBoard.
     * @example
     * // Delete one CafeBoard
     * const CafeBoard = await prisma.cafeBoard.delete({
     *   where: {
     *     // ... filter to delete one CafeBoard
     *   }
     * })
     * 
     */
    delete<T extends CafeBoardDeleteArgs>(args: SelectSubset<T, CafeBoardDeleteArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeBoard.
     * @param {CafeBoardUpdateArgs} args - Arguments to update one CafeBoard.
     * @example
     * // Update one CafeBoard
     * const cafeBoard = await prisma.cafeBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeBoardUpdateArgs>(args: SelectSubset<T, CafeBoardUpdateArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeBoards.
     * @param {CafeBoardDeleteManyArgs} args - Arguments to filter CafeBoards to delete.
     * @example
     * // Delete a few CafeBoards
     * const { count } = await prisma.cafeBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeBoardDeleteManyArgs>(args?: SelectSubset<T, CafeBoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeBoards
     * const cafeBoard = await prisma.cafeBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeBoardUpdateManyArgs>(args: SelectSubset<T, CafeBoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeBoards and returns the data updated in the database.
     * @param {CafeBoardUpdateManyAndReturnArgs} args - Arguments to update many CafeBoards.
     * @example
     * // Update many CafeBoards
     * const cafeBoard = await prisma.cafeBoard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeBoards and only return the `boardId`
     * const cafeBoardWithBoardIdOnly = await prisma.cafeBoard.updateManyAndReturn({
     *   select: { boardId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeBoardUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeBoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeBoard.
     * @param {CafeBoardUpsertArgs} args - Arguments to update or create a CafeBoard.
     * @example
     * // Update or create a CafeBoard
     * const cafeBoard = await prisma.cafeBoard.upsert({
     *   create: {
     *     // ... data to create a CafeBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeBoard we want to update
     *   }
     * })
     */
    upsert<T extends CafeBoardUpsertArgs>(args: SelectSubset<T, CafeBoardUpsertArgs<ExtArgs>>): Prisma__CafeBoardClient<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardCountArgs} args - Arguments to filter CafeBoards to count.
     * @example
     * // Count the number of CafeBoards
     * const count = await prisma.cafeBoard.count({
     *   where: {
     *     // ... the filter for the CafeBoards we want to count
     *   }
     * })
    **/
    count<T extends CafeBoardCountArgs>(
      args?: Subset<T, CafeBoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeBoardAggregateArgs>(args: Subset<T, CafeBoardAggregateArgs>): Prisma.PrismaPromise<GetCafeBoardAggregateType<T>>

    /**
     * Group by CafeBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeBoardGroupByArgs['orderBy'] }
        : { orderBy?: CafeBoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeBoard model
   */
  readonly fields: CafeBoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeBoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeBoard model
   */
  interface CafeBoardFieldRefs {
    readonly boardId: FieldRef<"CafeBoard", 'Int'>
    readonly cafeInfoId: FieldRef<"CafeBoard", 'Int'>
    readonly createdAt: FieldRef<"CafeBoard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CafeBoard findUnique
   */
  export type CafeBoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * Filter, which CafeBoard to fetch.
     */
    where: CafeBoardWhereUniqueInput
  }

  /**
   * CafeBoard findUniqueOrThrow
   */
  export type CafeBoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * Filter, which CafeBoard to fetch.
     */
    where: CafeBoardWhereUniqueInput
  }

  /**
   * CafeBoard findFirst
   */
  export type CafeBoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * Filter, which CafeBoard to fetch.
     */
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     */
    orderBy?: CafeBoardOrderByWithRelationInput | CafeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeBoards.
     */
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeBoards.
     */
    distinct?: CafeBoardScalarFieldEnum | CafeBoardScalarFieldEnum[]
  }

  /**
   * CafeBoard findFirstOrThrow
   */
  export type CafeBoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * Filter, which CafeBoard to fetch.
     */
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     */
    orderBy?: CafeBoardOrderByWithRelationInput | CafeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeBoards.
     */
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeBoards.
     */
    distinct?: CafeBoardScalarFieldEnum | CafeBoardScalarFieldEnum[]
  }

  /**
   * CafeBoard findMany
   */
  export type CafeBoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * Filter, which CafeBoards to fetch.
     */
    where?: CafeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeBoards to fetch.
     */
    orderBy?: CafeBoardOrderByWithRelationInput | CafeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeBoards.
     */
    cursor?: CafeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeBoards.
     */
    skip?: number
    distinct?: CafeBoardScalarFieldEnum | CafeBoardScalarFieldEnum[]
  }

  /**
   * CafeBoard create
   */
  export type CafeBoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeBoard.
     */
    data: XOR<CafeBoardCreateInput, CafeBoardUncheckedCreateInput>
  }

  /**
   * CafeBoard createMany
   */
  export type CafeBoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeBoards.
     */
    data: CafeBoardCreateManyInput | CafeBoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeBoard createManyAndReturn
   */
  export type CafeBoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * The data used to create many CafeBoards.
     */
    data: CafeBoardCreateManyInput | CafeBoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeBoard update
   */
  export type CafeBoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeBoard.
     */
    data: XOR<CafeBoardUpdateInput, CafeBoardUncheckedUpdateInput>
    /**
     * Choose, which CafeBoard to update.
     */
    where: CafeBoardWhereUniqueInput
  }

  /**
   * CafeBoard updateMany
   */
  export type CafeBoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeBoards.
     */
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyInput>
    /**
     * Filter which CafeBoards to update
     */
    where?: CafeBoardWhereInput
    /**
     * Limit how many CafeBoards to update.
     */
    limit?: number
  }

  /**
   * CafeBoard updateManyAndReturn
   */
  export type CafeBoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * The data used to update CafeBoards.
     */
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyInput>
    /**
     * Filter which CafeBoards to update
     */
    where?: CafeBoardWhereInput
    /**
     * Limit how many CafeBoards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeBoard upsert
   */
  export type CafeBoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeBoard to update in case it exists.
     */
    where: CafeBoardWhereUniqueInput
    /**
     * In case the CafeBoard found by the `where` argument doesn't exist, create a new CafeBoard with this data.
     */
    create: XOR<CafeBoardCreateInput, CafeBoardUncheckedCreateInput>
    /**
     * In case the CafeBoard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeBoardUpdateInput, CafeBoardUncheckedUpdateInput>
  }

  /**
   * CafeBoard delete
   */
  export type CafeBoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    /**
     * Filter which CafeBoard to delete.
     */
    where: CafeBoardWhereUniqueInput
  }

  /**
   * CafeBoard deleteMany
   */
  export type CafeBoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeBoards to delete
     */
    where?: CafeBoardWhereInput
    /**
     * Limit how many CafeBoards to delete.
     */
    limit?: number
  }

  /**
   * CafeBoard without action
   */
  export type CafeBoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
  }


  /**
   * Model RegionCategory
   */

  export type AggregateRegionCategory = {
    _count: RegionCategoryCountAggregateOutputType | null
    _avg: RegionCategoryAvgAggregateOutputType | null
    _sum: RegionCategorySumAggregateOutputType | null
    _min: RegionCategoryMinAggregateOutputType | null
    _max: RegionCategoryMaxAggregateOutputType | null
  }

  export type RegionCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionCategorySumAggregateOutputType = {
    id: number | null
  }

  export type RegionCategoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    isDisable: boolean | null
    govermentType: $Enums.GovermentType | null
  }

  export type RegionCategoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    isDisable: boolean | null
    govermentType: $Enums.GovermentType | null
  }

  export type RegionCategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    isDisable: number
    govermentType: number
    _all: number
  }


  export type RegionCategoryAvgAggregateInputType = {
    id?: true
  }

  export type RegionCategorySumAggregateInputType = {
    id?: true
  }

  export type RegionCategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    isDisable?: true
    govermentType?: true
  }

  export type RegionCategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    isDisable?: true
    govermentType?: true
  }

  export type RegionCategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    isDisable?: true
    govermentType?: true
    _all?: true
  }

  export type RegionCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionCategory to aggregate.
     */
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     */
    orderBy?: RegionCategoryOrderByWithRelationInput | RegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionCategories
    **/
    _count?: true | RegionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionCategoryMaxAggregateInputType
  }

  export type GetRegionCategoryAggregateType<T extends RegionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionCategory[P]>
      : GetScalarType<T[P], AggregateRegionCategory[P]>
  }




  export type RegionCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionCategoryWhereInput
    orderBy?: RegionCategoryOrderByWithAggregationInput | RegionCategoryOrderByWithAggregationInput[]
    by: RegionCategoryScalarFieldEnum[] | RegionCategoryScalarFieldEnum
    having?: RegionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCategoryCountAggregateInputType | true
    _avg?: RegionCategoryAvgAggregateInputType
    _sum?: RegionCategorySumAggregateInputType
    _min?: RegionCategoryMinAggregateInputType
    _max?: RegionCategoryMaxAggregateInputType
  }

  export type RegionCategoryGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    isDisable: boolean
    govermentType: $Enums.GovermentType
    _count: RegionCategoryCountAggregateOutputType | null
    _avg: RegionCategoryAvgAggregateOutputType | null
    _sum: RegionCategorySumAggregateOutputType | null
    _min: RegionCategoryMinAggregateOutputType | null
    _max: RegionCategoryMaxAggregateOutputType | null
  }

  type GetRegionCategoryGroupByPayload<T extends RegionCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], RegionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type RegionCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    isDisable?: boolean
    govermentType?: boolean
    CafeInfos?: boolean | RegionCategory$CafeInfosArgs<ExtArgs>
    AncestorCategories?: boolean | RegionCategory$AncestorCategoriesArgs<ExtArgs>
    DescendantCategories?: boolean | RegionCategory$DescendantCategoriesArgs<ExtArgs>
    _count?: boolean | RegionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionCategory"]>

  export type RegionCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    isDisable?: boolean
    govermentType?: boolean
  }, ExtArgs["result"]["regionCategory"]>

  export type RegionCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    isDisable?: boolean
    govermentType?: boolean
  }, ExtArgs["result"]["regionCategory"]>

  export type RegionCategorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    isDisable?: boolean
    govermentType?: boolean
  }

  export type RegionCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "isDisable" | "govermentType", ExtArgs["result"]["regionCategory"]>
  export type RegionCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfos?: boolean | RegionCategory$CafeInfosArgs<ExtArgs>
    AncestorCategories?: boolean | RegionCategory$AncestorCategoriesArgs<ExtArgs>
    DescendantCategories?: boolean | RegionCategory$DescendantCategoriesArgs<ExtArgs>
    _count?: boolean | RegionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegionCategory"
    objects: {
      CafeInfos: Prisma.$CafeInfoPayload<ExtArgs>[]
      AncestorCategories: Prisma.$ClosureRegionCategoryPayload<ExtArgs>[]
      DescendantCategories: Prisma.$ClosureRegionCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      isDisable: boolean
      govermentType: $Enums.GovermentType
    }, ExtArgs["result"]["regionCategory"]>
    composites: {}
  }

  type RegionCategoryGetPayload<S extends boolean | null | undefined | RegionCategoryDefaultArgs> = $Result.GetResult<Prisma.$RegionCategoryPayload, S>

  type RegionCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCategoryCountAggregateInputType | true
    }

  export interface RegionCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegionCategory'], meta: { name: 'RegionCategory' } }
    /**
     * Find zero or one RegionCategory that matches the filter.
     * @param {RegionCategoryFindUniqueArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionCategoryFindUniqueArgs>(args: SelectSubset<T, RegionCategoryFindUniqueArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegionCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionCategoryFindUniqueOrThrowArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryFindFirstArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionCategoryFindFirstArgs>(args?: SelectSubset<T, RegionCategoryFindFirstArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryFindFirstOrThrowArgs} args - Arguments to find a RegionCategory
     * @example
     * // Get one RegionCategory
     * const regionCategory = await prisma.regionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionCategories
     * const regionCategories = await prisma.regionCategory.findMany()
     * 
     * // Get first 10 RegionCategories
     * const regionCategories = await prisma.regionCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionCategoryWithIdOnly = await prisma.regionCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionCategoryFindManyArgs>(args?: SelectSubset<T, RegionCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegionCategory.
     * @param {RegionCategoryCreateArgs} args - Arguments to create a RegionCategory.
     * @example
     * // Create one RegionCategory
     * const RegionCategory = await prisma.regionCategory.create({
     *   data: {
     *     // ... data to create a RegionCategory
     *   }
     * })
     * 
     */
    create<T extends RegionCategoryCreateArgs>(args: SelectSubset<T, RegionCategoryCreateArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegionCategories.
     * @param {RegionCategoryCreateManyArgs} args - Arguments to create many RegionCategories.
     * @example
     * // Create many RegionCategories
     * const regionCategory = await prisma.regionCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCategoryCreateManyArgs>(args?: SelectSubset<T, RegionCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegionCategories and returns the data saved in the database.
     * @param {RegionCategoryCreateManyAndReturnArgs} args - Arguments to create many RegionCategories.
     * @example
     * // Create many RegionCategories
     * const regionCategory = await prisma.regionCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegionCategories and only return the `id`
     * const regionCategoryWithIdOnly = await prisma.regionCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegionCategory.
     * @param {RegionCategoryDeleteArgs} args - Arguments to delete one RegionCategory.
     * @example
     * // Delete one RegionCategory
     * const RegionCategory = await prisma.regionCategory.delete({
     *   where: {
     *     // ... filter to delete one RegionCategory
     *   }
     * })
     * 
     */
    delete<T extends RegionCategoryDeleteArgs>(args: SelectSubset<T, RegionCategoryDeleteArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegionCategory.
     * @param {RegionCategoryUpdateArgs} args - Arguments to update one RegionCategory.
     * @example
     * // Update one RegionCategory
     * const regionCategory = await prisma.regionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionCategoryUpdateArgs>(args: SelectSubset<T, RegionCategoryUpdateArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegionCategories.
     * @param {RegionCategoryDeleteManyArgs} args - Arguments to filter RegionCategories to delete.
     * @example
     * // Delete a few RegionCategories
     * const { count } = await prisma.regionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionCategoryDeleteManyArgs>(args?: SelectSubset<T, RegionCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionCategories
     * const regionCategory = await prisma.regionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionCategoryUpdateManyArgs>(args: SelectSubset<T, RegionCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionCategories and returns the data updated in the database.
     * @param {RegionCategoryUpdateManyAndReturnArgs} args - Arguments to update many RegionCategories.
     * @example
     * // Update many RegionCategories
     * const regionCategory = await prisma.regionCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegionCategories and only return the `id`
     * const regionCategoryWithIdOnly = await prisma.regionCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegionCategory.
     * @param {RegionCategoryUpsertArgs} args - Arguments to update or create a RegionCategory.
     * @example
     * // Update or create a RegionCategory
     * const regionCategory = await prisma.regionCategory.upsert({
     *   create: {
     *     // ... data to create a RegionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionCategory we want to update
     *   }
     * })
     */
    upsert<T extends RegionCategoryUpsertArgs>(args: SelectSubset<T, RegionCategoryUpsertArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryCountArgs} args - Arguments to filter RegionCategories to count.
     * @example
     * // Count the number of RegionCategories
     * const count = await prisma.regionCategory.count({
     *   where: {
     *     // ... the filter for the RegionCategories we want to count
     *   }
     * })
    **/
    count<T extends RegionCategoryCountArgs>(
      args?: Subset<T, RegionCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionCategoryAggregateArgs>(args: Subset<T, RegionCategoryAggregateArgs>): Prisma.PrismaPromise<GetRegionCategoryAggregateType<T>>

    /**
     * Group by RegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: RegionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegionCategory model
   */
  readonly fields: RegionCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeInfos<T extends RegionCategory$CafeInfosArgs<ExtArgs> = {}>(args?: Subset<T, RegionCategory$CafeInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AncestorCategories<T extends RegionCategory$AncestorCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, RegionCategory$AncestorCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DescendantCategories<T extends RegionCategory$DescendantCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, RegionCategory$DescendantCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegionCategory model
   */
  interface RegionCategoryFieldRefs {
    readonly id: FieldRef<"RegionCategory", 'Int'>
    readonly createdAt: FieldRef<"RegionCategory", 'DateTime'>
    readonly name: FieldRef<"RegionCategory", 'String'>
    readonly isDisable: FieldRef<"RegionCategory", 'Boolean'>
    readonly govermentType: FieldRef<"RegionCategory", 'GovermentType'>
  }
    

  // Custom InputTypes
  /**
   * RegionCategory findUnique
   */
  export type RegionCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegionCategory to fetch.
     */
    where: RegionCategoryWhereUniqueInput
  }

  /**
   * RegionCategory findUniqueOrThrow
   */
  export type RegionCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegionCategory to fetch.
     */
    where: RegionCategoryWhereUniqueInput
  }

  /**
   * RegionCategory findFirst
   */
  export type RegionCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegionCategory to fetch.
     */
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     */
    orderBy?: RegionCategoryOrderByWithRelationInput | RegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionCategories.
     */
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionCategories.
     */
    distinct?: RegionCategoryScalarFieldEnum | RegionCategoryScalarFieldEnum[]
  }

  /**
   * RegionCategory findFirstOrThrow
   */
  export type RegionCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegionCategory to fetch.
     */
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     */
    orderBy?: RegionCategoryOrderByWithRelationInput | RegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionCategories.
     */
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionCategories.
     */
    distinct?: RegionCategoryScalarFieldEnum | RegionCategoryScalarFieldEnum[]
  }

  /**
   * RegionCategory findMany
   */
  export type RegionCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegionCategories to fetch.
     */
    where?: RegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionCategories to fetch.
     */
    orderBy?: RegionCategoryOrderByWithRelationInput | RegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionCategories.
     */
    cursor?: RegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionCategories.
     */
    skip?: number
    distinct?: RegionCategoryScalarFieldEnum | RegionCategoryScalarFieldEnum[]
  }

  /**
   * RegionCategory create
   */
  export type RegionCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RegionCategory.
     */
    data: XOR<RegionCategoryCreateInput, RegionCategoryUncheckedCreateInput>
  }

  /**
   * RegionCategory createMany
   */
  export type RegionCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegionCategories.
     */
    data: RegionCategoryCreateManyInput | RegionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegionCategory createManyAndReturn
   */
  export type RegionCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many RegionCategories.
     */
    data: RegionCategoryCreateManyInput | RegionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegionCategory update
   */
  export type RegionCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RegionCategory.
     */
    data: XOR<RegionCategoryUpdateInput, RegionCategoryUncheckedUpdateInput>
    /**
     * Choose, which RegionCategory to update.
     */
    where: RegionCategoryWhereUniqueInput
  }

  /**
   * RegionCategory updateMany
   */
  export type RegionCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegionCategories.
     */
    data: XOR<RegionCategoryUpdateManyMutationInput, RegionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which RegionCategories to update
     */
    where?: RegionCategoryWhereInput
    /**
     * Limit how many RegionCategories to update.
     */
    limit?: number
  }

  /**
   * RegionCategory updateManyAndReturn
   */
  export type RegionCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * The data used to update RegionCategories.
     */
    data: XOR<RegionCategoryUpdateManyMutationInput, RegionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which RegionCategories to update
     */
    where?: RegionCategoryWhereInput
    /**
     * Limit how many RegionCategories to update.
     */
    limit?: number
  }

  /**
   * RegionCategory upsert
   */
  export type RegionCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RegionCategory to update in case it exists.
     */
    where: RegionCategoryWhereUniqueInput
    /**
     * In case the RegionCategory found by the `where` argument doesn't exist, create a new RegionCategory with this data.
     */
    create: XOR<RegionCategoryCreateInput, RegionCategoryUncheckedCreateInput>
    /**
     * In case the RegionCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionCategoryUpdateInput, RegionCategoryUncheckedUpdateInput>
  }

  /**
   * RegionCategory delete
   */
  export type RegionCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
    /**
     * Filter which RegionCategory to delete.
     */
    where: RegionCategoryWhereUniqueInput
  }

  /**
   * RegionCategory deleteMany
   */
  export type RegionCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionCategories to delete
     */
    where?: RegionCategoryWhereInput
    /**
     * Limit how many RegionCategories to delete.
     */
    limit?: number
  }

  /**
   * RegionCategory.CafeInfos
   */
  export type RegionCategory$CafeInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    where?: CafeInfoWhereInput
    orderBy?: CafeInfoOrderByWithRelationInput | CafeInfoOrderByWithRelationInput[]
    cursor?: CafeInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeInfoScalarFieldEnum | CafeInfoScalarFieldEnum[]
  }

  /**
   * RegionCategory.AncestorCategories
   */
  export type RegionCategory$AncestorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    where?: ClosureRegionCategoryWhereInput
    orderBy?: ClosureRegionCategoryOrderByWithRelationInput | ClosureRegionCategoryOrderByWithRelationInput[]
    cursor?: ClosureRegionCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClosureRegionCategoryScalarFieldEnum | ClosureRegionCategoryScalarFieldEnum[]
  }

  /**
   * RegionCategory.DescendantCategories
   */
  export type RegionCategory$DescendantCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    where?: ClosureRegionCategoryWhereInput
    orderBy?: ClosureRegionCategoryOrderByWithRelationInput | ClosureRegionCategoryOrderByWithRelationInput[]
    cursor?: ClosureRegionCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClosureRegionCategoryScalarFieldEnum | ClosureRegionCategoryScalarFieldEnum[]
  }

  /**
   * RegionCategory without action
   */
  export type RegionCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCategory
     */
    select?: RegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionCategory
     */
    omit?: RegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ClosureRegionCategory
   */

  export type AggregateClosureRegionCategory = {
    _count: ClosureRegionCategoryCountAggregateOutputType | null
    _avg: ClosureRegionCategoryAvgAggregateOutputType | null
    _sum: ClosureRegionCategorySumAggregateOutputType | null
    _min: ClosureRegionCategoryMinAggregateOutputType | null
    _max: ClosureRegionCategoryMaxAggregateOutputType | null
  }

  export type ClosureRegionCategoryAvgAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategorySumAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategoryMinAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategoryMaxAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureRegionCategoryCountAggregateOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _all: number
  }


  export type ClosureRegionCategoryAvgAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategorySumAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategoryMinAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategoryMaxAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureRegionCategoryCountAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
    _all?: true
  }

  export type ClosureRegionCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClosureRegionCategory to aggregate.
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     */
    orderBy?: ClosureRegionCategoryOrderByWithRelationInput | ClosureRegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClosureRegionCategories
    **/
    _count?: true | ClosureRegionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClosureRegionCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClosureRegionCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClosureRegionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClosureRegionCategoryMaxAggregateInputType
  }

  export type GetClosureRegionCategoryAggregateType<T extends ClosureRegionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateClosureRegionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClosureRegionCategory[P]>
      : GetScalarType<T[P], AggregateClosureRegionCategory[P]>
  }




  export type ClosureRegionCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosureRegionCategoryWhereInput
    orderBy?: ClosureRegionCategoryOrderByWithAggregationInput | ClosureRegionCategoryOrderByWithAggregationInput[]
    by: ClosureRegionCategoryScalarFieldEnum[] | ClosureRegionCategoryScalarFieldEnum
    having?: ClosureRegionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClosureRegionCategoryCountAggregateInputType | true
    _avg?: ClosureRegionCategoryAvgAggregateInputType
    _sum?: ClosureRegionCategorySumAggregateInputType
    _min?: ClosureRegionCategoryMinAggregateInputType
    _max?: ClosureRegionCategoryMaxAggregateInputType
  }

  export type ClosureRegionCategoryGroupByOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _count: ClosureRegionCategoryCountAggregateOutputType | null
    _avg: ClosureRegionCategoryAvgAggregateOutputType | null
    _sum: ClosureRegionCategorySumAggregateOutputType | null
    _min: ClosureRegionCategoryMinAggregateOutputType | null
    _max: ClosureRegionCategoryMaxAggregateOutputType | null
  }

  type GetClosureRegionCategoryGroupByPayload<T extends ClosureRegionCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClosureRegionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClosureRegionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClosureRegionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ClosureRegionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ClosureRegionCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closureRegionCategory"]>

  export type ClosureRegionCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closureRegionCategory"]>

  export type ClosureRegionCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closureRegionCategory"]>

  export type ClosureRegionCategorySelectScalar = {
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
  }

  export type ClosureRegionCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ancestor" | "descendant" | "depth", ExtArgs["result"]["closureRegionCategory"]>
  export type ClosureRegionCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }
  export type ClosureRegionCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }
  export type ClosureRegionCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }

  export type $ClosureRegionCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClosureRegionCategory"
    objects: {
      AncestorCategory: Prisma.$RegionCategoryPayload<ExtArgs>
      DescendantCategory: Prisma.$RegionCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ancestor: number
      descendant: number
      depth: number
    }, ExtArgs["result"]["closureRegionCategory"]>
    composites: {}
  }

  type ClosureRegionCategoryGetPayload<S extends boolean | null | undefined | ClosureRegionCategoryDefaultArgs> = $Result.GetResult<Prisma.$ClosureRegionCategoryPayload, S>

  type ClosureRegionCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClosureRegionCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClosureRegionCategoryCountAggregateInputType | true
    }

  export interface ClosureRegionCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClosureRegionCategory'], meta: { name: 'ClosureRegionCategory' } }
    /**
     * Find zero or one ClosureRegionCategory that matches the filter.
     * @param {ClosureRegionCategoryFindUniqueArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClosureRegionCategoryFindUniqueArgs>(args: SelectSubset<T, ClosureRegionCategoryFindUniqueArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClosureRegionCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClosureRegionCategoryFindUniqueOrThrowArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClosureRegionCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ClosureRegionCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClosureRegionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryFindFirstArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClosureRegionCategoryFindFirstArgs>(args?: SelectSubset<T, ClosureRegionCategoryFindFirstArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClosureRegionCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryFindFirstOrThrowArgs} args - Arguments to find a ClosureRegionCategory
     * @example
     * // Get one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClosureRegionCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ClosureRegionCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClosureRegionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClosureRegionCategories
     * const closureRegionCategories = await prisma.closureRegionCategory.findMany()
     * 
     * // Get first 10 ClosureRegionCategories
     * const closureRegionCategories = await prisma.closureRegionCategory.findMany({ take: 10 })
     * 
     * // Only select the `ancestor`
     * const closureRegionCategoryWithAncestorOnly = await prisma.closureRegionCategory.findMany({ select: { ancestor: true } })
     * 
     */
    findMany<T extends ClosureRegionCategoryFindManyArgs>(args?: SelectSubset<T, ClosureRegionCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClosureRegionCategory.
     * @param {ClosureRegionCategoryCreateArgs} args - Arguments to create a ClosureRegionCategory.
     * @example
     * // Create one ClosureRegionCategory
     * const ClosureRegionCategory = await prisma.closureRegionCategory.create({
     *   data: {
     *     // ... data to create a ClosureRegionCategory
     *   }
     * })
     * 
     */
    create<T extends ClosureRegionCategoryCreateArgs>(args: SelectSubset<T, ClosureRegionCategoryCreateArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClosureRegionCategories.
     * @param {ClosureRegionCategoryCreateManyArgs} args - Arguments to create many ClosureRegionCategories.
     * @example
     * // Create many ClosureRegionCategories
     * const closureRegionCategory = await prisma.closureRegionCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClosureRegionCategoryCreateManyArgs>(args?: SelectSubset<T, ClosureRegionCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClosureRegionCategories and returns the data saved in the database.
     * @param {ClosureRegionCategoryCreateManyAndReturnArgs} args - Arguments to create many ClosureRegionCategories.
     * @example
     * // Create many ClosureRegionCategories
     * const closureRegionCategory = await prisma.closureRegionCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClosureRegionCategories and only return the `ancestor`
     * const closureRegionCategoryWithAncestorOnly = await prisma.closureRegionCategory.createManyAndReturn({
     *   select: { ancestor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClosureRegionCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ClosureRegionCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClosureRegionCategory.
     * @param {ClosureRegionCategoryDeleteArgs} args - Arguments to delete one ClosureRegionCategory.
     * @example
     * // Delete one ClosureRegionCategory
     * const ClosureRegionCategory = await prisma.closureRegionCategory.delete({
     *   where: {
     *     // ... filter to delete one ClosureRegionCategory
     *   }
     * })
     * 
     */
    delete<T extends ClosureRegionCategoryDeleteArgs>(args: SelectSubset<T, ClosureRegionCategoryDeleteArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClosureRegionCategory.
     * @param {ClosureRegionCategoryUpdateArgs} args - Arguments to update one ClosureRegionCategory.
     * @example
     * // Update one ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClosureRegionCategoryUpdateArgs>(args: SelectSubset<T, ClosureRegionCategoryUpdateArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClosureRegionCategories.
     * @param {ClosureRegionCategoryDeleteManyArgs} args - Arguments to filter ClosureRegionCategories to delete.
     * @example
     * // Delete a few ClosureRegionCategories
     * const { count } = await prisma.closureRegionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClosureRegionCategoryDeleteManyArgs>(args?: SelectSubset<T, ClosureRegionCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClosureRegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClosureRegionCategories
     * const closureRegionCategory = await prisma.closureRegionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClosureRegionCategoryUpdateManyArgs>(args: SelectSubset<T, ClosureRegionCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClosureRegionCategories and returns the data updated in the database.
     * @param {ClosureRegionCategoryUpdateManyAndReturnArgs} args - Arguments to update many ClosureRegionCategories.
     * @example
     * // Update many ClosureRegionCategories
     * const closureRegionCategory = await prisma.closureRegionCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClosureRegionCategories and only return the `ancestor`
     * const closureRegionCategoryWithAncestorOnly = await prisma.closureRegionCategory.updateManyAndReturn({
     *   select: { ancestor: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClosureRegionCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ClosureRegionCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClosureRegionCategory.
     * @param {ClosureRegionCategoryUpsertArgs} args - Arguments to update or create a ClosureRegionCategory.
     * @example
     * // Update or create a ClosureRegionCategory
     * const closureRegionCategory = await prisma.closureRegionCategory.upsert({
     *   create: {
     *     // ... data to create a ClosureRegionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClosureRegionCategory we want to update
     *   }
     * })
     */
    upsert<T extends ClosureRegionCategoryUpsertArgs>(args: SelectSubset<T, ClosureRegionCategoryUpsertArgs<ExtArgs>>): Prisma__ClosureRegionCategoryClient<$Result.GetResult<Prisma.$ClosureRegionCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClosureRegionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryCountArgs} args - Arguments to filter ClosureRegionCategories to count.
     * @example
     * // Count the number of ClosureRegionCategories
     * const count = await prisma.closureRegionCategory.count({
     *   where: {
     *     // ... the filter for the ClosureRegionCategories we want to count
     *   }
     * })
    **/
    count<T extends ClosureRegionCategoryCountArgs>(
      args?: Subset<T, ClosureRegionCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClosureRegionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClosureRegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClosureRegionCategoryAggregateArgs>(args: Subset<T, ClosureRegionCategoryAggregateArgs>): Prisma.PrismaPromise<GetClosureRegionCategoryAggregateType<T>>

    /**
     * Group by ClosureRegionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureRegionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClosureRegionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClosureRegionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ClosureRegionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClosureRegionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosureRegionCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClosureRegionCategory model
   */
  readonly fields: ClosureRegionCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClosureRegionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClosureRegionCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AncestorCategory<T extends RegionCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionCategoryDefaultArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DescendantCategory<T extends RegionCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionCategoryDefaultArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClosureRegionCategory model
   */
  interface ClosureRegionCategoryFieldRefs {
    readonly ancestor: FieldRef<"ClosureRegionCategory", 'Int'>
    readonly descendant: FieldRef<"ClosureRegionCategory", 'Int'>
    readonly depth: FieldRef<"ClosureRegionCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClosureRegionCategory findUnique
   */
  export type ClosureRegionCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     */
    where: ClosureRegionCategoryWhereUniqueInput
  }

  /**
   * ClosureRegionCategory findUniqueOrThrow
   */
  export type ClosureRegionCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     */
    where: ClosureRegionCategoryWhereUniqueInput
  }

  /**
   * ClosureRegionCategory findFirst
   */
  export type ClosureRegionCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     */
    orderBy?: ClosureRegionCategoryOrderByWithRelationInput | ClosureRegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureRegionCategories.
     */
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureRegionCategories.
     */
    distinct?: ClosureRegionCategoryScalarFieldEnum | ClosureRegionCategoryScalarFieldEnum[]
  }

  /**
   * ClosureRegionCategory findFirstOrThrow
   */
  export type ClosureRegionCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureRegionCategory to fetch.
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     */
    orderBy?: ClosureRegionCategoryOrderByWithRelationInput | ClosureRegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureRegionCategories.
     */
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureRegionCategories.
     */
    distinct?: ClosureRegionCategoryScalarFieldEnum | ClosureRegionCategoryScalarFieldEnum[]
  }

  /**
   * ClosureRegionCategory findMany
   */
  export type ClosureRegionCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureRegionCategories to fetch.
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureRegionCategories to fetch.
     */
    orderBy?: ClosureRegionCategoryOrderByWithRelationInput | ClosureRegionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClosureRegionCategories.
     */
    cursor?: ClosureRegionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureRegionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureRegionCategories.
     */
    skip?: number
    distinct?: ClosureRegionCategoryScalarFieldEnum | ClosureRegionCategoryScalarFieldEnum[]
  }

  /**
   * ClosureRegionCategory create
   */
  export type ClosureRegionCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ClosureRegionCategory.
     */
    data: XOR<ClosureRegionCategoryCreateInput, ClosureRegionCategoryUncheckedCreateInput>
  }

  /**
   * ClosureRegionCategory createMany
   */
  export type ClosureRegionCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClosureRegionCategories.
     */
    data: ClosureRegionCategoryCreateManyInput | ClosureRegionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClosureRegionCategory createManyAndReturn
   */
  export type ClosureRegionCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ClosureRegionCategories.
     */
    data: ClosureRegionCategoryCreateManyInput | ClosureRegionCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClosureRegionCategory update
   */
  export type ClosureRegionCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ClosureRegionCategory.
     */
    data: XOR<ClosureRegionCategoryUpdateInput, ClosureRegionCategoryUncheckedUpdateInput>
    /**
     * Choose, which ClosureRegionCategory to update.
     */
    where: ClosureRegionCategoryWhereUniqueInput
  }

  /**
   * ClosureRegionCategory updateMany
   */
  export type ClosureRegionCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClosureRegionCategories.
     */
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ClosureRegionCategories to update
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * Limit how many ClosureRegionCategories to update.
     */
    limit?: number
  }

  /**
   * ClosureRegionCategory updateManyAndReturn
   */
  export type ClosureRegionCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ClosureRegionCategories.
     */
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ClosureRegionCategories to update
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * Limit how many ClosureRegionCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClosureRegionCategory upsert
   */
  export type ClosureRegionCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ClosureRegionCategory to update in case it exists.
     */
    where: ClosureRegionCategoryWhereUniqueInput
    /**
     * In case the ClosureRegionCategory found by the `where` argument doesn't exist, create a new ClosureRegionCategory with this data.
     */
    create: XOR<ClosureRegionCategoryCreateInput, ClosureRegionCategoryUncheckedCreateInput>
    /**
     * In case the ClosureRegionCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClosureRegionCategoryUpdateInput, ClosureRegionCategoryUncheckedUpdateInput>
  }

  /**
   * ClosureRegionCategory delete
   */
  export type ClosureRegionCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
    /**
     * Filter which ClosureRegionCategory to delete.
     */
    where: ClosureRegionCategoryWhereUniqueInput
  }

  /**
   * ClosureRegionCategory deleteMany
   */
  export type ClosureRegionCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClosureRegionCategories to delete
     */
    where?: ClosureRegionCategoryWhereInput
    /**
     * Limit how many ClosureRegionCategories to delete.
     */
    limit?: number
  }

  /**
   * ClosureRegionCategory without action
   */
  export type ClosureRegionCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureRegionCategory
     */
    select?: ClosureRegionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureRegionCategory
     */
    omit?: ClosureRegionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureRegionCategoryInclude<ExtArgs> | null
  }


  /**
   * Model CafeInfo
   */

  export type AggregateCafeInfo = {
    _count: CafeInfoCountAggregateOutputType | null
    _avg: CafeInfoAvgAggregateOutputType | null
    _sum: CafeInfoSumAggregateOutputType | null
    _min: CafeInfoMinAggregateOutputType | null
    _max: CafeInfoMaxAggregateOutputType | null
  }

  export type CafeInfoAvgAggregateOutputType = {
    id: number | null
    regionCategoryId: number | null
  }

  export type CafeInfoSumAggregateOutputType = {
    id: number | null
    regionCategoryId: number | null
  }

  export type CafeInfoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDisable: boolean | null
    name: string | null
    code: string | null
    regionCategoryId: number | null
    address: string | null
    directions: string | null
    businessNumber: string | null
    ceoName: string | null
  }

  export type CafeInfoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    isDisable: boolean | null
    name: string | null
    code: string | null
    regionCategoryId: number | null
    address: string | null
    directions: string | null
    businessNumber: string | null
    ceoName: string | null
  }

  export type CafeInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    isDisable: number
    name: number
    code: number
    regionCategoryId: number
    address: number
    directions: number
    businessNumber: number
    ceoName: number
    _all: number
  }


  export type CafeInfoAvgAggregateInputType = {
    id?: true
    regionCategoryId?: true
  }

  export type CafeInfoSumAggregateInputType = {
    id?: true
    regionCategoryId?: true
  }

  export type CafeInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    isDisable?: true
    name?: true
    code?: true
    regionCategoryId?: true
    address?: true
    directions?: true
    businessNumber?: true
    ceoName?: true
  }

  export type CafeInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isDisable?: true
    name?: true
    code?: true
    regionCategoryId?: true
    address?: true
    directions?: true
    businessNumber?: true
    ceoName?: true
  }

  export type CafeInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    isDisable?: true
    name?: true
    code?: true
    regionCategoryId?: true
    address?: true
    directions?: true
    businessNumber?: true
    ceoName?: true
    _all?: true
  }

  export type CafeInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeInfo to aggregate.
     */
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     */
    orderBy?: CafeInfoOrderByWithRelationInput | CafeInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeInfos
    **/
    _count?: true | CafeInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeInfoMaxAggregateInputType
  }

  export type GetCafeInfoAggregateType<T extends CafeInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeInfo[P]>
      : GetScalarType<T[P], AggregateCafeInfo[P]>
  }




  export type CafeInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeInfoWhereInput
    orderBy?: CafeInfoOrderByWithAggregationInput | CafeInfoOrderByWithAggregationInput[]
    by: CafeInfoScalarFieldEnum[] | CafeInfoScalarFieldEnum
    having?: CafeInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeInfoCountAggregateInputType | true
    _avg?: CafeInfoAvgAggregateInputType
    _sum?: CafeInfoSumAggregateInputType
    _min?: CafeInfoMinAggregateInputType
    _max?: CafeInfoMaxAggregateInputType
  }

  export type CafeInfoGroupByOutputType = {
    id: number
    createdAt: Date
    isDisable: boolean
    name: string
    code: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    _count: CafeInfoCountAggregateOutputType | null
    _avg: CafeInfoAvgAggregateOutputType | null
    _sum: CafeInfoSumAggregateOutputType | null
    _min: CafeInfoMinAggregateOutputType | null
    _max: CafeInfoMaxAggregateOutputType | null
  }

  type GetCafeInfoGroupByPayload<T extends CafeInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeInfoGroupByOutputType[P]>
            : GetScalarType<T[P], CafeInfoGroupByOutputType[P]>
        }
      >
    >


  export type CafeInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDisable?: boolean
    name?: boolean
    code?: boolean
    regionCategoryId?: boolean
    address?: boolean
    directions?: boolean
    businessNumber?: boolean
    ceoName?: boolean
    RegionCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    CafeVirtualLinks?: boolean | CafeInfo$CafeVirtualLinksArgs<ExtArgs>
    CafeThumbnailImages?: boolean | CafeInfo$CafeThumbnailImagesArgs<ExtArgs>
    CafeVirtualImages?: boolean | CafeInfo$CafeVirtualImagesArgs<ExtArgs>
    CafeRealImages?: boolean | CafeInfo$CafeRealImagesArgs<ExtArgs>
    CafeCouponGroupPartners?: boolean | CafeInfo$CafeCouponGroupPartnersArgs<ExtArgs>
    CafeBoards?: boolean | CafeInfo$CafeBoardsArgs<ExtArgs>
    MetaViewerInfos?: boolean | CafeInfo$MetaViewerInfosArgs<ExtArgs>
    Products?: boolean | CafeInfo$ProductsArgs<ExtArgs>
    _count?: boolean | CafeInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeInfo"]>

  export type CafeInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDisable?: boolean
    name?: boolean
    code?: boolean
    regionCategoryId?: boolean
    address?: boolean
    directions?: boolean
    businessNumber?: boolean
    ceoName?: boolean
    RegionCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeInfo"]>

  export type CafeInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    isDisable?: boolean
    name?: boolean
    code?: boolean
    regionCategoryId?: boolean
    address?: boolean
    directions?: boolean
    businessNumber?: boolean
    ceoName?: boolean
    RegionCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeInfo"]>

  export type CafeInfoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    isDisable?: boolean
    name?: boolean
    code?: boolean
    regionCategoryId?: boolean
    address?: boolean
    directions?: boolean
    businessNumber?: boolean
    ceoName?: boolean
  }

  export type CafeInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "isDisable" | "name" | "code" | "regionCategoryId" | "address" | "directions" | "businessNumber" | "ceoName", ExtArgs["result"]["cafeInfo"]>
  export type CafeInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RegionCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
    CafeVirtualLinks?: boolean | CafeInfo$CafeVirtualLinksArgs<ExtArgs>
    CafeThumbnailImages?: boolean | CafeInfo$CafeThumbnailImagesArgs<ExtArgs>
    CafeVirtualImages?: boolean | CafeInfo$CafeVirtualImagesArgs<ExtArgs>
    CafeRealImages?: boolean | CafeInfo$CafeRealImagesArgs<ExtArgs>
    CafeCouponGroupPartners?: boolean | CafeInfo$CafeCouponGroupPartnersArgs<ExtArgs>
    CafeBoards?: boolean | CafeInfo$CafeBoardsArgs<ExtArgs>
    MetaViewerInfos?: boolean | CafeInfo$MetaViewerInfosArgs<ExtArgs>
    Products?: boolean | CafeInfo$ProductsArgs<ExtArgs>
    _count?: boolean | CafeInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CafeInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RegionCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }
  export type CafeInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RegionCategory?: boolean | RegionCategoryDefaultArgs<ExtArgs>
  }

  export type $CafeInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeInfo"
    objects: {
      RegionCategory: Prisma.$RegionCategoryPayload<ExtArgs>
      CafeVirtualLinks: Prisma.$CafeVirtualLinkPayload<ExtArgs>[]
      CafeThumbnailImages: Prisma.$CafeThumbnailImagePayload<ExtArgs>[]
      CafeVirtualImages: Prisma.$CafeVirtualImagePayload<ExtArgs>[]
      CafeRealImages: Prisma.$CafeRealImagePayload<ExtArgs>[]
      CafeCouponGroupPartners: Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>[]
      CafeBoards: Prisma.$CafeBoardPayload<ExtArgs>[]
      MetaViewerInfos: Prisma.$MetaViewerInfoPayload<ExtArgs>[]
      Products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      isDisable: boolean
      name: string
      code: string | null
      regionCategoryId: number
      address: string
      directions: string
      businessNumber: string
      ceoName: string
    }, ExtArgs["result"]["cafeInfo"]>
    composites: {}
  }

  type CafeInfoGetPayload<S extends boolean | null | undefined | CafeInfoDefaultArgs> = $Result.GetResult<Prisma.$CafeInfoPayload, S>

  type CafeInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeInfoCountAggregateInputType | true
    }

  export interface CafeInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeInfo'], meta: { name: 'CafeInfo' } }
    /**
     * Find zero or one CafeInfo that matches the filter.
     * @param {CafeInfoFindUniqueArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeInfoFindUniqueArgs>(args: SelectSubset<T, CafeInfoFindUniqueArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeInfoFindUniqueOrThrowArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoFindFirstArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeInfoFindFirstArgs>(args?: SelectSubset<T, CafeInfoFindFirstArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoFindFirstOrThrowArgs} args - Arguments to find a CafeInfo
     * @example
     * // Get one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeInfos
     * const cafeInfos = await prisma.cafeInfo.findMany()
     * 
     * // Get first 10 CafeInfos
     * const cafeInfos = await prisma.cafeInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeInfoWithIdOnly = await prisma.cafeInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeInfoFindManyArgs>(args?: SelectSubset<T, CafeInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeInfo.
     * @param {CafeInfoCreateArgs} args - Arguments to create a CafeInfo.
     * @example
     * // Create one CafeInfo
     * const CafeInfo = await prisma.cafeInfo.create({
     *   data: {
     *     // ... data to create a CafeInfo
     *   }
     * })
     * 
     */
    create<T extends CafeInfoCreateArgs>(args: SelectSubset<T, CafeInfoCreateArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeInfos.
     * @param {CafeInfoCreateManyArgs} args - Arguments to create many CafeInfos.
     * @example
     * // Create many CafeInfos
     * const cafeInfo = await prisma.cafeInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeInfoCreateManyArgs>(args?: SelectSubset<T, CafeInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeInfos and returns the data saved in the database.
     * @param {CafeInfoCreateManyAndReturnArgs} args - Arguments to create many CafeInfos.
     * @example
     * // Create many CafeInfos
     * const cafeInfo = await prisma.cafeInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeInfos and only return the `id`
     * const cafeInfoWithIdOnly = await prisma.cafeInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeInfo.
     * @param {CafeInfoDeleteArgs} args - Arguments to delete one CafeInfo.
     * @example
     * // Delete one CafeInfo
     * const CafeInfo = await prisma.cafeInfo.delete({
     *   where: {
     *     // ... filter to delete one CafeInfo
     *   }
     * })
     * 
     */
    delete<T extends CafeInfoDeleteArgs>(args: SelectSubset<T, CafeInfoDeleteArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeInfo.
     * @param {CafeInfoUpdateArgs} args - Arguments to update one CafeInfo.
     * @example
     * // Update one CafeInfo
     * const cafeInfo = await prisma.cafeInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeInfoUpdateArgs>(args: SelectSubset<T, CafeInfoUpdateArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeInfos.
     * @param {CafeInfoDeleteManyArgs} args - Arguments to filter CafeInfos to delete.
     * @example
     * // Delete a few CafeInfos
     * const { count } = await prisma.cafeInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeInfoDeleteManyArgs>(args?: SelectSubset<T, CafeInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeInfos
     * const cafeInfo = await prisma.cafeInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeInfoUpdateManyArgs>(args: SelectSubset<T, CafeInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeInfos and returns the data updated in the database.
     * @param {CafeInfoUpdateManyAndReturnArgs} args - Arguments to update many CafeInfos.
     * @example
     * // Update many CafeInfos
     * const cafeInfo = await prisma.cafeInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeInfos and only return the `id`
     * const cafeInfoWithIdOnly = await prisma.cafeInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeInfo.
     * @param {CafeInfoUpsertArgs} args - Arguments to update or create a CafeInfo.
     * @example
     * // Update or create a CafeInfo
     * const cafeInfo = await prisma.cafeInfo.upsert({
     *   create: {
     *     // ... data to create a CafeInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeInfo we want to update
     *   }
     * })
     */
    upsert<T extends CafeInfoUpsertArgs>(args: SelectSubset<T, CafeInfoUpsertArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoCountArgs} args - Arguments to filter CafeInfos to count.
     * @example
     * // Count the number of CafeInfos
     * const count = await prisma.cafeInfo.count({
     *   where: {
     *     // ... the filter for the CafeInfos we want to count
     *   }
     * })
    **/
    count<T extends CafeInfoCountArgs>(
      args?: Subset<T, CafeInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeInfoAggregateArgs>(args: Subset<T, CafeInfoAggregateArgs>): Prisma.PrismaPromise<GetCafeInfoAggregateType<T>>

    /**
     * Group by CafeInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeInfoGroupByArgs['orderBy'] }
        : { orderBy?: CafeInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeInfo model
   */
  readonly fields: CafeInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RegionCategory<T extends RegionCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionCategoryDefaultArgs<ExtArgs>>): Prisma__RegionCategoryClient<$Result.GetResult<Prisma.$RegionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeVirtualLinks<T extends CafeInfo$CafeVirtualLinksArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$CafeVirtualLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeThumbnailImages<T extends CafeInfo$CafeThumbnailImagesArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$CafeThumbnailImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeVirtualImages<T extends CafeInfo$CafeVirtualImagesArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$CafeVirtualImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeRealImages<T extends CafeInfo$CafeRealImagesArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$CafeRealImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeCouponGroupPartners<T extends CafeInfo$CafeCouponGroupPartnersArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$CafeCouponGroupPartnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeBoards<T extends CafeInfo$CafeBoardsArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$CafeBoardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeBoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MetaViewerInfos<T extends CafeInfo$MetaViewerInfosArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$MetaViewerInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Products<T extends CafeInfo$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfo$ProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeInfo model
   */
  interface CafeInfoFieldRefs {
    readonly id: FieldRef<"CafeInfo", 'Int'>
    readonly createdAt: FieldRef<"CafeInfo", 'DateTime'>
    readonly isDisable: FieldRef<"CafeInfo", 'Boolean'>
    readonly name: FieldRef<"CafeInfo", 'String'>
    readonly code: FieldRef<"CafeInfo", 'String'>
    readonly regionCategoryId: FieldRef<"CafeInfo", 'Int'>
    readonly address: FieldRef<"CafeInfo", 'String'>
    readonly directions: FieldRef<"CafeInfo", 'String'>
    readonly businessNumber: FieldRef<"CafeInfo", 'String'>
    readonly ceoName: FieldRef<"CafeInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CafeInfo findUnique
   */
  export type CafeInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * Filter, which CafeInfo to fetch.
     */
    where: CafeInfoWhereUniqueInput
  }

  /**
   * CafeInfo findUniqueOrThrow
   */
  export type CafeInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * Filter, which CafeInfo to fetch.
     */
    where: CafeInfoWhereUniqueInput
  }

  /**
   * CafeInfo findFirst
   */
  export type CafeInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * Filter, which CafeInfo to fetch.
     */
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     */
    orderBy?: CafeInfoOrderByWithRelationInput | CafeInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeInfos.
     */
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeInfos.
     */
    distinct?: CafeInfoScalarFieldEnum | CafeInfoScalarFieldEnum[]
  }

  /**
   * CafeInfo findFirstOrThrow
   */
  export type CafeInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * Filter, which CafeInfo to fetch.
     */
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     */
    orderBy?: CafeInfoOrderByWithRelationInput | CafeInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeInfos.
     */
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeInfos.
     */
    distinct?: CafeInfoScalarFieldEnum | CafeInfoScalarFieldEnum[]
  }

  /**
   * CafeInfo findMany
   */
  export type CafeInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * Filter, which CafeInfos to fetch.
     */
    where?: CafeInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeInfos to fetch.
     */
    orderBy?: CafeInfoOrderByWithRelationInput | CafeInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeInfos.
     */
    cursor?: CafeInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeInfos.
     */
    skip?: number
    distinct?: CafeInfoScalarFieldEnum | CafeInfoScalarFieldEnum[]
  }

  /**
   * CafeInfo create
   */
  export type CafeInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeInfo.
     */
    data: XOR<CafeInfoCreateInput, CafeInfoUncheckedCreateInput>
  }

  /**
   * CafeInfo createMany
   */
  export type CafeInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeInfos.
     */
    data: CafeInfoCreateManyInput | CafeInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeInfo createManyAndReturn
   */
  export type CafeInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * The data used to create many CafeInfos.
     */
    data: CafeInfoCreateManyInput | CafeInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeInfo update
   */
  export type CafeInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeInfo.
     */
    data: XOR<CafeInfoUpdateInput, CafeInfoUncheckedUpdateInput>
    /**
     * Choose, which CafeInfo to update.
     */
    where: CafeInfoWhereUniqueInput
  }

  /**
   * CafeInfo updateMany
   */
  export type CafeInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeInfos.
     */
    data: XOR<CafeInfoUpdateManyMutationInput, CafeInfoUncheckedUpdateManyInput>
    /**
     * Filter which CafeInfos to update
     */
    where?: CafeInfoWhereInput
    /**
     * Limit how many CafeInfos to update.
     */
    limit?: number
  }

  /**
   * CafeInfo updateManyAndReturn
   */
  export type CafeInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * The data used to update CafeInfos.
     */
    data: XOR<CafeInfoUpdateManyMutationInput, CafeInfoUncheckedUpdateManyInput>
    /**
     * Filter which CafeInfos to update
     */
    where?: CafeInfoWhereInput
    /**
     * Limit how many CafeInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeInfo upsert
   */
  export type CafeInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeInfo to update in case it exists.
     */
    where: CafeInfoWhereUniqueInput
    /**
     * In case the CafeInfo found by the `where` argument doesn't exist, create a new CafeInfo with this data.
     */
    create: XOR<CafeInfoCreateInput, CafeInfoUncheckedCreateInput>
    /**
     * In case the CafeInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeInfoUpdateInput, CafeInfoUncheckedUpdateInput>
  }

  /**
   * CafeInfo delete
   */
  export type CafeInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    /**
     * Filter which CafeInfo to delete.
     */
    where: CafeInfoWhereUniqueInput
  }

  /**
   * CafeInfo deleteMany
   */
  export type CafeInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeInfos to delete
     */
    where?: CafeInfoWhereInput
    /**
     * Limit how many CafeInfos to delete.
     */
    limit?: number
  }

  /**
   * CafeInfo.CafeVirtualLinks
   */
  export type CafeInfo$CafeVirtualLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    where?: CafeVirtualLinkWhereInput
    orderBy?: CafeVirtualLinkOrderByWithRelationInput | CafeVirtualLinkOrderByWithRelationInput[]
    cursor?: CafeVirtualLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeVirtualLinkScalarFieldEnum | CafeVirtualLinkScalarFieldEnum[]
  }

  /**
   * CafeInfo.CafeThumbnailImages
   */
  export type CafeInfo$CafeThumbnailImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    where?: CafeThumbnailImageWhereInput
    orderBy?: CafeThumbnailImageOrderByWithRelationInput | CafeThumbnailImageOrderByWithRelationInput[]
    cursor?: CafeThumbnailImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeThumbnailImageScalarFieldEnum | CafeThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeInfo.CafeVirtualImages
   */
  export type CafeInfo$CafeVirtualImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    where?: CafeVirtualImageWhereInput
    orderBy?: CafeVirtualImageOrderByWithRelationInput | CafeVirtualImageOrderByWithRelationInput[]
    cursor?: CafeVirtualImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeVirtualImageScalarFieldEnum | CafeVirtualImageScalarFieldEnum[]
  }

  /**
   * CafeInfo.CafeRealImages
   */
  export type CafeInfo$CafeRealImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    where?: CafeRealImageWhereInput
    orderBy?: CafeRealImageOrderByWithRelationInput | CafeRealImageOrderByWithRelationInput[]
    cursor?: CafeRealImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeRealImageScalarFieldEnum | CafeRealImageScalarFieldEnum[]
  }

  /**
   * CafeInfo.CafeCouponGroupPartners
   */
  export type CafeInfo$CafeCouponGroupPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    where?: CafeCouponGoupPartnerWhereInput
    orderBy?: CafeCouponGoupPartnerOrderByWithRelationInput | CafeCouponGoupPartnerOrderByWithRelationInput[]
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponGoupPartnerScalarFieldEnum | CafeCouponGoupPartnerScalarFieldEnum[]
  }

  /**
   * CafeInfo.CafeBoards
   */
  export type CafeInfo$CafeBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeBoard
     */
    select?: CafeBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeBoard
     */
    omit?: CafeBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeBoardInclude<ExtArgs> | null
    where?: CafeBoardWhereInput
    orderBy?: CafeBoardOrderByWithRelationInput | CafeBoardOrderByWithRelationInput[]
    cursor?: CafeBoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeBoardScalarFieldEnum | CafeBoardScalarFieldEnum[]
  }

  /**
   * CafeInfo.MetaViewerInfos
   */
  export type CafeInfo$MetaViewerInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    where?: MetaViewerInfoWhereInput
    orderBy?: MetaViewerInfoOrderByWithRelationInput | MetaViewerInfoOrderByWithRelationInput[]
    cursor?: MetaViewerInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetaViewerInfoScalarFieldEnum | MetaViewerInfoScalarFieldEnum[]
  }

  /**
   * CafeInfo.Products
   */
  export type CafeInfo$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * CafeInfo without action
   */
  export type CafeInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
  }


  /**
   * Model CafeThumbnailImage
   */

  export type AggregateCafeThumbnailImage = {
    _count: CafeThumbnailImageCountAggregateOutputType | null
    _avg: CafeThumbnailImageAvgAggregateOutputType | null
    _sum: CafeThumbnailImageSumAggregateOutputType | null
    _min: CafeThumbnailImageMinAggregateOutputType | null
    _max: CafeThumbnailImageMaxAggregateOutputType | null
  }

  export type CafeThumbnailImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeThumbnailImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    thumbnailUrl: number
    width: number
    height: number
    size: number
    priority: number
    isDisable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeThumbnailImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeThumbnailImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeThumbnailImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeThumbnailImage to aggregate.
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     */
    orderBy?: CafeThumbnailImageOrderByWithRelationInput | CafeThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeThumbnailImages
    **/
    _count?: true | CafeThumbnailImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeThumbnailImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeThumbnailImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeThumbnailImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeThumbnailImageMaxAggregateInputType
  }

  export type GetCafeThumbnailImageAggregateType<T extends CafeThumbnailImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeThumbnailImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeThumbnailImage[P]>
      : GetScalarType<T[P], AggregateCafeThumbnailImage[P]>
  }




  export type CafeThumbnailImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeThumbnailImageWhereInput
    orderBy?: CafeThumbnailImageOrderByWithAggregationInput | CafeThumbnailImageOrderByWithAggregationInput[]
    by: CafeThumbnailImageScalarFieldEnum[] | CafeThumbnailImageScalarFieldEnum
    having?: CafeThumbnailImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeThumbnailImageCountAggregateInputType | true
    _avg?: CafeThumbnailImageAvgAggregateInputType
    _sum?: CafeThumbnailImageSumAggregateInputType
    _min?: CafeThumbnailImageMinAggregateInputType
    _max?: CafeThumbnailImageMaxAggregateInputType
  }

  export type CafeThumbnailImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority: number
    isDisable: boolean
    cafeInfoId: number
    _count: CafeThumbnailImageCountAggregateOutputType | null
    _avg: CafeThumbnailImageAvgAggregateOutputType | null
    _sum: CafeThumbnailImageSumAggregateOutputType | null
    _min: CafeThumbnailImageMinAggregateOutputType | null
    _max: CafeThumbnailImageMaxAggregateOutputType | null
  }

  type GetCafeThumbnailImageGroupByPayload<T extends CafeThumbnailImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeThumbnailImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeThumbnailImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeThumbnailImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeThumbnailImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeThumbnailImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeThumbnailImage"]>

  export type CafeThumbnailImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeThumbnailImage"]>

  export type CafeThumbnailImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeThumbnailImage"]>

  export type CafeThumbnailImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
  }

  export type CafeThumbnailImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "url" | "thumbnailUrl" | "width" | "height" | "size" | "priority" | "isDisable" | "cafeInfoId", ExtArgs["result"]["cafeThumbnailImage"]>
  export type CafeThumbnailImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeThumbnailImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeThumbnailImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $CafeThumbnailImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeThumbnailImage"
    objects: {
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      url: string
      thumbnailUrl: string
      width: number
      height: number
      size: number
      priority: number
      isDisable: boolean
      cafeInfoId: number
    }, ExtArgs["result"]["cafeThumbnailImage"]>
    composites: {}
  }

  type CafeThumbnailImageGetPayload<S extends boolean | null | undefined | CafeThumbnailImageDefaultArgs> = $Result.GetResult<Prisma.$CafeThumbnailImagePayload, S>

  type CafeThumbnailImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeThumbnailImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeThumbnailImageCountAggregateInputType | true
    }

  export interface CafeThumbnailImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeThumbnailImage'], meta: { name: 'CafeThumbnailImage' } }
    /**
     * Find zero or one CafeThumbnailImage that matches the filter.
     * @param {CafeThumbnailImageFindUniqueArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeThumbnailImageFindUniqueArgs>(args: SelectSubset<T, CafeThumbnailImageFindUniqueArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeThumbnailImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeThumbnailImageFindUniqueOrThrowArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeThumbnailImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeThumbnailImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeThumbnailImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageFindFirstArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeThumbnailImageFindFirstArgs>(args?: SelectSubset<T, CafeThumbnailImageFindFirstArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeThumbnailImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageFindFirstOrThrowArgs} args - Arguments to find a CafeThumbnailImage
     * @example
     * // Get one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeThumbnailImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeThumbnailImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeThumbnailImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeThumbnailImages
     * const cafeThumbnailImages = await prisma.cafeThumbnailImage.findMany()
     * 
     * // Get first 10 CafeThumbnailImages
     * const cafeThumbnailImages = await prisma.cafeThumbnailImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeThumbnailImageWithIdOnly = await prisma.cafeThumbnailImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeThumbnailImageFindManyArgs>(args?: SelectSubset<T, CafeThumbnailImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeThumbnailImage.
     * @param {CafeThumbnailImageCreateArgs} args - Arguments to create a CafeThumbnailImage.
     * @example
     * // Create one CafeThumbnailImage
     * const CafeThumbnailImage = await prisma.cafeThumbnailImage.create({
     *   data: {
     *     // ... data to create a CafeThumbnailImage
     *   }
     * })
     * 
     */
    create<T extends CafeThumbnailImageCreateArgs>(args: SelectSubset<T, CafeThumbnailImageCreateArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeThumbnailImages.
     * @param {CafeThumbnailImageCreateManyArgs} args - Arguments to create many CafeThumbnailImages.
     * @example
     * // Create many CafeThumbnailImages
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeThumbnailImageCreateManyArgs>(args?: SelectSubset<T, CafeThumbnailImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeThumbnailImages and returns the data saved in the database.
     * @param {CafeThumbnailImageCreateManyAndReturnArgs} args - Arguments to create many CafeThumbnailImages.
     * @example
     * // Create many CafeThumbnailImages
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeThumbnailImages and only return the `id`
     * const cafeThumbnailImageWithIdOnly = await prisma.cafeThumbnailImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeThumbnailImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeThumbnailImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeThumbnailImage.
     * @param {CafeThumbnailImageDeleteArgs} args - Arguments to delete one CafeThumbnailImage.
     * @example
     * // Delete one CafeThumbnailImage
     * const CafeThumbnailImage = await prisma.cafeThumbnailImage.delete({
     *   where: {
     *     // ... filter to delete one CafeThumbnailImage
     *   }
     * })
     * 
     */
    delete<T extends CafeThumbnailImageDeleteArgs>(args: SelectSubset<T, CafeThumbnailImageDeleteArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeThumbnailImage.
     * @param {CafeThumbnailImageUpdateArgs} args - Arguments to update one CafeThumbnailImage.
     * @example
     * // Update one CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeThumbnailImageUpdateArgs>(args: SelectSubset<T, CafeThumbnailImageUpdateArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeThumbnailImages.
     * @param {CafeThumbnailImageDeleteManyArgs} args - Arguments to filter CafeThumbnailImages to delete.
     * @example
     * // Delete a few CafeThumbnailImages
     * const { count } = await prisma.cafeThumbnailImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeThumbnailImageDeleteManyArgs>(args?: SelectSubset<T, CafeThumbnailImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeThumbnailImages
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeThumbnailImageUpdateManyArgs>(args: SelectSubset<T, CafeThumbnailImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeThumbnailImages and returns the data updated in the database.
     * @param {CafeThumbnailImageUpdateManyAndReturnArgs} args - Arguments to update many CafeThumbnailImages.
     * @example
     * // Update many CafeThumbnailImages
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeThumbnailImages and only return the `id`
     * const cafeThumbnailImageWithIdOnly = await prisma.cafeThumbnailImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeThumbnailImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeThumbnailImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeThumbnailImage.
     * @param {CafeThumbnailImageUpsertArgs} args - Arguments to update or create a CafeThumbnailImage.
     * @example
     * // Update or create a CafeThumbnailImage
     * const cafeThumbnailImage = await prisma.cafeThumbnailImage.upsert({
     *   create: {
     *     // ... data to create a CafeThumbnailImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeThumbnailImage we want to update
     *   }
     * })
     */
    upsert<T extends CafeThumbnailImageUpsertArgs>(args: SelectSubset<T, CafeThumbnailImageUpsertArgs<ExtArgs>>): Prisma__CafeThumbnailImageClient<$Result.GetResult<Prisma.$CafeThumbnailImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageCountArgs} args - Arguments to filter CafeThumbnailImages to count.
     * @example
     * // Count the number of CafeThumbnailImages
     * const count = await prisma.cafeThumbnailImage.count({
     *   where: {
     *     // ... the filter for the CafeThumbnailImages we want to count
     *   }
     * })
    **/
    count<T extends CafeThumbnailImageCountArgs>(
      args?: Subset<T, CafeThumbnailImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeThumbnailImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeThumbnailImageAggregateArgs>(args: Subset<T, CafeThumbnailImageAggregateArgs>): Prisma.PrismaPromise<GetCafeThumbnailImageAggregateType<T>>

    /**
     * Group by CafeThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeThumbnailImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeThumbnailImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeThumbnailImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeThumbnailImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeThumbnailImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeThumbnailImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeThumbnailImage model
   */
  readonly fields: CafeThumbnailImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeThumbnailImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeThumbnailImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeThumbnailImage model
   */
  interface CafeThumbnailImageFieldRefs {
    readonly id: FieldRef<"CafeThumbnailImage", 'Int'>
    readonly createdAt: FieldRef<"CafeThumbnailImage", 'DateTime'>
    readonly url: FieldRef<"CafeThumbnailImage", 'String'>
    readonly thumbnailUrl: FieldRef<"CafeThumbnailImage", 'String'>
    readonly width: FieldRef<"CafeThumbnailImage", 'Int'>
    readonly height: FieldRef<"CafeThumbnailImage", 'Int'>
    readonly size: FieldRef<"CafeThumbnailImage", 'Int'>
    readonly priority: FieldRef<"CafeThumbnailImage", 'Int'>
    readonly isDisable: FieldRef<"CafeThumbnailImage", 'Boolean'>
    readonly cafeInfoId: FieldRef<"CafeThumbnailImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeThumbnailImage findUnique
   */
  export type CafeThumbnailImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     */
    where: CafeThumbnailImageWhereUniqueInput
  }

  /**
   * CafeThumbnailImage findUniqueOrThrow
   */
  export type CafeThumbnailImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     */
    where: CafeThumbnailImageWhereUniqueInput
  }

  /**
   * CafeThumbnailImage findFirst
   */
  export type CafeThumbnailImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     */
    orderBy?: CafeThumbnailImageOrderByWithRelationInput | CafeThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeThumbnailImages.
     */
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeThumbnailImages.
     */
    distinct?: CafeThumbnailImageScalarFieldEnum | CafeThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeThumbnailImage findFirstOrThrow
   */
  export type CafeThumbnailImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeThumbnailImage to fetch.
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     */
    orderBy?: CafeThumbnailImageOrderByWithRelationInput | CafeThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeThumbnailImages.
     */
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeThumbnailImages.
     */
    distinct?: CafeThumbnailImageScalarFieldEnum | CafeThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeThumbnailImage findMany
   */
  export type CafeThumbnailImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeThumbnailImages to fetch.
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeThumbnailImages to fetch.
     */
    orderBy?: CafeThumbnailImageOrderByWithRelationInput | CafeThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeThumbnailImages.
     */
    cursor?: CafeThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeThumbnailImages.
     */
    skip?: number
    distinct?: CafeThumbnailImageScalarFieldEnum | CafeThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeThumbnailImage create
   */
  export type CafeThumbnailImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeThumbnailImage.
     */
    data: XOR<CafeThumbnailImageCreateInput, CafeThumbnailImageUncheckedCreateInput>
  }

  /**
   * CafeThumbnailImage createMany
   */
  export type CafeThumbnailImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeThumbnailImages.
     */
    data: CafeThumbnailImageCreateManyInput | CafeThumbnailImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeThumbnailImage createManyAndReturn
   */
  export type CafeThumbnailImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * The data used to create many CafeThumbnailImages.
     */
    data: CafeThumbnailImageCreateManyInput | CafeThumbnailImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeThumbnailImage update
   */
  export type CafeThumbnailImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeThumbnailImage.
     */
    data: XOR<CafeThumbnailImageUpdateInput, CafeThumbnailImageUncheckedUpdateInput>
    /**
     * Choose, which CafeThumbnailImage to update.
     */
    where: CafeThumbnailImageWhereUniqueInput
  }

  /**
   * CafeThumbnailImage updateMany
   */
  export type CafeThumbnailImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeThumbnailImages.
     */
    data: XOR<CafeThumbnailImageUpdateManyMutationInput, CafeThumbnailImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeThumbnailImages to update
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * Limit how many CafeThumbnailImages to update.
     */
    limit?: number
  }

  /**
   * CafeThumbnailImage updateManyAndReturn
   */
  export type CafeThumbnailImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * The data used to update CafeThumbnailImages.
     */
    data: XOR<CafeThumbnailImageUpdateManyMutationInput, CafeThumbnailImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeThumbnailImages to update
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * Limit how many CafeThumbnailImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeThumbnailImage upsert
   */
  export type CafeThumbnailImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeThumbnailImage to update in case it exists.
     */
    where: CafeThumbnailImageWhereUniqueInput
    /**
     * In case the CafeThumbnailImage found by the `where` argument doesn't exist, create a new CafeThumbnailImage with this data.
     */
    create: XOR<CafeThumbnailImageCreateInput, CafeThumbnailImageUncheckedCreateInput>
    /**
     * In case the CafeThumbnailImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeThumbnailImageUpdateInput, CafeThumbnailImageUncheckedUpdateInput>
  }

  /**
   * CafeThumbnailImage delete
   */
  export type CafeThumbnailImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter which CafeThumbnailImage to delete.
     */
    where: CafeThumbnailImageWhereUniqueInput
  }

  /**
   * CafeThumbnailImage deleteMany
   */
  export type CafeThumbnailImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeThumbnailImages to delete
     */
    where?: CafeThumbnailImageWhereInput
    /**
     * Limit how many CafeThumbnailImages to delete.
     */
    limit?: number
  }

  /**
   * CafeThumbnailImage without action
   */
  export type CafeThumbnailImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeThumbnailImage
     */
    select?: CafeThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeThumbnailImage
     */
    omit?: CafeThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeThumbnailImageInclude<ExtArgs> | null
  }


  /**
   * Model CafeVirtualImage
   */

  export type AggregateCafeVirtualImage = {
    _count: CafeVirtualImageCountAggregateOutputType | null
    _avg: CafeVirtualImageAvgAggregateOutputType | null
    _sum: CafeVirtualImageSumAggregateOutputType | null
    _min: CafeVirtualImageMinAggregateOutputType | null
    _max: CafeVirtualImageMaxAggregateOutputType | null
  }

  export type CafeVirtualImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    width: number
    height: number
    size: number
    priority: number
    isDisable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeVirtualImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeVirtualImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeVirtualImage to aggregate.
     */
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     */
    orderBy?: CafeVirtualImageOrderByWithRelationInput | CafeVirtualImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeVirtualImages
    **/
    _count?: true | CafeVirtualImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeVirtualImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeVirtualImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeVirtualImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeVirtualImageMaxAggregateInputType
  }

  export type GetCafeVirtualImageAggregateType<T extends CafeVirtualImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeVirtualImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeVirtualImage[P]>
      : GetScalarType<T[P], AggregateCafeVirtualImage[P]>
  }




  export type CafeVirtualImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeVirtualImageWhereInput
    orderBy?: CafeVirtualImageOrderByWithAggregationInput | CafeVirtualImageOrderByWithAggregationInput[]
    by: CafeVirtualImageScalarFieldEnum[] | CafeVirtualImageScalarFieldEnum
    having?: CafeVirtualImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeVirtualImageCountAggregateInputType | true
    _avg?: CafeVirtualImageAvgAggregateInputType
    _sum?: CafeVirtualImageSumAggregateInputType
    _min?: CafeVirtualImageMinAggregateInputType
    _max?: CafeVirtualImageMaxAggregateInputType
  }

  export type CafeVirtualImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    width: number
    height: number
    size: number
    priority: number
    isDisable: boolean
    cafeInfoId: number
    _count: CafeVirtualImageCountAggregateOutputType | null
    _avg: CafeVirtualImageAvgAggregateOutputType | null
    _sum: CafeVirtualImageSumAggregateOutputType | null
    _min: CafeVirtualImageMinAggregateOutputType | null
    _max: CafeVirtualImageMaxAggregateOutputType | null
  }

  type GetCafeVirtualImageGroupByPayload<T extends CafeVirtualImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeVirtualImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeVirtualImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeVirtualImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeVirtualImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeVirtualImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualImage"]>

  export type CafeVirtualImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualImage"]>

  export type CafeVirtualImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualImage"]>

  export type CafeVirtualImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
  }

  export type CafeVirtualImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "url" | "width" | "height" | "size" | "priority" | "isDisable" | "cafeInfoId", ExtArgs["result"]["cafeVirtualImage"]>
  export type CafeVirtualImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeVirtualImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeVirtualImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $CafeVirtualImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeVirtualImage"
    objects: {
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      url: string
      width: number
      height: number
      size: number
      priority: number
      isDisable: boolean
      cafeInfoId: number
    }, ExtArgs["result"]["cafeVirtualImage"]>
    composites: {}
  }

  type CafeVirtualImageGetPayload<S extends boolean | null | undefined | CafeVirtualImageDefaultArgs> = $Result.GetResult<Prisma.$CafeVirtualImagePayload, S>

  type CafeVirtualImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeVirtualImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeVirtualImageCountAggregateInputType | true
    }

  export interface CafeVirtualImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeVirtualImage'], meta: { name: 'CafeVirtualImage' } }
    /**
     * Find zero or one CafeVirtualImage that matches the filter.
     * @param {CafeVirtualImageFindUniqueArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeVirtualImageFindUniqueArgs>(args: SelectSubset<T, CafeVirtualImageFindUniqueArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeVirtualImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeVirtualImageFindUniqueOrThrowArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeVirtualImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeVirtualImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeVirtualImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageFindFirstArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeVirtualImageFindFirstArgs>(args?: SelectSubset<T, CafeVirtualImageFindFirstArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeVirtualImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageFindFirstOrThrowArgs} args - Arguments to find a CafeVirtualImage
     * @example
     * // Get one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeVirtualImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeVirtualImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeVirtualImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeVirtualImages
     * const cafeVirtualImages = await prisma.cafeVirtualImage.findMany()
     * 
     * // Get first 10 CafeVirtualImages
     * const cafeVirtualImages = await prisma.cafeVirtualImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeVirtualImageWithIdOnly = await prisma.cafeVirtualImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeVirtualImageFindManyArgs>(args?: SelectSubset<T, CafeVirtualImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeVirtualImage.
     * @param {CafeVirtualImageCreateArgs} args - Arguments to create a CafeVirtualImage.
     * @example
     * // Create one CafeVirtualImage
     * const CafeVirtualImage = await prisma.cafeVirtualImage.create({
     *   data: {
     *     // ... data to create a CafeVirtualImage
     *   }
     * })
     * 
     */
    create<T extends CafeVirtualImageCreateArgs>(args: SelectSubset<T, CafeVirtualImageCreateArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeVirtualImages.
     * @param {CafeVirtualImageCreateManyArgs} args - Arguments to create many CafeVirtualImages.
     * @example
     * // Create many CafeVirtualImages
     * const cafeVirtualImage = await prisma.cafeVirtualImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeVirtualImageCreateManyArgs>(args?: SelectSubset<T, CafeVirtualImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeVirtualImages and returns the data saved in the database.
     * @param {CafeVirtualImageCreateManyAndReturnArgs} args - Arguments to create many CafeVirtualImages.
     * @example
     * // Create many CafeVirtualImages
     * const cafeVirtualImage = await prisma.cafeVirtualImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeVirtualImages and only return the `id`
     * const cafeVirtualImageWithIdOnly = await prisma.cafeVirtualImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeVirtualImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeVirtualImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeVirtualImage.
     * @param {CafeVirtualImageDeleteArgs} args - Arguments to delete one CafeVirtualImage.
     * @example
     * // Delete one CafeVirtualImage
     * const CafeVirtualImage = await prisma.cafeVirtualImage.delete({
     *   where: {
     *     // ... filter to delete one CafeVirtualImage
     *   }
     * })
     * 
     */
    delete<T extends CafeVirtualImageDeleteArgs>(args: SelectSubset<T, CafeVirtualImageDeleteArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeVirtualImage.
     * @param {CafeVirtualImageUpdateArgs} args - Arguments to update one CafeVirtualImage.
     * @example
     * // Update one CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeVirtualImageUpdateArgs>(args: SelectSubset<T, CafeVirtualImageUpdateArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeVirtualImages.
     * @param {CafeVirtualImageDeleteManyArgs} args - Arguments to filter CafeVirtualImages to delete.
     * @example
     * // Delete a few CafeVirtualImages
     * const { count } = await prisma.cafeVirtualImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeVirtualImageDeleteManyArgs>(args?: SelectSubset<T, CafeVirtualImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeVirtualImages
     * const cafeVirtualImage = await prisma.cafeVirtualImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeVirtualImageUpdateManyArgs>(args: SelectSubset<T, CafeVirtualImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualImages and returns the data updated in the database.
     * @param {CafeVirtualImageUpdateManyAndReturnArgs} args - Arguments to update many CafeVirtualImages.
     * @example
     * // Update many CafeVirtualImages
     * const cafeVirtualImage = await prisma.cafeVirtualImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeVirtualImages and only return the `id`
     * const cafeVirtualImageWithIdOnly = await prisma.cafeVirtualImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeVirtualImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeVirtualImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeVirtualImage.
     * @param {CafeVirtualImageUpsertArgs} args - Arguments to update or create a CafeVirtualImage.
     * @example
     * // Update or create a CafeVirtualImage
     * const cafeVirtualImage = await prisma.cafeVirtualImage.upsert({
     *   create: {
     *     // ... data to create a CafeVirtualImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeVirtualImage we want to update
     *   }
     * })
     */
    upsert<T extends CafeVirtualImageUpsertArgs>(args: SelectSubset<T, CafeVirtualImageUpsertArgs<ExtArgs>>): Prisma__CafeVirtualImageClient<$Result.GetResult<Prisma.$CafeVirtualImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeVirtualImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageCountArgs} args - Arguments to filter CafeVirtualImages to count.
     * @example
     * // Count the number of CafeVirtualImages
     * const count = await prisma.cafeVirtualImage.count({
     *   where: {
     *     // ... the filter for the CafeVirtualImages we want to count
     *   }
     * })
    **/
    count<T extends CafeVirtualImageCountArgs>(
      args?: Subset<T, CafeVirtualImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeVirtualImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeVirtualImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeVirtualImageAggregateArgs>(args: Subset<T, CafeVirtualImageAggregateArgs>): Prisma.PrismaPromise<GetCafeVirtualImageAggregateType<T>>

    /**
     * Group by CafeVirtualImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeVirtualImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeVirtualImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeVirtualImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeVirtualImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeVirtualImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeVirtualImage model
   */
  readonly fields: CafeVirtualImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeVirtualImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeVirtualImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeVirtualImage model
   */
  interface CafeVirtualImageFieldRefs {
    readonly id: FieldRef<"CafeVirtualImage", 'Int'>
    readonly createdAt: FieldRef<"CafeVirtualImage", 'DateTime'>
    readonly url: FieldRef<"CafeVirtualImage", 'String'>
    readonly width: FieldRef<"CafeVirtualImage", 'Int'>
    readonly height: FieldRef<"CafeVirtualImage", 'Int'>
    readonly size: FieldRef<"CafeVirtualImage", 'Int'>
    readonly priority: FieldRef<"CafeVirtualImage", 'Int'>
    readonly isDisable: FieldRef<"CafeVirtualImage", 'Boolean'>
    readonly cafeInfoId: FieldRef<"CafeVirtualImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeVirtualImage findUnique
   */
  export type CafeVirtualImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     */
    where: CafeVirtualImageWhereUniqueInput
  }

  /**
   * CafeVirtualImage findUniqueOrThrow
   */
  export type CafeVirtualImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     */
    where: CafeVirtualImageWhereUniqueInput
  }

  /**
   * CafeVirtualImage findFirst
   */
  export type CafeVirtualImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     */
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     */
    orderBy?: CafeVirtualImageOrderByWithRelationInput | CafeVirtualImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualImages.
     */
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualImages.
     */
    distinct?: CafeVirtualImageScalarFieldEnum | CafeVirtualImageScalarFieldEnum[]
  }

  /**
   * CafeVirtualImage findFirstOrThrow
   */
  export type CafeVirtualImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualImage to fetch.
     */
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     */
    orderBy?: CafeVirtualImageOrderByWithRelationInput | CafeVirtualImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualImages.
     */
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualImages.
     */
    distinct?: CafeVirtualImageScalarFieldEnum | CafeVirtualImageScalarFieldEnum[]
  }

  /**
   * CafeVirtualImage findMany
   */
  export type CafeVirtualImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualImages to fetch.
     */
    where?: CafeVirtualImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualImages to fetch.
     */
    orderBy?: CafeVirtualImageOrderByWithRelationInput | CafeVirtualImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeVirtualImages.
     */
    cursor?: CafeVirtualImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualImages.
     */
    skip?: number
    distinct?: CafeVirtualImageScalarFieldEnum | CafeVirtualImageScalarFieldEnum[]
  }

  /**
   * CafeVirtualImage create
   */
  export type CafeVirtualImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeVirtualImage.
     */
    data: XOR<CafeVirtualImageCreateInput, CafeVirtualImageUncheckedCreateInput>
  }

  /**
   * CafeVirtualImage createMany
   */
  export type CafeVirtualImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeVirtualImages.
     */
    data: CafeVirtualImageCreateManyInput | CafeVirtualImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeVirtualImage createManyAndReturn
   */
  export type CafeVirtualImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * The data used to create many CafeVirtualImages.
     */
    data: CafeVirtualImageCreateManyInput | CafeVirtualImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeVirtualImage update
   */
  export type CafeVirtualImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeVirtualImage.
     */
    data: XOR<CafeVirtualImageUpdateInput, CafeVirtualImageUncheckedUpdateInput>
    /**
     * Choose, which CafeVirtualImage to update.
     */
    where: CafeVirtualImageWhereUniqueInput
  }

  /**
   * CafeVirtualImage updateMany
   */
  export type CafeVirtualImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeVirtualImages.
     */
    data: XOR<CafeVirtualImageUpdateManyMutationInput, CafeVirtualImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualImages to update
     */
    where?: CafeVirtualImageWhereInput
    /**
     * Limit how many CafeVirtualImages to update.
     */
    limit?: number
  }

  /**
   * CafeVirtualImage updateManyAndReturn
   */
  export type CafeVirtualImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * The data used to update CafeVirtualImages.
     */
    data: XOR<CafeVirtualImageUpdateManyMutationInput, CafeVirtualImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualImages to update
     */
    where?: CafeVirtualImageWhereInput
    /**
     * Limit how many CafeVirtualImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeVirtualImage upsert
   */
  export type CafeVirtualImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeVirtualImage to update in case it exists.
     */
    where: CafeVirtualImageWhereUniqueInput
    /**
     * In case the CafeVirtualImage found by the `where` argument doesn't exist, create a new CafeVirtualImage with this data.
     */
    create: XOR<CafeVirtualImageCreateInput, CafeVirtualImageUncheckedCreateInput>
    /**
     * In case the CafeVirtualImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeVirtualImageUpdateInput, CafeVirtualImageUncheckedUpdateInput>
  }

  /**
   * CafeVirtualImage delete
   */
  export type CafeVirtualImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
    /**
     * Filter which CafeVirtualImage to delete.
     */
    where: CafeVirtualImageWhereUniqueInput
  }

  /**
   * CafeVirtualImage deleteMany
   */
  export type CafeVirtualImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeVirtualImages to delete
     */
    where?: CafeVirtualImageWhereInput
    /**
     * Limit how many CafeVirtualImages to delete.
     */
    limit?: number
  }

  /**
   * CafeVirtualImage without action
   */
  export type CafeVirtualImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualImage
     */
    select?: CafeVirtualImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualImage
     */
    omit?: CafeVirtualImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualImageInclude<ExtArgs> | null
  }


  /**
   * Model CafeRealImage
   */

  export type AggregateCafeRealImage = {
    _count: CafeRealImageCountAggregateOutputType | null
    _avg: CafeRealImageAvgAggregateOutputType | null
    _sum: CafeRealImageSumAggregateOutputType | null
    _min: CafeRealImageMinAggregateOutputType | null
    _max: CafeRealImageMaxAggregateOutputType | null
  }

  export type CafeRealImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeRealImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    cafeInfoId: number | null
  }

  export type CafeRealImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeRealImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    priority: number | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeRealImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    width: number
    height: number
    size: number
    priority: number
    isDisable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeRealImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeRealImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    cafeInfoId?: true
  }

  export type CafeRealImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeRealImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type CafeRealImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    priority?: true
    isDisable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeRealImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeRealImage to aggregate.
     */
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     */
    orderBy?: CafeRealImageOrderByWithRelationInput | CafeRealImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeRealImages
    **/
    _count?: true | CafeRealImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeRealImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeRealImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeRealImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeRealImageMaxAggregateInputType
  }

  export type GetCafeRealImageAggregateType<T extends CafeRealImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeRealImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeRealImage[P]>
      : GetScalarType<T[P], AggregateCafeRealImage[P]>
  }




  export type CafeRealImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeRealImageWhereInput
    orderBy?: CafeRealImageOrderByWithAggregationInput | CafeRealImageOrderByWithAggregationInput[]
    by: CafeRealImageScalarFieldEnum[] | CafeRealImageScalarFieldEnum
    having?: CafeRealImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeRealImageCountAggregateInputType | true
    _avg?: CafeRealImageAvgAggregateInputType
    _sum?: CafeRealImageSumAggregateInputType
    _min?: CafeRealImageMinAggregateInputType
    _max?: CafeRealImageMaxAggregateInputType
  }

  export type CafeRealImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    width: number
    height: number
    size: number
    priority: number
    isDisable: boolean
    cafeInfoId: number
    _count: CafeRealImageCountAggregateOutputType | null
    _avg: CafeRealImageAvgAggregateOutputType | null
    _sum: CafeRealImageSumAggregateOutputType | null
    _min: CafeRealImageMinAggregateOutputType | null
    _max: CafeRealImageMaxAggregateOutputType | null
  }

  type GetCafeRealImageGroupByPayload<T extends CafeRealImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeRealImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeRealImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeRealImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeRealImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeRealImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeRealImage"]>

  export type CafeRealImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeRealImage"]>

  export type CafeRealImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeRealImage"]>

  export type CafeRealImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    priority?: boolean
    isDisable?: boolean
    cafeInfoId?: boolean
  }

  export type CafeRealImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "url" | "width" | "height" | "size" | "priority" | "isDisable" | "cafeInfoId", ExtArgs["result"]["cafeRealImage"]>
  export type CafeRealImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeRealImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeRealImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $CafeRealImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeRealImage"
    objects: {
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      url: string
      width: number
      height: number
      size: number
      priority: number
      isDisable: boolean
      cafeInfoId: number
    }, ExtArgs["result"]["cafeRealImage"]>
    composites: {}
  }

  type CafeRealImageGetPayload<S extends boolean | null | undefined | CafeRealImageDefaultArgs> = $Result.GetResult<Prisma.$CafeRealImagePayload, S>

  type CafeRealImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeRealImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeRealImageCountAggregateInputType | true
    }

  export interface CafeRealImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeRealImage'], meta: { name: 'CafeRealImage' } }
    /**
     * Find zero or one CafeRealImage that matches the filter.
     * @param {CafeRealImageFindUniqueArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeRealImageFindUniqueArgs>(args: SelectSubset<T, CafeRealImageFindUniqueArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeRealImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeRealImageFindUniqueOrThrowArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeRealImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeRealImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeRealImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageFindFirstArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeRealImageFindFirstArgs>(args?: SelectSubset<T, CafeRealImageFindFirstArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeRealImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageFindFirstOrThrowArgs} args - Arguments to find a CafeRealImage
     * @example
     * // Get one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeRealImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeRealImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeRealImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeRealImages
     * const cafeRealImages = await prisma.cafeRealImage.findMany()
     * 
     * // Get first 10 CafeRealImages
     * const cafeRealImages = await prisma.cafeRealImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeRealImageWithIdOnly = await prisma.cafeRealImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeRealImageFindManyArgs>(args?: SelectSubset<T, CafeRealImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeRealImage.
     * @param {CafeRealImageCreateArgs} args - Arguments to create a CafeRealImage.
     * @example
     * // Create one CafeRealImage
     * const CafeRealImage = await prisma.cafeRealImage.create({
     *   data: {
     *     // ... data to create a CafeRealImage
     *   }
     * })
     * 
     */
    create<T extends CafeRealImageCreateArgs>(args: SelectSubset<T, CafeRealImageCreateArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeRealImages.
     * @param {CafeRealImageCreateManyArgs} args - Arguments to create many CafeRealImages.
     * @example
     * // Create many CafeRealImages
     * const cafeRealImage = await prisma.cafeRealImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeRealImageCreateManyArgs>(args?: SelectSubset<T, CafeRealImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeRealImages and returns the data saved in the database.
     * @param {CafeRealImageCreateManyAndReturnArgs} args - Arguments to create many CafeRealImages.
     * @example
     * // Create many CafeRealImages
     * const cafeRealImage = await prisma.cafeRealImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeRealImages and only return the `id`
     * const cafeRealImageWithIdOnly = await prisma.cafeRealImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeRealImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeRealImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeRealImage.
     * @param {CafeRealImageDeleteArgs} args - Arguments to delete one CafeRealImage.
     * @example
     * // Delete one CafeRealImage
     * const CafeRealImage = await prisma.cafeRealImage.delete({
     *   where: {
     *     // ... filter to delete one CafeRealImage
     *   }
     * })
     * 
     */
    delete<T extends CafeRealImageDeleteArgs>(args: SelectSubset<T, CafeRealImageDeleteArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeRealImage.
     * @param {CafeRealImageUpdateArgs} args - Arguments to update one CafeRealImage.
     * @example
     * // Update one CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeRealImageUpdateArgs>(args: SelectSubset<T, CafeRealImageUpdateArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeRealImages.
     * @param {CafeRealImageDeleteManyArgs} args - Arguments to filter CafeRealImages to delete.
     * @example
     * // Delete a few CafeRealImages
     * const { count } = await prisma.cafeRealImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeRealImageDeleteManyArgs>(args?: SelectSubset<T, CafeRealImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeRealImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeRealImages
     * const cafeRealImage = await prisma.cafeRealImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeRealImageUpdateManyArgs>(args: SelectSubset<T, CafeRealImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeRealImages and returns the data updated in the database.
     * @param {CafeRealImageUpdateManyAndReturnArgs} args - Arguments to update many CafeRealImages.
     * @example
     * // Update many CafeRealImages
     * const cafeRealImage = await prisma.cafeRealImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeRealImages and only return the `id`
     * const cafeRealImageWithIdOnly = await prisma.cafeRealImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeRealImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeRealImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeRealImage.
     * @param {CafeRealImageUpsertArgs} args - Arguments to update or create a CafeRealImage.
     * @example
     * // Update or create a CafeRealImage
     * const cafeRealImage = await prisma.cafeRealImage.upsert({
     *   create: {
     *     // ... data to create a CafeRealImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeRealImage we want to update
     *   }
     * })
     */
    upsert<T extends CafeRealImageUpsertArgs>(args: SelectSubset<T, CafeRealImageUpsertArgs<ExtArgs>>): Prisma__CafeRealImageClient<$Result.GetResult<Prisma.$CafeRealImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeRealImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageCountArgs} args - Arguments to filter CafeRealImages to count.
     * @example
     * // Count the number of CafeRealImages
     * const count = await prisma.cafeRealImage.count({
     *   where: {
     *     // ... the filter for the CafeRealImages we want to count
     *   }
     * })
    **/
    count<T extends CafeRealImageCountArgs>(
      args?: Subset<T, CafeRealImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeRealImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeRealImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeRealImageAggregateArgs>(args: Subset<T, CafeRealImageAggregateArgs>): Prisma.PrismaPromise<GetCafeRealImageAggregateType<T>>

    /**
     * Group by CafeRealImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeRealImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeRealImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeRealImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeRealImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeRealImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeRealImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeRealImage model
   */
  readonly fields: CafeRealImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeRealImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeRealImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeRealImage model
   */
  interface CafeRealImageFieldRefs {
    readonly id: FieldRef<"CafeRealImage", 'Int'>
    readonly createdAt: FieldRef<"CafeRealImage", 'DateTime'>
    readonly url: FieldRef<"CafeRealImage", 'String'>
    readonly width: FieldRef<"CafeRealImage", 'Int'>
    readonly height: FieldRef<"CafeRealImage", 'Int'>
    readonly size: FieldRef<"CafeRealImage", 'Int'>
    readonly priority: FieldRef<"CafeRealImage", 'Int'>
    readonly isDisable: FieldRef<"CafeRealImage", 'Boolean'>
    readonly cafeInfoId: FieldRef<"CafeRealImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeRealImage findUnique
   */
  export type CafeRealImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeRealImage to fetch.
     */
    where: CafeRealImageWhereUniqueInput
  }

  /**
   * CafeRealImage findUniqueOrThrow
   */
  export type CafeRealImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeRealImage to fetch.
     */
    where: CafeRealImageWhereUniqueInput
  }

  /**
   * CafeRealImage findFirst
   */
  export type CafeRealImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeRealImage to fetch.
     */
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     */
    orderBy?: CafeRealImageOrderByWithRelationInput | CafeRealImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeRealImages.
     */
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeRealImages.
     */
    distinct?: CafeRealImageScalarFieldEnum | CafeRealImageScalarFieldEnum[]
  }

  /**
   * CafeRealImage findFirstOrThrow
   */
  export type CafeRealImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeRealImage to fetch.
     */
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     */
    orderBy?: CafeRealImageOrderByWithRelationInput | CafeRealImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeRealImages.
     */
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeRealImages.
     */
    distinct?: CafeRealImageScalarFieldEnum | CafeRealImageScalarFieldEnum[]
  }

  /**
   * CafeRealImage findMany
   */
  export type CafeRealImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeRealImages to fetch.
     */
    where?: CafeRealImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeRealImages to fetch.
     */
    orderBy?: CafeRealImageOrderByWithRelationInput | CafeRealImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeRealImages.
     */
    cursor?: CafeRealImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeRealImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeRealImages.
     */
    skip?: number
    distinct?: CafeRealImageScalarFieldEnum | CafeRealImageScalarFieldEnum[]
  }

  /**
   * CafeRealImage create
   */
  export type CafeRealImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeRealImage.
     */
    data: XOR<CafeRealImageCreateInput, CafeRealImageUncheckedCreateInput>
  }

  /**
   * CafeRealImage createMany
   */
  export type CafeRealImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeRealImages.
     */
    data: CafeRealImageCreateManyInput | CafeRealImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeRealImage createManyAndReturn
   */
  export type CafeRealImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * The data used to create many CafeRealImages.
     */
    data: CafeRealImageCreateManyInput | CafeRealImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeRealImage update
   */
  export type CafeRealImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeRealImage.
     */
    data: XOR<CafeRealImageUpdateInput, CafeRealImageUncheckedUpdateInput>
    /**
     * Choose, which CafeRealImage to update.
     */
    where: CafeRealImageWhereUniqueInput
  }

  /**
   * CafeRealImage updateMany
   */
  export type CafeRealImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeRealImages.
     */
    data: XOR<CafeRealImageUpdateManyMutationInput, CafeRealImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeRealImages to update
     */
    where?: CafeRealImageWhereInput
    /**
     * Limit how many CafeRealImages to update.
     */
    limit?: number
  }

  /**
   * CafeRealImage updateManyAndReturn
   */
  export type CafeRealImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * The data used to update CafeRealImages.
     */
    data: XOR<CafeRealImageUpdateManyMutationInput, CafeRealImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeRealImages to update
     */
    where?: CafeRealImageWhereInput
    /**
     * Limit how many CafeRealImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeRealImage upsert
   */
  export type CafeRealImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeRealImage to update in case it exists.
     */
    where: CafeRealImageWhereUniqueInput
    /**
     * In case the CafeRealImage found by the `where` argument doesn't exist, create a new CafeRealImage with this data.
     */
    create: XOR<CafeRealImageCreateInput, CafeRealImageUncheckedCreateInput>
    /**
     * In case the CafeRealImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeRealImageUpdateInput, CafeRealImageUncheckedUpdateInput>
  }

  /**
   * CafeRealImage delete
   */
  export type CafeRealImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
    /**
     * Filter which CafeRealImage to delete.
     */
    where: CafeRealImageWhereUniqueInput
  }

  /**
   * CafeRealImage deleteMany
   */
  export type CafeRealImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeRealImages to delete
     */
    where?: CafeRealImageWhereInput
    /**
     * Limit how many CafeRealImages to delete.
     */
    limit?: number
  }

  /**
   * CafeRealImage without action
   */
  export type CafeRealImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeRealImage
     */
    select?: CafeRealImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeRealImage
     */
    omit?: CafeRealImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeRealImageInclude<ExtArgs> | null
  }


  /**
   * Model CafeVirtualLink
   */

  export type AggregateCafeVirtualLink = {
    _count: CafeVirtualLinkCountAggregateOutputType | null
    _avg: CafeVirtualLinkAvgAggregateOutputType | null
    _sum: CafeVirtualLinkSumAggregateOutputType | null
    _min: CafeVirtualLinkMinAggregateOutputType | null
    _max: CafeVirtualLinkMaxAggregateOutputType | null
  }

  export type CafeVirtualLinkAvgAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkSumAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    url: string | null
    type: string | null
    isDisable: boolean | null
    isAvaliable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    url: string | null
    type: string | null
    isDisable: boolean | null
    isAvaliable: boolean | null
    cafeInfoId: number | null
  }

  export type CafeVirtualLinkCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    url: number
    type: number
    isDisable: number
    isAvaliable: number
    cafeInfoId: number
    _all: number
  }


  export type CafeVirtualLinkAvgAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkSumAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    url?: true
    type?: true
    isDisable?: true
    isAvaliable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    url?: true
    type?: true
    isDisable?: true
    isAvaliable?: true
    cafeInfoId?: true
  }

  export type CafeVirtualLinkCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    url?: true
    type?: true
    isDisable?: true
    isAvaliable?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeVirtualLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeVirtualLink to aggregate.
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     */
    orderBy?: CafeVirtualLinkOrderByWithRelationInput | CafeVirtualLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeVirtualLinks
    **/
    _count?: true | CafeVirtualLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeVirtualLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeVirtualLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeVirtualLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeVirtualLinkMaxAggregateInputType
  }

  export type GetCafeVirtualLinkAggregateType<T extends CafeVirtualLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeVirtualLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeVirtualLink[P]>
      : GetScalarType<T[P], AggregateCafeVirtualLink[P]>
  }




  export type CafeVirtualLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeVirtualLinkWhereInput
    orderBy?: CafeVirtualLinkOrderByWithAggregationInput | CafeVirtualLinkOrderByWithAggregationInput[]
    by: CafeVirtualLinkScalarFieldEnum[] | CafeVirtualLinkScalarFieldEnum
    having?: CafeVirtualLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeVirtualLinkCountAggregateInputType | true
    _avg?: CafeVirtualLinkAvgAggregateInputType
    _sum?: CafeVirtualLinkSumAggregateInputType
    _min?: CafeVirtualLinkMinAggregateInputType
    _max?: CafeVirtualLinkMaxAggregateInputType
  }

  export type CafeVirtualLinkGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    url: string
    type: string
    isDisable: boolean
    isAvaliable: boolean
    cafeInfoId: number
    _count: CafeVirtualLinkCountAggregateOutputType | null
    _avg: CafeVirtualLinkAvgAggregateOutputType | null
    _sum: CafeVirtualLinkSumAggregateOutputType | null
    _min: CafeVirtualLinkMinAggregateOutputType | null
    _max: CafeVirtualLinkMaxAggregateOutputType | null
  }

  type GetCafeVirtualLinkGroupByPayload<T extends CafeVirtualLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeVirtualLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeVirtualLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeVirtualLinkGroupByOutputType[P]>
            : GetScalarType<T[P], CafeVirtualLinkGroupByOutputType[P]>
        }
      >
    >


  export type CafeVirtualLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
    CafeVirtualLinkThumbnailImage?: boolean | CafeVirtualLink$CafeVirtualLinkThumbnailImageArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualLink"]>

  export type CafeVirtualLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualLink"]>

  export type CafeVirtualLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualLink"]>

  export type CafeVirtualLinkSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId?: boolean
  }

  export type CafeVirtualLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "url" | "type" | "isDisable" | "isAvaliable" | "cafeInfoId", ExtArgs["result"]["cafeVirtualLink"]>
  export type CafeVirtualLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
    CafeVirtualLinkThumbnailImage?: boolean | CafeVirtualLink$CafeVirtualLinkThumbnailImageArgs<ExtArgs>
  }
  export type CafeVirtualLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeVirtualLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $CafeVirtualLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeVirtualLink"
    objects: {
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
      CafeVirtualLinkThumbnailImage: Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      url: string
      type: string
      isDisable: boolean
      isAvaliable: boolean
      cafeInfoId: number
    }, ExtArgs["result"]["cafeVirtualLink"]>
    composites: {}
  }

  type CafeVirtualLinkGetPayload<S extends boolean | null | undefined | CafeVirtualLinkDefaultArgs> = $Result.GetResult<Prisma.$CafeVirtualLinkPayload, S>

  type CafeVirtualLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeVirtualLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeVirtualLinkCountAggregateInputType | true
    }

  export interface CafeVirtualLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeVirtualLink'], meta: { name: 'CafeVirtualLink' } }
    /**
     * Find zero or one CafeVirtualLink that matches the filter.
     * @param {CafeVirtualLinkFindUniqueArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeVirtualLinkFindUniqueArgs>(args: SelectSubset<T, CafeVirtualLinkFindUniqueArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeVirtualLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeVirtualLinkFindUniqueOrThrowArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeVirtualLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeVirtualLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeVirtualLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkFindFirstArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeVirtualLinkFindFirstArgs>(args?: SelectSubset<T, CafeVirtualLinkFindFirstArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeVirtualLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkFindFirstOrThrowArgs} args - Arguments to find a CafeVirtualLink
     * @example
     * // Get one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeVirtualLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeVirtualLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeVirtualLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeVirtualLinks
     * const cafeVirtualLinks = await prisma.cafeVirtualLink.findMany()
     * 
     * // Get first 10 CafeVirtualLinks
     * const cafeVirtualLinks = await prisma.cafeVirtualLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeVirtualLinkWithIdOnly = await prisma.cafeVirtualLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeVirtualLinkFindManyArgs>(args?: SelectSubset<T, CafeVirtualLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeVirtualLink.
     * @param {CafeVirtualLinkCreateArgs} args - Arguments to create a CafeVirtualLink.
     * @example
     * // Create one CafeVirtualLink
     * const CafeVirtualLink = await prisma.cafeVirtualLink.create({
     *   data: {
     *     // ... data to create a CafeVirtualLink
     *   }
     * })
     * 
     */
    create<T extends CafeVirtualLinkCreateArgs>(args: SelectSubset<T, CafeVirtualLinkCreateArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeVirtualLinks.
     * @param {CafeVirtualLinkCreateManyArgs} args - Arguments to create many CafeVirtualLinks.
     * @example
     * // Create many CafeVirtualLinks
     * const cafeVirtualLink = await prisma.cafeVirtualLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeVirtualLinkCreateManyArgs>(args?: SelectSubset<T, CafeVirtualLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeVirtualLinks and returns the data saved in the database.
     * @param {CafeVirtualLinkCreateManyAndReturnArgs} args - Arguments to create many CafeVirtualLinks.
     * @example
     * // Create many CafeVirtualLinks
     * const cafeVirtualLink = await prisma.cafeVirtualLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeVirtualLinks and only return the `id`
     * const cafeVirtualLinkWithIdOnly = await prisma.cafeVirtualLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeVirtualLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeVirtualLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeVirtualLink.
     * @param {CafeVirtualLinkDeleteArgs} args - Arguments to delete one CafeVirtualLink.
     * @example
     * // Delete one CafeVirtualLink
     * const CafeVirtualLink = await prisma.cafeVirtualLink.delete({
     *   where: {
     *     // ... filter to delete one CafeVirtualLink
     *   }
     * })
     * 
     */
    delete<T extends CafeVirtualLinkDeleteArgs>(args: SelectSubset<T, CafeVirtualLinkDeleteArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeVirtualLink.
     * @param {CafeVirtualLinkUpdateArgs} args - Arguments to update one CafeVirtualLink.
     * @example
     * // Update one CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeVirtualLinkUpdateArgs>(args: SelectSubset<T, CafeVirtualLinkUpdateArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeVirtualLinks.
     * @param {CafeVirtualLinkDeleteManyArgs} args - Arguments to filter CafeVirtualLinks to delete.
     * @example
     * // Delete a few CafeVirtualLinks
     * const { count } = await prisma.cafeVirtualLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeVirtualLinkDeleteManyArgs>(args?: SelectSubset<T, CafeVirtualLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeVirtualLinks
     * const cafeVirtualLink = await prisma.cafeVirtualLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeVirtualLinkUpdateManyArgs>(args: SelectSubset<T, CafeVirtualLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualLinks and returns the data updated in the database.
     * @param {CafeVirtualLinkUpdateManyAndReturnArgs} args - Arguments to update many CafeVirtualLinks.
     * @example
     * // Update many CafeVirtualLinks
     * const cafeVirtualLink = await prisma.cafeVirtualLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeVirtualLinks and only return the `id`
     * const cafeVirtualLinkWithIdOnly = await prisma.cafeVirtualLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeVirtualLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeVirtualLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeVirtualLink.
     * @param {CafeVirtualLinkUpsertArgs} args - Arguments to update or create a CafeVirtualLink.
     * @example
     * // Update or create a CafeVirtualLink
     * const cafeVirtualLink = await prisma.cafeVirtualLink.upsert({
     *   create: {
     *     // ... data to create a CafeVirtualLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeVirtualLink we want to update
     *   }
     * })
     */
    upsert<T extends CafeVirtualLinkUpsertArgs>(args: SelectSubset<T, CafeVirtualLinkUpsertArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeVirtualLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkCountArgs} args - Arguments to filter CafeVirtualLinks to count.
     * @example
     * // Count the number of CafeVirtualLinks
     * const count = await prisma.cafeVirtualLink.count({
     *   where: {
     *     // ... the filter for the CafeVirtualLinks we want to count
     *   }
     * })
    **/
    count<T extends CafeVirtualLinkCountArgs>(
      args?: Subset<T, CafeVirtualLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeVirtualLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeVirtualLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeVirtualLinkAggregateArgs>(args: Subset<T, CafeVirtualLinkAggregateArgs>): Prisma.PrismaPromise<GetCafeVirtualLinkAggregateType<T>>

    /**
     * Group by CafeVirtualLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeVirtualLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeVirtualLinkGroupByArgs['orderBy'] }
        : { orderBy?: CafeVirtualLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeVirtualLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeVirtualLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeVirtualLink model
   */
  readonly fields: CafeVirtualLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeVirtualLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeVirtualLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeVirtualLinkThumbnailImage<T extends CafeVirtualLink$CafeVirtualLinkThumbnailImageArgs<ExtArgs> = {}>(args?: Subset<T, CafeVirtualLink$CafeVirtualLinkThumbnailImageArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeVirtualLink model
   */
  interface CafeVirtualLinkFieldRefs {
    readonly id: FieldRef<"CafeVirtualLink", 'Int'>
    readonly createdAt: FieldRef<"CafeVirtualLink", 'DateTime'>
    readonly name: FieldRef<"CafeVirtualLink", 'String'>
    readonly url: FieldRef<"CafeVirtualLink", 'String'>
    readonly type: FieldRef<"CafeVirtualLink", 'String'>
    readonly isDisable: FieldRef<"CafeVirtualLink", 'Boolean'>
    readonly isAvaliable: FieldRef<"CafeVirtualLink", 'Boolean'>
    readonly cafeInfoId: FieldRef<"CafeVirtualLink", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeVirtualLink findUnique
   */
  export type CafeVirtualLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     */
    where: CafeVirtualLinkWhereUniqueInput
  }

  /**
   * CafeVirtualLink findUniqueOrThrow
   */
  export type CafeVirtualLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     */
    where: CafeVirtualLinkWhereUniqueInput
  }

  /**
   * CafeVirtualLink findFirst
   */
  export type CafeVirtualLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     */
    orderBy?: CafeVirtualLinkOrderByWithRelationInput | CafeVirtualLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinks.
     */
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinks.
     */
    distinct?: CafeVirtualLinkScalarFieldEnum | CafeVirtualLinkScalarFieldEnum[]
  }

  /**
   * CafeVirtualLink findFirstOrThrow
   */
  export type CafeVirtualLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLink to fetch.
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     */
    orderBy?: CafeVirtualLinkOrderByWithRelationInput | CafeVirtualLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinks.
     */
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinks.
     */
    distinct?: CafeVirtualLinkScalarFieldEnum | CafeVirtualLinkScalarFieldEnum[]
  }

  /**
   * CafeVirtualLink findMany
   */
  export type CafeVirtualLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLinks to fetch.
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinks to fetch.
     */
    orderBy?: CafeVirtualLinkOrderByWithRelationInput | CafeVirtualLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeVirtualLinks.
     */
    cursor?: CafeVirtualLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinks.
     */
    skip?: number
    distinct?: CafeVirtualLinkScalarFieldEnum | CafeVirtualLinkScalarFieldEnum[]
  }

  /**
   * CafeVirtualLink create
   */
  export type CafeVirtualLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeVirtualLink.
     */
    data: XOR<CafeVirtualLinkCreateInput, CafeVirtualLinkUncheckedCreateInput>
  }

  /**
   * CafeVirtualLink createMany
   */
  export type CafeVirtualLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeVirtualLinks.
     */
    data: CafeVirtualLinkCreateManyInput | CafeVirtualLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeVirtualLink createManyAndReturn
   */
  export type CafeVirtualLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * The data used to create many CafeVirtualLinks.
     */
    data: CafeVirtualLinkCreateManyInput | CafeVirtualLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeVirtualLink update
   */
  export type CafeVirtualLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeVirtualLink.
     */
    data: XOR<CafeVirtualLinkUpdateInput, CafeVirtualLinkUncheckedUpdateInput>
    /**
     * Choose, which CafeVirtualLink to update.
     */
    where: CafeVirtualLinkWhereUniqueInput
  }

  /**
   * CafeVirtualLink updateMany
   */
  export type CafeVirtualLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeVirtualLinks.
     */
    data: XOR<CafeVirtualLinkUpdateManyMutationInput, CafeVirtualLinkUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualLinks to update
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * Limit how many CafeVirtualLinks to update.
     */
    limit?: number
  }

  /**
   * CafeVirtualLink updateManyAndReturn
   */
  export type CafeVirtualLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * The data used to update CafeVirtualLinks.
     */
    data: XOR<CafeVirtualLinkUpdateManyMutationInput, CafeVirtualLinkUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualLinks to update
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * Limit how many CafeVirtualLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeVirtualLink upsert
   */
  export type CafeVirtualLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeVirtualLink to update in case it exists.
     */
    where: CafeVirtualLinkWhereUniqueInput
    /**
     * In case the CafeVirtualLink found by the `where` argument doesn't exist, create a new CafeVirtualLink with this data.
     */
    create: XOR<CafeVirtualLinkCreateInput, CafeVirtualLinkUncheckedCreateInput>
    /**
     * In case the CafeVirtualLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeVirtualLinkUpdateInput, CafeVirtualLinkUncheckedUpdateInput>
  }

  /**
   * CafeVirtualLink delete
   */
  export type CafeVirtualLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
    /**
     * Filter which CafeVirtualLink to delete.
     */
    where: CafeVirtualLinkWhereUniqueInput
  }

  /**
   * CafeVirtualLink deleteMany
   */
  export type CafeVirtualLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeVirtualLinks to delete
     */
    where?: CafeVirtualLinkWhereInput
    /**
     * Limit how many CafeVirtualLinks to delete.
     */
    limit?: number
  }

  /**
   * CafeVirtualLink.CafeVirtualLinkThumbnailImage
   */
  export type CafeVirtualLink$CafeVirtualLinkThumbnailImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    where?: CafeVirtualLinkThumbnailImageWhereInput
  }

  /**
   * CafeVirtualLink without action
   */
  export type CafeVirtualLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLink
     */
    select?: CafeVirtualLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLink
     */
    omit?: CafeVirtualLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkInclude<ExtArgs> | null
  }


  /**
   * Model CafeVirtualLinkThumbnailImage
   */

  export type AggregateCafeVirtualLinkThumbnailImage = {
    _count: CafeVirtualLinkThumbnailImageCountAggregateOutputType | null
    _avg: CafeVirtualLinkThumbnailImageAvgAggregateOutputType | null
    _sum: CafeVirtualLinkThumbnailImageSumAggregateOutputType | null
    _min: CafeVirtualLinkThumbnailImageMinAggregateOutputType | null
    _max: CafeVirtualLinkThumbnailImageMaxAggregateOutputType | null
  }

  export type CafeVirtualLinkThumbnailImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    width: number | null
    height: number | null
    size: number | null
    cafeVirtualLinkId: number | null
  }

  export type CafeVirtualLinkThumbnailImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
    _all: number
  }


  export type CafeVirtualLinkThumbnailImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
  }

  export type CafeVirtualLinkThumbnailImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    width?: true
    height?: true
    size?: true
    cafeVirtualLinkId?: true
    _all?: true
  }

  export type CafeVirtualLinkThumbnailImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeVirtualLinkThumbnailImage to aggregate.
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     */
    orderBy?: CafeVirtualLinkThumbnailImageOrderByWithRelationInput | CafeVirtualLinkThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeVirtualLinkThumbnailImages
    **/
    _count?: true | CafeVirtualLinkThumbnailImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeVirtualLinkThumbnailImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeVirtualLinkThumbnailImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeVirtualLinkThumbnailImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeVirtualLinkThumbnailImageMaxAggregateInputType
  }

  export type GetCafeVirtualLinkThumbnailImageAggregateType<T extends CafeVirtualLinkThumbnailImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeVirtualLinkThumbnailImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeVirtualLinkThumbnailImage[P]>
      : GetScalarType<T[P], AggregateCafeVirtualLinkThumbnailImage[P]>
  }




  export type CafeVirtualLinkThumbnailImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeVirtualLinkThumbnailImageWhereInput
    orderBy?: CafeVirtualLinkThumbnailImageOrderByWithAggregationInput | CafeVirtualLinkThumbnailImageOrderByWithAggregationInput[]
    by: CafeVirtualLinkThumbnailImageScalarFieldEnum[] | CafeVirtualLinkThumbnailImageScalarFieldEnum
    having?: CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeVirtualLinkThumbnailImageCountAggregateInputType | true
    _avg?: CafeVirtualLinkThumbnailImageAvgAggregateInputType
    _sum?: CafeVirtualLinkThumbnailImageSumAggregateInputType
    _min?: CafeVirtualLinkThumbnailImageMinAggregateInputType
    _max?: CafeVirtualLinkThumbnailImageMaxAggregateInputType
  }

  export type CafeVirtualLinkThumbnailImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
    _count: CafeVirtualLinkThumbnailImageCountAggregateOutputType | null
    _avg: CafeVirtualLinkThumbnailImageAvgAggregateOutputType | null
    _sum: CafeVirtualLinkThumbnailImageSumAggregateOutputType | null
    _min: CafeVirtualLinkThumbnailImageMinAggregateOutputType | null
    _max: CafeVirtualLinkThumbnailImageMaxAggregateOutputType | null
  }

  type GetCafeVirtualLinkThumbnailImageGroupByPayload<T extends CafeVirtualLinkThumbnailImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeVirtualLinkThumbnailImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeVirtualLinkThumbnailImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeVirtualLinkThumbnailImageGroupByOutputType[P]>
            : GetScalarType<T[P], CafeVirtualLinkThumbnailImageGroupByOutputType[P]>
        }
      >
    >


  export type CafeVirtualLinkThumbnailImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    cafeVirtualLinkId?: boolean
    CafeVirtualLink?: boolean | CafeVirtualLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualLinkThumbnailImage"]>

  export type CafeVirtualLinkThumbnailImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    cafeVirtualLinkId?: boolean
    CafeVirtualLink?: boolean | CafeVirtualLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualLinkThumbnailImage"]>

  export type CafeVirtualLinkThumbnailImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    cafeVirtualLinkId?: boolean
    CafeVirtualLink?: boolean | CafeVirtualLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeVirtualLinkThumbnailImage"]>

  export type CafeVirtualLinkThumbnailImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    cafeVirtualLinkId?: boolean
  }

  export type CafeVirtualLinkThumbnailImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "url" | "width" | "height" | "size" | "cafeVirtualLinkId", ExtArgs["result"]["cafeVirtualLinkThumbnailImage"]>
  export type CafeVirtualLinkThumbnailImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeVirtualLink?: boolean | CafeVirtualLinkDefaultArgs<ExtArgs>
  }
  export type CafeVirtualLinkThumbnailImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeVirtualLink?: boolean | CafeVirtualLinkDefaultArgs<ExtArgs>
  }
  export type CafeVirtualLinkThumbnailImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeVirtualLink?: boolean | CafeVirtualLinkDefaultArgs<ExtArgs>
  }

  export type $CafeVirtualLinkThumbnailImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeVirtualLinkThumbnailImage"
    objects: {
      CafeVirtualLink: Prisma.$CafeVirtualLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      url: string
      width: number
      height: number
      size: number
      cafeVirtualLinkId: number
    }, ExtArgs["result"]["cafeVirtualLinkThumbnailImage"]>
    composites: {}
  }

  type CafeVirtualLinkThumbnailImageGetPayload<S extends boolean | null | undefined | CafeVirtualLinkThumbnailImageDefaultArgs> = $Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload, S>

  type CafeVirtualLinkThumbnailImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeVirtualLinkThumbnailImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeVirtualLinkThumbnailImageCountAggregateInputType | true
    }

  export interface CafeVirtualLinkThumbnailImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeVirtualLinkThumbnailImage'], meta: { name: 'CafeVirtualLinkThumbnailImage' } }
    /**
     * Find zero or one CafeVirtualLinkThumbnailImage that matches the filter.
     * @param {CafeVirtualLinkThumbnailImageFindUniqueArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeVirtualLinkThumbnailImageFindUniqueArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageFindUniqueArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeVirtualLinkThumbnailImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeVirtualLinkThumbnailImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageFindFirstArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeVirtualLinkThumbnailImageFindFirstArgs>(args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindFirstArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeVirtualLinkThumbnailImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs} args - Arguments to find a CafeVirtualLinkThumbnailImage
     * @example
     * // Get one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeVirtualLinkThumbnailImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImages = await prisma.cafeVirtualLinkThumbnailImage.findMany()
     * 
     * // Get first 10 CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImages = await prisma.cafeVirtualLinkThumbnailImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeVirtualLinkThumbnailImageWithIdOnly = await prisma.cafeVirtualLinkThumbnailImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeVirtualLinkThumbnailImageFindManyArgs>(args?: SelectSubset<T, CafeVirtualLinkThumbnailImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageCreateArgs} args - Arguments to create a CafeVirtualLinkThumbnailImage.
     * @example
     * // Create one CafeVirtualLinkThumbnailImage
     * const CafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.create({
     *   data: {
     *     // ... data to create a CafeVirtualLinkThumbnailImage
     *   }
     * })
     * 
     */
    create<T extends CafeVirtualLinkThumbnailImageCreateArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageCreateArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeVirtualLinkThumbnailImages.
     * @param {CafeVirtualLinkThumbnailImageCreateManyArgs} args - Arguments to create many CafeVirtualLinkThumbnailImages.
     * @example
     * // Create many CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeVirtualLinkThumbnailImageCreateManyArgs>(args?: SelectSubset<T, CafeVirtualLinkThumbnailImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeVirtualLinkThumbnailImages and returns the data saved in the database.
     * @param {CafeVirtualLinkThumbnailImageCreateManyAndReturnArgs} args - Arguments to create many CafeVirtualLinkThumbnailImages.
     * @example
     * // Create many CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeVirtualLinkThumbnailImages and only return the `id`
     * const cafeVirtualLinkThumbnailImageWithIdOnly = await prisma.cafeVirtualLinkThumbnailImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeVirtualLinkThumbnailImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeVirtualLinkThumbnailImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageDeleteArgs} args - Arguments to delete one CafeVirtualLinkThumbnailImage.
     * @example
     * // Delete one CafeVirtualLinkThumbnailImage
     * const CafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.delete({
     *   where: {
     *     // ... filter to delete one CafeVirtualLinkThumbnailImage
     *   }
     * })
     * 
     */
    delete<T extends CafeVirtualLinkThumbnailImageDeleteArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageDeleteArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageUpdateArgs} args - Arguments to update one CafeVirtualLinkThumbnailImage.
     * @example
     * // Update one CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeVirtualLinkThumbnailImageUpdateArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpdateArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeVirtualLinkThumbnailImages.
     * @param {CafeVirtualLinkThumbnailImageDeleteManyArgs} args - Arguments to filter CafeVirtualLinkThumbnailImages to delete.
     * @example
     * // Delete a few CafeVirtualLinkThumbnailImages
     * const { count } = await prisma.cafeVirtualLinkThumbnailImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeVirtualLinkThumbnailImageDeleteManyArgs>(args?: SelectSubset<T, CafeVirtualLinkThumbnailImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualLinkThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeVirtualLinkThumbnailImageUpdateManyArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeVirtualLinkThumbnailImages and returns the data updated in the database.
     * @param {CafeVirtualLinkThumbnailImageUpdateManyAndReturnArgs} args - Arguments to update many CafeVirtualLinkThumbnailImages.
     * @example
     * // Update many CafeVirtualLinkThumbnailImages
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeVirtualLinkThumbnailImages and only return the `id`
     * const cafeVirtualLinkThumbnailImageWithIdOnly = await prisma.cafeVirtualLinkThumbnailImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeVirtualLinkThumbnailImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeVirtualLinkThumbnailImage.
     * @param {CafeVirtualLinkThumbnailImageUpsertArgs} args - Arguments to update or create a CafeVirtualLinkThumbnailImage.
     * @example
     * // Update or create a CafeVirtualLinkThumbnailImage
     * const cafeVirtualLinkThumbnailImage = await prisma.cafeVirtualLinkThumbnailImage.upsert({
     *   create: {
     *     // ... data to create a CafeVirtualLinkThumbnailImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeVirtualLinkThumbnailImage we want to update
     *   }
     * })
     */
    upsert<T extends CafeVirtualLinkThumbnailImageUpsertArgs>(args: SelectSubset<T, CafeVirtualLinkThumbnailImageUpsertArgs<ExtArgs>>): Prisma__CafeVirtualLinkThumbnailImageClient<$Result.GetResult<Prisma.$CafeVirtualLinkThumbnailImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeVirtualLinkThumbnailImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageCountArgs} args - Arguments to filter CafeVirtualLinkThumbnailImages to count.
     * @example
     * // Count the number of CafeVirtualLinkThumbnailImages
     * const count = await prisma.cafeVirtualLinkThumbnailImage.count({
     *   where: {
     *     // ... the filter for the CafeVirtualLinkThumbnailImages we want to count
     *   }
     * })
    **/
    count<T extends CafeVirtualLinkThumbnailImageCountArgs>(
      args?: Subset<T, CafeVirtualLinkThumbnailImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeVirtualLinkThumbnailImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeVirtualLinkThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeVirtualLinkThumbnailImageAggregateArgs>(args: Subset<T, CafeVirtualLinkThumbnailImageAggregateArgs>): Prisma.PrismaPromise<GetCafeVirtualLinkThumbnailImageAggregateType<T>>

    /**
     * Group by CafeVirtualLinkThumbnailImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeVirtualLinkThumbnailImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeVirtualLinkThumbnailImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeVirtualLinkThumbnailImageGroupByArgs['orderBy'] }
        : { orderBy?: CafeVirtualLinkThumbnailImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeVirtualLinkThumbnailImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeVirtualLinkThumbnailImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeVirtualLinkThumbnailImage model
   */
  readonly fields: CafeVirtualLinkThumbnailImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeVirtualLinkThumbnailImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeVirtualLinkThumbnailImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeVirtualLink<T extends CafeVirtualLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeVirtualLinkDefaultArgs<ExtArgs>>): Prisma__CafeVirtualLinkClient<$Result.GetResult<Prisma.$CafeVirtualLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeVirtualLinkThumbnailImage model
   */
  interface CafeVirtualLinkThumbnailImageFieldRefs {
    readonly id: FieldRef<"CafeVirtualLinkThumbnailImage", 'Int'>
    readonly createdAt: FieldRef<"CafeVirtualLinkThumbnailImage", 'DateTime'>
    readonly url: FieldRef<"CafeVirtualLinkThumbnailImage", 'String'>
    readonly width: FieldRef<"CafeVirtualLinkThumbnailImage", 'Int'>
    readonly height: FieldRef<"CafeVirtualLinkThumbnailImage", 'Int'>
    readonly size: FieldRef<"CafeVirtualLinkThumbnailImage", 'Int'>
    readonly cafeVirtualLinkId: FieldRef<"CafeVirtualLinkThumbnailImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeVirtualLinkThumbnailImage findUnique
   */
  export type CafeVirtualLinkThumbnailImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     */
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  /**
   * CafeVirtualLinkThumbnailImage findUniqueOrThrow
   */
  export type CafeVirtualLinkThumbnailImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     */
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  /**
   * CafeVirtualLinkThumbnailImage findFirst
   */
  export type CafeVirtualLinkThumbnailImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     */
    orderBy?: CafeVirtualLinkThumbnailImageOrderByWithRelationInput | CafeVirtualLinkThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinkThumbnailImages.
     */
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinkThumbnailImages.
     */
    distinct?: CafeVirtualLinkThumbnailImageScalarFieldEnum | CafeVirtualLinkThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeVirtualLinkThumbnailImage findFirstOrThrow
   */
  export type CafeVirtualLinkThumbnailImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImage to fetch.
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     */
    orderBy?: CafeVirtualLinkThumbnailImageOrderByWithRelationInput | CafeVirtualLinkThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeVirtualLinkThumbnailImages.
     */
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeVirtualLinkThumbnailImages.
     */
    distinct?: CafeVirtualLinkThumbnailImageScalarFieldEnum | CafeVirtualLinkThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeVirtualLinkThumbnailImage findMany
   */
  export type CafeVirtualLinkThumbnailImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter, which CafeVirtualLinkThumbnailImages to fetch.
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeVirtualLinkThumbnailImages to fetch.
     */
    orderBy?: CafeVirtualLinkThumbnailImageOrderByWithRelationInput | CafeVirtualLinkThumbnailImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeVirtualLinkThumbnailImages.
     */
    cursor?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeVirtualLinkThumbnailImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeVirtualLinkThumbnailImages.
     */
    skip?: number
    distinct?: CafeVirtualLinkThumbnailImageScalarFieldEnum | CafeVirtualLinkThumbnailImageScalarFieldEnum[]
  }

  /**
   * CafeVirtualLinkThumbnailImage create
   */
  export type CafeVirtualLinkThumbnailImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeVirtualLinkThumbnailImage.
     */
    data: XOR<CafeVirtualLinkThumbnailImageCreateInput, CafeVirtualLinkThumbnailImageUncheckedCreateInput>
  }

  /**
   * CafeVirtualLinkThumbnailImage createMany
   */
  export type CafeVirtualLinkThumbnailImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeVirtualLinkThumbnailImages.
     */
    data: CafeVirtualLinkThumbnailImageCreateManyInput | CafeVirtualLinkThumbnailImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeVirtualLinkThumbnailImage createManyAndReturn
   */
  export type CafeVirtualLinkThumbnailImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * The data used to create many CafeVirtualLinkThumbnailImages.
     */
    data: CafeVirtualLinkThumbnailImageCreateManyInput | CafeVirtualLinkThumbnailImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeVirtualLinkThumbnailImage update
   */
  export type CafeVirtualLinkThumbnailImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeVirtualLinkThumbnailImage.
     */
    data: XOR<CafeVirtualLinkThumbnailImageUpdateInput, CafeVirtualLinkThumbnailImageUncheckedUpdateInput>
    /**
     * Choose, which CafeVirtualLinkThumbnailImage to update.
     */
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  /**
   * CafeVirtualLinkThumbnailImage updateMany
   */
  export type CafeVirtualLinkThumbnailImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeVirtualLinkThumbnailImages.
     */
    data: XOR<CafeVirtualLinkThumbnailImageUpdateManyMutationInput, CafeVirtualLinkThumbnailImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualLinkThumbnailImages to update
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * Limit how many CafeVirtualLinkThumbnailImages to update.
     */
    limit?: number
  }

  /**
   * CafeVirtualLinkThumbnailImage updateManyAndReturn
   */
  export type CafeVirtualLinkThumbnailImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * The data used to update CafeVirtualLinkThumbnailImages.
     */
    data: XOR<CafeVirtualLinkThumbnailImageUpdateManyMutationInput, CafeVirtualLinkThumbnailImageUncheckedUpdateManyInput>
    /**
     * Filter which CafeVirtualLinkThumbnailImages to update
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * Limit how many CafeVirtualLinkThumbnailImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeVirtualLinkThumbnailImage upsert
   */
  export type CafeVirtualLinkThumbnailImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeVirtualLinkThumbnailImage to update in case it exists.
     */
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
    /**
     * In case the CafeVirtualLinkThumbnailImage found by the `where` argument doesn't exist, create a new CafeVirtualLinkThumbnailImage with this data.
     */
    create: XOR<CafeVirtualLinkThumbnailImageCreateInput, CafeVirtualLinkThumbnailImageUncheckedCreateInput>
    /**
     * In case the CafeVirtualLinkThumbnailImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeVirtualLinkThumbnailImageUpdateInput, CafeVirtualLinkThumbnailImageUncheckedUpdateInput>
  }

  /**
   * CafeVirtualLinkThumbnailImage delete
   */
  export type CafeVirtualLinkThumbnailImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
    /**
     * Filter which CafeVirtualLinkThumbnailImage to delete.
     */
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  /**
   * CafeVirtualLinkThumbnailImage deleteMany
   */
  export type CafeVirtualLinkThumbnailImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeVirtualLinkThumbnailImages to delete
     */
    where?: CafeVirtualLinkThumbnailImageWhereInput
    /**
     * Limit how many CafeVirtualLinkThumbnailImages to delete.
     */
    limit?: number
  }

  /**
   * CafeVirtualLinkThumbnailImage without action
   */
  export type CafeVirtualLinkThumbnailImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeVirtualLinkThumbnailImage
     */
    select?: CafeVirtualLinkThumbnailImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeVirtualLinkThumbnailImage
     */
    omit?: CafeVirtualLinkThumbnailImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeVirtualLinkThumbnailImageInclude<ExtArgs> | null
  }


  /**
   * Model CafeCouponGroup
   */

  export type AggregateCafeCouponGroup = {
    _count: CafeCouponGroupCountAggregateOutputType | null
    _avg: CafeCouponGroupAvgAggregateOutputType | null
    _sum: CafeCouponGroupSumAggregateOutputType | null
    _min: CafeCouponGroupMinAggregateOutputType | null
    _max: CafeCouponGroupMaxAggregateOutputType | null
  }

  export type CafeCouponGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type CafeCouponGroupSumAggregateOutputType = {
    id: number | null
  }

  export type CafeCouponGroupMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    name: string | null
    tag: string | null
    description: string | null
    isDisable: boolean | null
    startDay: Date | null
    endDay: Date | null
    issuanceStartDay: Date | null
    issuanceEndDay: Date | null
  }

  export type CafeCouponGroupMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    name: string | null
    tag: string | null
    description: string | null
    isDisable: boolean | null
    startDay: Date | null
    endDay: Date | null
    issuanceStartDay: Date | null
    issuanceEndDay: Date | null
  }

  export type CafeCouponGroupCountAggregateOutputType = {
    id: number
    createdAt: number
    code: number
    name: number
    tag: number
    description: number
    isDisable: number
    startDay: number
    endDay: number
    issuanceStartDay: number
    issuanceEndDay: number
    _all: number
  }


  export type CafeCouponGroupAvgAggregateInputType = {
    id?: true
  }

  export type CafeCouponGroupSumAggregateInputType = {
    id?: true
  }

  export type CafeCouponGroupMinAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    name?: true
    tag?: true
    description?: true
    isDisable?: true
    startDay?: true
    endDay?: true
    issuanceStartDay?: true
    issuanceEndDay?: true
  }

  export type CafeCouponGroupMaxAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    name?: true
    tag?: true
    description?: true
    isDisable?: true
    startDay?: true
    endDay?: true
    issuanceStartDay?: true
    issuanceEndDay?: true
  }

  export type CafeCouponGroupCountAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    name?: true
    tag?: true
    description?: true
    isDisable?: true
    startDay?: true
    endDay?: true
    issuanceStartDay?: true
    issuanceEndDay?: true
    _all?: true
  }

  export type CafeCouponGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponGroup to aggregate.
     */
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     */
    orderBy?: CafeCouponGroupOrderByWithRelationInput | CafeCouponGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponGroups
    **/
    _count?: true | CafeCouponGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponGroupMaxAggregateInputType
  }

  export type GetCafeCouponGroupAggregateType<T extends CafeCouponGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponGroup[P]>
      : GetScalarType<T[P], AggregateCafeCouponGroup[P]>
  }




  export type CafeCouponGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponGroupWhereInput
    orderBy?: CafeCouponGroupOrderByWithAggregationInput | CafeCouponGroupOrderByWithAggregationInput[]
    by: CafeCouponGroupScalarFieldEnum[] | CafeCouponGroupScalarFieldEnum
    having?: CafeCouponGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponGroupCountAggregateInputType | true
    _avg?: CafeCouponGroupAvgAggregateInputType
    _sum?: CafeCouponGroupSumAggregateInputType
    _min?: CafeCouponGroupMinAggregateInputType
    _max?: CafeCouponGroupMaxAggregateInputType
  }

  export type CafeCouponGroupGroupByOutputType = {
    id: number
    createdAt: Date
    code: string
    name: string
    tag: string
    description: string
    isDisable: boolean
    startDay: Date
    endDay: Date
    issuanceStartDay: Date
    issuanceEndDay: Date
    _count: CafeCouponGroupCountAggregateOutputType | null
    _avg: CafeCouponGroupAvgAggregateOutputType | null
    _sum: CafeCouponGroupSumAggregateOutputType | null
    _min: CafeCouponGroupMinAggregateOutputType | null
    _max: CafeCouponGroupMaxAggregateOutputType | null
  }

  type GetCafeCouponGroupGroupByPayload<T extends CafeCouponGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeCouponGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponGroupGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    code?: boolean
    name?: boolean
    tag?: boolean
    description?: boolean
    isDisable?: boolean
    startDay?: boolean
    endDay?: boolean
    issuanceStartDay?: boolean
    issuanceEndDay?: boolean
    CafeCoupons?: boolean | CafeCouponGroup$CafeCouponsArgs<ExtArgs>
    CafeCouponGoupPartners?: boolean | CafeCouponGroup$CafeCouponGoupPartnersArgs<ExtArgs>
    _count?: boolean | CafeCouponGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponGroup"]>

  export type CafeCouponGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    code?: boolean
    name?: boolean
    tag?: boolean
    description?: boolean
    isDisable?: boolean
    startDay?: boolean
    endDay?: boolean
    issuanceStartDay?: boolean
    issuanceEndDay?: boolean
  }, ExtArgs["result"]["cafeCouponGroup"]>

  export type CafeCouponGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    code?: boolean
    name?: boolean
    tag?: boolean
    description?: boolean
    isDisable?: boolean
    startDay?: boolean
    endDay?: boolean
    issuanceStartDay?: boolean
    issuanceEndDay?: boolean
  }, ExtArgs["result"]["cafeCouponGroup"]>

  export type CafeCouponGroupSelectScalar = {
    id?: boolean
    createdAt?: boolean
    code?: boolean
    name?: boolean
    tag?: boolean
    description?: boolean
    isDisable?: boolean
    startDay?: boolean
    endDay?: boolean
    issuanceStartDay?: boolean
    issuanceEndDay?: boolean
  }

  export type CafeCouponGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "code" | "name" | "tag" | "description" | "isDisable" | "startDay" | "endDay" | "issuanceStartDay" | "issuanceEndDay", ExtArgs["result"]["cafeCouponGroup"]>
  export type CafeCouponGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupons?: boolean | CafeCouponGroup$CafeCouponsArgs<ExtArgs>
    CafeCouponGoupPartners?: boolean | CafeCouponGroup$CafeCouponGoupPartnersArgs<ExtArgs>
    _count?: boolean | CafeCouponGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CafeCouponGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CafeCouponGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CafeCouponGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeCouponGroup"
    objects: {
      CafeCoupons: Prisma.$CafeCouponPayload<ExtArgs>[]
      CafeCouponGoupPartners: Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      code: string
      name: string
      tag: string
      description: string
      isDisable: boolean
      startDay: Date
      endDay: Date
      issuanceStartDay: Date
      issuanceEndDay: Date
    }, ExtArgs["result"]["cafeCouponGroup"]>
    composites: {}
  }

  type CafeCouponGroupGetPayload<S extends boolean | null | undefined | CafeCouponGroupDefaultArgs> = $Result.GetResult<Prisma.$CafeCouponGroupPayload, S>

  type CafeCouponGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeCouponGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeCouponGroupCountAggregateInputType | true
    }

  export interface CafeCouponGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeCouponGroup'], meta: { name: 'CafeCouponGroup' } }
    /**
     * Find zero or one CafeCouponGroup that matches the filter.
     * @param {CafeCouponGroupFindUniqueArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeCouponGroupFindUniqueArgs>(args: SelectSubset<T, CafeCouponGroupFindUniqueArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeCouponGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeCouponGroupFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeCouponGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeCouponGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupFindFirstArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeCouponGroupFindFirstArgs>(args?: SelectSubset<T, CafeCouponGroupFindFirstArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupFindFirstOrThrowArgs} args - Arguments to find a CafeCouponGroup
     * @example
     * // Get one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeCouponGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeCouponGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeCouponGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponGroups
     * const cafeCouponGroups = await prisma.cafeCouponGroup.findMany()
     * 
     * // Get first 10 CafeCouponGroups
     * const cafeCouponGroups = await prisma.cafeCouponGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeCouponGroupWithIdOnly = await prisma.cafeCouponGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeCouponGroupFindManyArgs>(args?: SelectSubset<T, CafeCouponGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeCouponGroup.
     * @param {CafeCouponGroupCreateArgs} args - Arguments to create a CafeCouponGroup.
     * @example
     * // Create one CafeCouponGroup
     * const CafeCouponGroup = await prisma.cafeCouponGroup.create({
     *   data: {
     *     // ... data to create a CafeCouponGroup
     *   }
     * })
     * 
     */
    create<T extends CafeCouponGroupCreateArgs>(args: SelectSubset<T, CafeCouponGroupCreateArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeCouponGroups.
     * @param {CafeCouponGroupCreateManyArgs} args - Arguments to create many CafeCouponGroups.
     * @example
     * // Create many CafeCouponGroups
     * const cafeCouponGroup = await prisma.cafeCouponGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeCouponGroupCreateManyArgs>(args?: SelectSubset<T, CafeCouponGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeCouponGroups and returns the data saved in the database.
     * @param {CafeCouponGroupCreateManyAndReturnArgs} args - Arguments to create many CafeCouponGroups.
     * @example
     * // Create many CafeCouponGroups
     * const cafeCouponGroup = await prisma.cafeCouponGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeCouponGroups and only return the `id`
     * const cafeCouponGroupWithIdOnly = await prisma.cafeCouponGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeCouponGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeCouponGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeCouponGroup.
     * @param {CafeCouponGroupDeleteArgs} args - Arguments to delete one CafeCouponGroup.
     * @example
     * // Delete one CafeCouponGroup
     * const CafeCouponGroup = await prisma.cafeCouponGroup.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponGroup
     *   }
     * })
     * 
     */
    delete<T extends CafeCouponGroupDeleteArgs>(args: SelectSubset<T, CafeCouponGroupDeleteArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeCouponGroup.
     * @param {CafeCouponGroupUpdateArgs} args - Arguments to update one CafeCouponGroup.
     * @example
     * // Update one CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeCouponGroupUpdateArgs>(args: SelectSubset<T, CafeCouponGroupUpdateArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeCouponGroups.
     * @param {CafeCouponGroupDeleteManyArgs} args - Arguments to filter CafeCouponGroups to delete.
     * @example
     * // Delete a few CafeCouponGroups
     * const { count } = await prisma.cafeCouponGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeCouponGroupDeleteManyArgs>(args?: SelectSubset<T, CafeCouponGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponGroups
     * const cafeCouponGroup = await prisma.cafeCouponGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeCouponGroupUpdateManyArgs>(args: SelectSubset<T, CafeCouponGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponGroups and returns the data updated in the database.
     * @param {CafeCouponGroupUpdateManyAndReturnArgs} args - Arguments to update many CafeCouponGroups.
     * @example
     * // Update many CafeCouponGroups
     * const cafeCouponGroup = await prisma.cafeCouponGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeCouponGroups and only return the `id`
     * const cafeCouponGroupWithIdOnly = await prisma.cafeCouponGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeCouponGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeCouponGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeCouponGroup.
     * @param {CafeCouponGroupUpsertArgs} args - Arguments to update or create a CafeCouponGroup.
     * @example
     * // Update or create a CafeCouponGroup
     * const cafeCouponGroup = await prisma.cafeCouponGroup.upsert({
     *   create: {
     *     // ... data to create a CafeCouponGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponGroup we want to update
     *   }
     * })
     */
    upsert<T extends CafeCouponGroupUpsertArgs>(args: SelectSubset<T, CafeCouponGroupUpsertArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeCouponGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupCountArgs} args - Arguments to filter CafeCouponGroups to count.
     * @example
     * // Count the number of CafeCouponGroups
     * const count = await prisma.cafeCouponGroup.count({
     *   where: {
     *     // ... the filter for the CafeCouponGroups we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponGroupCountArgs>(
      args?: Subset<T, CafeCouponGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponGroupAggregateArgs>(args: Subset<T, CafeCouponGroupAggregateArgs>): Prisma.PrismaPromise<GetCafeCouponGroupAggregateType<T>>

    /**
     * Group by CafeCouponGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponGroupGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeCouponGroup model
   */
  readonly fields: CafeCouponGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeCouponGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeCoupons<T extends CafeCouponGroup$CafeCouponsArgs<ExtArgs> = {}>(args?: Subset<T, CafeCouponGroup$CafeCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeCouponGoupPartners<T extends CafeCouponGroup$CafeCouponGoupPartnersArgs<ExtArgs> = {}>(args?: Subset<T, CafeCouponGroup$CafeCouponGoupPartnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeCouponGroup model
   */
  interface CafeCouponGroupFieldRefs {
    readonly id: FieldRef<"CafeCouponGroup", 'Int'>
    readonly createdAt: FieldRef<"CafeCouponGroup", 'DateTime'>
    readonly code: FieldRef<"CafeCouponGroup", 'String'>
    readonly name: FieldRef<"CafeCouponGroup", 'String'>
    readonly tag: FieldRef<"CafeCouponGroup", 'String'>
    readonly description: FieldRef<"CafeCouponGroup", 'String'>
    readonly isDisable: FieldRef<"CafeCouponGroup", 'Boolean'>
    readonly startDay: FieldRef<"CafeCouponGroup", 'DateTime'>
    readonly endDay: FieldRef<"CafeCouponGroup", 'DateTime'>
    readonly issuanceStartDay: FieldRef<"CafeCouponGroup", 'DateTime'>
    readonly issuanceEndDay: FieldRef<"CafeCouponGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CafeCouponGroup findUnique
   */
  export type CafeCouponGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     */
    where: CafeCouponGroupWhereUniqueInput
  }

  /**
   * CafeCouponGroup findUniqueOrThrow
   */
  export type CafeCouponGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     */
    where: CafeCouponGroupWhereUniqueInput
  }

  /**
   * CafeCouponGroup findFirst
   */
  export type CafeCouponGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     */
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     */
    orderBy?: CafeCouponGroupOrderByWithRelationInput | CafeCouponGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGroups.
     */
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGroups.
     */
    distinct?: CafeCouponGroupScalarFieldEnum | CafeCouponGroupScalarFieldEnum[]
  }

  /**
   * CafeCouponGroup findFirstOrThrow
   */
  export type CafeCouponGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGroup to fetch.
     */
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     */
    orderBy?: CafeCouponGroupOrderByWithRelationInput | CafeCouponGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGroups.
     */
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGroups.
     */
    distinct?: CafeCouponGroupScalarFieldEnum | CafeCouponGroupScalarFieldEnum[]
  }

  /**
   * CafeCouponGroup findMany
   */
  export type CafeCouponGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGroups to fetch.
     */
    where?: CafeCouponGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGroups to fetch.
     */
    orderBy?: CafeCouponGroupOrderByWithRelationInput | CafeCouponGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponGroups.
     */
    cursor?: CafeCouponGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGroups.
     */
    skip?: number
    distinct?: CafeCouponGroupScalarFieldEnum | CafeCouponGroupScalarFieldEnum[]
  }

  /**
   * CafeCouponGroup create
   */
  export type CafeCouponGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeCouponGroup.
     */
    data: XOR<CafeCouponGroupCreateInput, CafeCouponGroupUncheckedCreateInput>
  }

  /**
   * CafeCouponGroup createMany
   */
  export type CafeCouponGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeCouponGroups.
     */
    data: CafeCouponGroupCreateManyInput | CafeCouponGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeCouponGroup createManyAndReturn
   */
  export type CafeCouponGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * The data used to create many CafeCouponGroups.
     */
    data: CafeCouponGroupCreateManyInput | CafeCouponGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeCouponGroup update
   */
  export type CafeCouponGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeCouponGroup.
     */
    data: XOR<CafeCouponGroupUpdateInput, CafeCouponGroupUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponGroup to update.
     */
    where: CafeCouponGroupWhereUniqueInput
  }

  /**
   * CafeCouponGroup updateMany
   */
  export type CafeCouponGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeCouponGroups.
     */
    data: XOR<CafeCouponGroupUpdateManyMutationInput, CafeCouponGroupUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponGroups to update
     */
    where?: CafeCouponGroupWhereInput
    /**
     * Limit how many CafeCouponGroups to update.
     */
    limit?: number
  }

  /**
   * CafeCouponGroup updateManyAndReturn
   */
  export type CafeCouponGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * The data used to update CafeCouponGroups.
     */
    data: XOR<CafeCouponGroupUpdateManyMutationInput, CafeCouponGroupUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponGroups to update
     */
    where?: CafeCouponGroupWhereInput
    /**
     * Limit how many CafeCouponGroups to update.
     */
    limit?: number
  }

  /**
   * CafeCouponGroup upsert
   */
  export type CafeCouponGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeCouponGroup to update in case it exists.
     */
    where: CafeCouponGroupWhereUniqueInput
    /**
     * In case the CafeCouponGroup found by the `where` argument doesn't exist, create a new CafeCouponGroup with this data.
     */
    create: XOR<CafeCouponGroupCreateInput, CafeCouponGroupUncheckedCreateInput>
    /**
     * In case the CafeCouponGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeCouponGroupUpdateInput, CafeCouponGroupUncheckedUpdateInput>
  }

  /**
   * CafeCouponGroup delete
   */
  export type CafeCouponGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
    /**
     * Filter which CafeCouponGroup to delete.
     */
    where: CafeCouponGroupWhereUniqueInput
  }

  /**
   * CafeCouponGroup deleteMany
   */
  export type CafeCouponGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponGroups to delete
     */
    where?: CafeCouponGroupWhereInput
    /**
     * Limit how many CafeCouponGroups to delete.
     */
    limit?: number
  }

  /**
   * CafeCouponGroup.CafeCoupons
   */
  export type CafeCouponGroup$CafeCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    where?: CafeCouponWhereInput
    orderBy?: CafeCouponOrderByWithRelationInput | CafeCouponOrderByWithRelationInput[]
    cursor?: CafeCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponScalarFieldEnum | CafeCouponScalarFieldEnum[]
  }

  /**
   * CafeCouponGroup.CafeCouponGoupPartners
   */
  export type CafeCouponGroup$CafeCouponGoupPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    where?: CafeCouponGoupPartnerWhereInput
    orderBy?: CafeCouponGoupPartnerOrderByWithRelationInput | CafeCouponGoupPartnerOrderByWithRelationInput[]
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponGoupPartnerScalarFieldEnum | CafeCouponGoupPartnerScalarFieldEnum[]
  }

  /**
   * CafeCouponGroup without action
   */
  export type CafeCouponGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGroup
     */
    select?: CafeCouponGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGroup
     */
    omit?: CafeCouponGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGroupInclude<ExtArgs> | null
  }


  /**
   * Model CafeCouponGoupPartner
   */

  export type AggregateCafeCouponGoupPartner = {
    _count: CafeCouponGoupPartnerCountAggregateOutputType | null
    _avg: CafeCouponGoupPartnerAvgAggregateOutputType | null
    _sum: CafeCouponGoupPartnerSumAggregateOutputType | null
    _min: CafeCouponGoupPartnerMinAggregateOutputType | null
    _max: CafeCouponGoupPartnerMaxAggregateOutputType | null
  }

  export type CafeCouponGoupPartnerAvgAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerSumAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerMinAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerMaxAggregateOutputType = {
    cafeCouponGroupId: number | null
    cafeInfoId: number | null
  }

  export type CafeCouponGoupPartnerCountAggregateOutputType = {
    cafeCouponGroupId: number
    cafeInfoId: number
    _all: number
  }


  export type CafeCouponGoupPartnerAvgAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerSumAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerMinAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerMaxAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
  }

  export type CafeCouponGoupPartnerCountAggregateInputType = {
    cafeCouponGroupId?: true
    cafeInfoId?: true
    _all?: true
  }

  export type CafeCouponGoupPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponGoupPartner to aggregate.
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     */
    orderBy?: CafeCouponGoupPartnerOrderByWithRelationInput | CafeCouponGoupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponGoupPartners
    **/
    _count?: true | CafeCouponGoupPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponGoupPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponGoupPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponGoupPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponGoupPartnerMaxAggregateInputType
  }

  export type GetCafeCouponGoupPartnerAggregateType<T extends CafeCouponGoupPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponGoupPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponGoupPartner[P]>
      : GetScalarType<T[P], AggregateCafeCouponGoupPartner[P]>
  }




  export type CafeCouponGoupPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponGoupPartnerWhereInput
    orderBy?: CafeCouponGoupPartnerOrderByWithAggregationInput | CafeCouponGoupPartnerOrderByWithAggregationInput[]
    by: CafeCouponGoupPartnerScalarFieldEnum[] | CafeCouponGoupPartnerScalarFieldEnum
    having?: CafeCouponGoupPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponGoupPartnerCountAggregateInputType | true
    _avg?: CafeCouponGoupPartnerAvgAggregateInputType
    _sum?: CafeCouponGoupPartnerSumAggregateInputType
    _min?: CafeCouponGoupPartnerMinAggregateInputType
    _max?: CafeCouponGoupPartnerMaxAggregateInputType
  }

  export type CafeCouponGoupPartnerGroupByOutputType = {
    cafeCouponGroupId: number
    cafeInfoId: number
    _count: CafeCouponGoupPartnerCountAggregateOutputType | null
    _avg: CafeCouponGoupPartnerAvgAggregateOutputType | null
    _sum: CafeCouponGoupPartnerSumAggregateOutputType | null
    _min: CafeCouponGoupPartnerMinAggregateOutputType | null
    _max: CafeCouponGoupPartnerMaxAggregateOutputType | null
  }

  type GetCafeCouponGoupPartnerGroupByPayload<T extends CafeCouponGoupPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeCouponGoupPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponGoupPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponGoupPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponGoupPartnerGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponGoupPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cafeCouponGroupId?: boolean
    cafeInfoId?: boolean
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponGoupPartner"]>

  export type CafeCouponGoupPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cafeCouponGroupId?: boolean
    cafeInfoId?: boolean
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponGoupPartner"]>

  export type CafeCouponGoupPartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cafeCouponGroupId?: boolean
    cafeInfoId?: boolean
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponGoupPartner"]>

  export type CafeCouponGoupPartnerSelectScalar = {
    cafeCouponGroupId?: boolean
    cafeInfoId?: boolean
  }

  export type CafeCouponGoupPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cafeCouponGroupId" | "cafeInfoId", ExtArgs["result"]["cafeCouponGoupPartner"]>
  export type CafeCouponGoupPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeCouponGoupPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type CafeCouponGoupPartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $CafeCouponGoupPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeCouponGoupPartner"
    objects: {
      CafeCouponGroup: Prisma.$CafeCouponGroupPayload<ExtArgs>
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cafeCouponGroupId: number
      cafeInfoId: number
    }, ExtArgs["result"]["cafeCouponGoupPartner"]>
    composites: {}
  }

  type CafeCouponGoupPartnerGetPayload<S extends boolean | null | undefined | CafeCouponGoupPartnerDefaultArgs> = $Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload, S>

  type CafeCouponGoupPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeCouponGoupPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeCouponGoupPartnerCountAggregateInputType | true
    }

  export interface CafeCouponGoupPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeCouponGoupPartner'], meta: { name: 'CafeCouponGoupPartner' } }
    /**
     * Find zero or one CafeCouponGoupPartner that matches the filter.
     * @param {CafeCouponGoupPartnerFindUniqueArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeCouponGoupPartnerFindUniqueArgs>(args: SelectSubset<T, CafeCouponGoupPartnerFindUniqueArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeCouponGoupPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeCouponGoupPartnerFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeCouponGoupPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeCouponGoupPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponGoupPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerFindFirstArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeCouponGoupPartnerFindFirstArgs>(args?: SelectSubset<T, CafeCouponGoupPartnerFindFirstArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponGoupPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerFindFirstOrThrowArgs} args - Arguments to find a CafeCouponGoupPartner
     * @example
     * // Get one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeCouponGoupPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeCouponGoupPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeCouponGoupPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponGoupPartners
     * const cafeCouponGoupPartners = await prisma.cafeCouponGoupPartner.findMany()
     * 
     * // Get first 10 CafeCouponGoupPartners
     * const cafeCouponGoupPartners = await prisma.cafeCouponGoupPartner.findMany({ take: 10 })
     * 
     * // Only select the `cafeCouponGroupId`
     * const cafeCouponGoupPartnerWithCafeCouponGroupIdOnly = await prisma.cafeCouponGoupPartner.findMany({ select: { cafeCouponGroupId: true } })
     * 
     */
    findMany<T extends CafeCouponGoupPartnerFindManyArgs>(args?: SelectSubset<T, CafeCouponGoupPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerCreateArgs} args - Arguments to create a CafeCouponGoupPartner.
     * @example
     * // Create one CafeCouponGoupPartner
     * const CafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.create({
     *   data: {
     *     // ... data to create a CafeCouponGoupPartner
     *   }
     * })
     * 
     */
    create<T extends CafeCouponGoupPartnerCreateArgs>(args: SelectSubset<T, CafeCouponGoupPartnerCreateArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeCouponGoupPartners.
     * @param {CafeCouponGoupPartnerCreateManyArgs} args - Arguments to create many CafeCouponGoupPartners.
     * @example
     * // Create many CafeCouponGoupPartners
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeCouponGoupPartnerCreateManyArgs>(args?: SelectSubset<T, CafeCouponGoupPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeCouponGoupPartners and returns the data saved in the database.
     * @param {CafeCouponGoupPartnerCreateManyAndReturnArgs} args - Arguments to create many CafeCouponGoupPartners.
     * @example
     * // Create many CafeCouponGoupPartners
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeCouponGoupPartners and only return the `cafeCouponGroupId`
     * const cafeCouponGoupPartnerWithCafeCouponGroupIdOnly = await prisma.cafeCouponGoupPartner.createManyAndReturn({
     *   select: { cafeCouponGroupId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeCouponGoupPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeCouponGoupPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerDeleteArgs} args - Arguments to delete one CafeCouponGoupPartner.
     * @example
     * // Delete one CafeCouponGoupPartner
     * const CafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponGoupPartner
     *   }
     * })
     * 
     */
    delete<T extends CafeCouponGoupPartnerDeleteArgs>(args: SelectSubset<T, CafeCouponGoupPartnerDeleteArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerUpdateArgs} args - Arguments to update one CafeCouponGoupPartner.
     * @example
     * // Update one CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeCouponGoupPartnerUpdateArgs>(args: SelectSubset<T, CafeCouponGoupPartnerUpdateArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeCouponGoupPartners.
     * @param {CafeCouponGoupPartnerDeleteManyArgs} args - Arguments to filter CafeCouponGoupPartners to delete.
     * @example
     * // Delete a few CafeCouponGoupPartners
     * const { count } = await prisma.cafeCouponGoupPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeCouponGoupPartnerDeleteManyArgs>(args?: SelectSubset<T, CafeCouponGoupPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponGoupPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponGoupPartners
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeCouponGoupPartnerUpdateManyArgs>(args: SelectSubset<T, CafeCouponGoupPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponGoupPartners and returns the data updated in the database.
     * @param {CafeCouponGoupPartnerUpdateManyAndReturnArgs} args - Arguments to update many CafeCouponGoupPartners.
     * @example
     * // Update many CafeCouponGoupPartners
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeCouponGoupPartners and only return the `cafeCouponGroupId`
     * const cafeCouponGoupPartnerWithCafeCouponGroupIdOnly = await prisma.cafeCouponGoupPartner.updateManyAndReturn({
     *   select: { cafeCouponGroupId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeCouponGoupPartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeCouponGoupPartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeCouponGoupPartner.
     * @param {CafeCouponGoupPartnerUpsertArgs} args - Arguments to update or create a CafeCouponGoupPartner.
     * @example
     * // Update or create a CafeCouponGoupPartner
     * const cafeCouponGoupPartner = await prisma.cafeCouponGoupPartner.upsert({
     *   create: {
     *     // ... data to create a CafeCouponGoupPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponGoupPartner we want to update
     *   }
     * })
     */
    upsert<T extends CafeCouponGoupPartnerUpsertArgs>(args: SelectSubset<T, CafeCouponGoupPartnerUpsertArgs<ExtArgs>>): Prisma__CafeCouponGoupPartnerClient<$Result.GetResult<Prisma.$CafeCouponGoupPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeCouponGoupPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerCountArgs} args - Arguments to filter CafeCouponGoupPartners to count.
     * @example
     * // Count the number of CafeCouponGoupPartners
     * const count = await prisma.cafeCouponGoupPartner.count({
     *   where: {
     *     // ... the filter for the CafeCouponGoupPartners we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponGoupPartnerCountArgs>(
      args?: Subset<T, CafeCouponGoupPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponGoupPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponGoupPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponGoupPartnerAggregateArgs>(args: Subset<T, CafeCouponGoupPartnerAggregateArgs>): Prisma.PrismaPromise<GetCafeCouponGoupPartnerAggregateType<T>>

    /**
     * Group by CafeCouponGoupPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGoupPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponGoupPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponGoupPartnerGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponGoupPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponGoupPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponGoupPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeCouponGoupPartner model
   */
  readonly fields: CafeCouponGoupPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponGoupPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeCouponGoupPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeCouponGroup<T extends CafeCouponGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeCouponGroupDefaultArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeCouponGoupPartner model
   */
  interface CafeCouponGoupPartnerFieldRefs {
    readonly cafeCouponGroupId: FieldRef<"CafeCouponGoupPartner", 'Int'>
    readonly cafeInfoId: FieldRef<"CafeCouponGoupPartner", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeCouponGoupPartner findUnique
   */
  export type CafeCouponGoupPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     */
    where: CafeCouponGoupPartnerWhereUniqueInput
  }

  /**
   * CafeCouponGoupPartner findUniqueOrThrow
   */
  export type CafeCouponGoupPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     */
    where: CafeCouponGoupPartnerWhereUniqueInput
  }

  /**
   * CafeCouponGoupPartner findFirst
   */
  export type CafeCouponGoupPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     */
    orderBy?: CafeCouponGoupPartnerOrderByWithRelationInput | CafeCouponGoupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGoupPartners.
     */
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGoupPartners.
     */
    distinct?: CafeCouponGoupPartnerScalarFieldEnum | CafeCouponGoupPartnerScalarFieldEnum[]
  }

  /**
   * CafeCouponGoupPartner findFirstOrThrow
   */
  export type CafeCouponGoupPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGoupPartner to fetch.
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     */
    orderBy?: CafeCouponGoupPartnerOrderByWithRelationInput | CafeCouponGoupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponGoupPartners.
     */
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponGoupPartners.
     */
    distinct?: CafeCouponGoupPartnerScalarFieldEnum | CafeCouponGoupPartnerScalarFieldEnum[]
  }

  /**
   * CafeCouponGoupPartner findMany
   */
  export type CafeCouponGoupPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponGoupPartners to fetch.
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponGoupPartners to fetch.
     */
    orderBy?: CafeCouponGoupPartnerOrderByWithRelationInput | CafeCouponGoupPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponGoupPartners.
     */
    cursor?: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponGoupPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponGoupPartners.
     */
    skip?: number
    distinct?: CafeCouponGoupPartnerScalarFieldEnum | CafeCouponGoupPartnerScalarFieldEnum[]
  }

  /**
   * CafeCouponGoupPartner create
   */
  export type CafeCouponGoupPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeCouponGoupPartner.
     */
    data: XOR<CafeCouponGoupPartnerCreateInput, CafeCouponGoupPartnerUncheckedCreateInput>
  }

  /**
   * CafeCouponGoupPartner createMany
   */
  export type CafeCouponGoupPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeCouponGoupPartners.
     */
    data: CafeCouponGoupPartnerCreateManyInput | CafeCouponGoupPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeCouponGoupPartner createManyAndReturn
   */
  export type CafeCouponGoupPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * The data used to create many CafeCouponGoupPartners.
     */
    data: CafeCouponGoupPartnerCreateManyInput | CafeCouponGoupPartnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCouponGoupPartner update
   */
  export type CafeCouponGoupPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeCouponGoupPartner.
     */
    data: XOR<CafeCouponGoupPartnerUpdateInput, CafeCouponGoupPartnerUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponGoupPartner to update.
     */
    where: CafeCouponGoupPartnerWhereUniqueInput
  }

  /**
   * CafeCouponGoupPartner updateMany
   */
  export type CafeCouponGoupPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeCouponGoupPartners.
     */
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponGoupPartners to update
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * Limit how many CafeCouponGoupPartners to update.
     */
    limit?: number
  }

  /**
   * CafeCouponGoupPartner updateManyAndReturn
   */
  export type CafeCouponGoupPartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * The data used to update CafeCouponGoupPartners.
     */
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponGoupPartners to update
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * Limit how many CafeCouponGoupPartners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCouponGoupPartner upsert
   */
  export type CafeCouponGoupPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeCouponGoupPartner to update in case it exists.
     */
    where: CafeCouponGoupPartnerWhereUniqueInput
    /**
     * In case the CafeCouponGoupPartner found by the `where` argument doesn't exist, create a new CafeCouponGoupPartner with this data.
     */
    create: XOR<CafeCouponGoupPartnerCreateInput, CafeCouponGoupPartnerUncheckedCreateInput>
    /**
     * In case the CafeCouponGoupPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeCouponGoupPartnerUpdateInput, CafeCouponGoupPartnerUncheckedUpdateInput>
  }

  /**
   * CafeCouponGoupPartner delete
   */
  export type CafeCouponGoupPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
    /**
     * Filter which CafeCouponGoupPartner to delete.
     */
    where: CafeCouponGoupPartnerWhereUniqueInput
  }

  /**
   * CafeCouponGoupPartner deleteMany
   */
  export type CafeCouponGoupPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponGoupPartners to delete
     */
    where?: CafeCouponGoupPartnerWhereInput
    /**
     * Limit how many CafeCouponGoupPartners to delete.
     */
    limit?: number
  }

  /**
   * CafeCouponGoupPartner without action
   */
  export type CafeCouponGoupPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponGoupPartner
     */
    select?: CafeCouponGoupPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponGoupPartner
     */
    omit?: CafeCouponGoupPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponGoupPartnerInclude<ExtArgs> | null
  }


  /**
   * Model ProxyUser
   */

  export type AggregateProxyUser = {
    _count: ProxyUserCountAggregateOutputType | null
    _avg: ProxyUserAvgAggregateOutputType | null
    _sum: ProxyUserSumAggregateOutputType | null
    _min: ProxyUserMinAggregateOutputType | null
    _max: ProxyUserMaxAggregateOutputType | null
  }

  export type ProxyUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProxyUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProxyUserMinAggregateOutputType = {
    id: number | null
    memberId: string | null
    createdAt: Date | null
    proxyUserType: $Enums.ProxyUserType | null
    name: string | null
    token: string | null
    userId: number | null
  }

  export type ProxyUserMaxAggregateOutputType = {
    id: number | null
    memberId: string | null
    createdAt: Date | null
    proxyUserType: $Enums.ProxyUserType | null
    name: string | null
    token: string | null
    userId: number | null
  }

  export type ProxyUserCountAggregateOutputType = {
    id: number
    memberId: number
    createdAt: number
    proxyUserType: number
    name: number
    token: number
    userId: number
    _all: number
  }


  export type ProxyUserAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProxyUserSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProxyUserMinAggregateInputType = {
    id?: true
    memberId?: true
    createdAt?: true
    proxyUserType?: true
    name?: true
    token?: true
    userId?: true
  }

  export type ProxyUserMaxAggregateInputType = {
    id?: true
    memberId?: true
    createdAt?: true
    proxyUserType?: true
    name?: true
    token?: true
    userId?: true
  }

  export type ProxyUserCountAggregateInputType = {
    id?: true
    memberId?: true
    createdAt?: true
    proxyUserType?: true
    name?: true
    token?: true
    userId?: true
    _all?: true
  }

  export type ProxyUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyUser to aggregate.
     */
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     */
    orderBy?: ProxyUserOrderByWithRelationInput | ProxyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxyUsers
    **/
    _count?: true | ProxyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxyUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxyUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyUserMaxAggregateInputType
  }

  export type GetProxyUserAggregateType<T extends ProxyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateProxyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxyUser[P]>
      : GetScalarType<T[P], AggregateProxyUser[P]>
  }




  export type ProxyUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyUserWhereInput
    orderBy?: ProxyUserOrderByWithAggregationInput | ProxyUserOrderByWithAggregationInput[]
    by: ProxyUserScalarFieldEnum[] | ProxyUserScalarFieldEnum
    having?: ProxyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyUserCountAggregateInputType | true
    _avg?: ProxyUserAvgAggregateInputType
    _sum?: ProxyUserSumAggregateInputType
    _min?: ProxyUserMinAggregateInputType
    _max?: ProxyUserMaxAggregateInputType
  }

  export type ProxyUserGroupByOutputType = {
    id: number
    memberId: string
    createdAt: Date
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    userId: number | null
    _count: ProxyUserCountAggregateOutputType | null
    _avg: ProxyUserAvgAggregateOutputType | null
    _sum: ProxyUserSumAggregateOutputType | null
    _min: ProxyUserMinAggregateOutputType | null
    _max: ProxyUserMaxAggregateOutputType | null
  }

  type GetProxyUserGroupByPayload<T extends ProxyUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyUserGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyUserGroupByOutputType[P]>
        }
      >
    >


  export type ProxyUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    createdAt?: boolean
    proxyUserType?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    User?: boolean | ProxyUser$UserArgs<ExtArgs>
    CafeCoupons?: boolean | ProxyUser$CafeCouponsArgs<ExtArgs>
    WishlistProducts?: boolean | ProxyUser$WishlistProductsArgs<ExtArgs>
    _count?: boolean | ProxyUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyUser"]>

  export type ProxyUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    createdAt?: boolean
    proxyUserType?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    User?: boolean | ProxyUser$UserArgs<ExtArgs>
  }, ExtArgs["result"]["proxyUser"]>

  export type ProxyUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    createdAt?: boolean
    proxyUserType?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    User?: boolean | ProxyUser$UserArgs<ExtArgs>
  }, ExtArgs["result"]["proxyUser"]>

  export type ProxyUserSelectScalar = {
    id?: boolean
    memberId?: boolean
    createdAt?: boolean
    proxyUserType?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
  }

  export type ProxyUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberId" | "createdAt" | "proxyUserType" | "name" | "token" | "userId", ExtArgs["result"]["proxyUser"]>
  export type ProxyUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProxyUser$UserArgs<ExtArgs>
    CafeCoupons?: boolean | ProxyUser$CafeCouponsArgs<ExtArgs>
    WishlistProducts?: boolean | ProxyUser$WishlistProductsArgs<ExtArgs>
    _count?: boolean | ProxyUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProxyUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProxyUser$UserArgs<ExtArgs>
  }
  export type ProxyUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProxyUser$UserArgs<ExtArgs>
  }

  export type $ProxyUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxyUser"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      CafeCoupons: Prisma.$CafeCouponPayload<ExtArgs>[]
      WishlistProducts: Prisma.$WishlistProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memberId: string
      createdAt: Date
      proxyUserType: $Enums.ProxyUserType
      name: string
      token: string
      userId: number | null
    }, ExtArgs["result"]["proxyUser"]>
    composites: {}
  }

  type ProxyUserGetPayload<S extends boolean | null | undefined | ProxyUserDefaultArgs> = $Result.GetResult<Prisma.$ProxyUserPayload, S>

  type ProxyUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyUserCountAggregateInputType | true
    }

  export interface ProxyUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxyUser'], meta: { name: 'ProxyUser' } }
    /**
     * Find zero or one ProxyUser that matches the filter.
     * @param {ProxyUserFindUniqueArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyUserFindUniqueArgs>(args: SelectSubset<T, ProxyUserFindUniqueArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxyUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyUserFindUniqueOrThrowArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserFindFirstArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyUserFindFirstArgs>(args?: SelectSubset<T, ProxyUserFindFirstArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserFindFirstOrThrowArgs} args - Arguments to find a ProxyUser
     * @example
     * // Get one ProxyUser
     * const proxyUser = await prisma.proxyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxyUsers
     * const proxyUsers = await prisma.proxyUser.findMany()
     * 
     * // Get first 10 ProxyUsers
     * const proxyUsers = await prisma.proxyUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyUserWithIdOnly = await prisma.proxyUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyUserFindManyArgs>(args?: SelectSubset<T, ProxyUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxyUser.
     * @param {ProxyUserCreateArgs} args - Arguments to create a ProxyUser.
     * @example
     * // Create one ProxyUser
     * const ProxyUser = await prisma.proxyUser.create({
     *   data: {
     *     // ... data to create a ProxyUser
     *   }
     * })
     * 
     */
    create<T extends ProxyUserCreateArgs>(args: SelectSubset<T, ProxyUserCreateArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxyUsers.
     * @param {ProxyUserCreateManyArgs} args - Arguments to create many ProxyUsers.
     * @example
     * // Create many ProxyUsers
     * const proxyUser = await prisma.proxyUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyUserCreateManyArgs>(args?: SelectSubset<T, ProxyUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxyUsers and returns the data saved in the database.
     * @param {ProxyUserCreateManyAndReturnArgs} args - Arguments to create many ProxyUsers.
     * @example
     * // Create many ProxyUsers
     * const proxyUser = await prisma.proxyUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxyUsers and only return the `id`
     * const proxyUserWithIdOnly = await prisma.proxyUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxyUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxyUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxyUser.
     * @param {ProxyUserDeleteArgs} args - Arguments to delete one ProxyUser.
     * @example
     * // Delete one ProxyUser
     * const ProxyUser = await prisma.proxyUser.delete({
     *   where: {
     *     // ... filter to delete one ProxyUser
     *   }
     * })
     * 
     */
    delete<T extends ProxyUserDeleteArgs>(args: SelectSubset<T, ProxyUserDeleteArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxyUser.
     * @param {ProxyUserUpdateArgs} args - Arguments to update one ProxyUser.
     * @example
     * // Update one ProxyUser
     * const proxyUser = await prisma.proxyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyUserUpdateArgs>(args: SelectSubset<T, ProxyUserUpdateArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxyUsers.
     * @param {ProxyUserDeleteManyArgs} args - Arguments to filter ProxyUsers to delete.
     * @example
     * // Delete a few ProxyUsers
     * const { count } = await prisma.proxyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyUserDeleteManyArgs>(args?: SelectSubset<T, ProxyUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxyUsers
     * const proxyUser = await prisma.proxyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyUserUpdateManyArgs>(args: SelectSubset<T, ProxyUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyUsers and returns the data updated in the database.
     * @param {ProxyUserUpdateManyAndReturnArgs} args - Arguments to update many ProxyUsers.
     * @example
     * // Update many ProxyUsers
     * const proxyUser = await prisma.proxyUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxyUsers and only return the `id`
     * const proxyUserWithIdOnly = await prisma.proxyUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxyUserUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxyUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxyUser.
     * @param {ProxyUserUpsertArgs} args - Arguments to update or create a ProxyUser.
     * @example
     * // Update or create a ProxyUser
     * const proxyUser = await prisma.proxyUser.upsert({
     *   create: {
     *     // ... data to create a ProxyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxyUser we want to update
     *   }
     * })
     */
    upsert<T extends ProxyUserUpsertArgs>(args: SelectSubset<T, ProxyUserUpsertArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserCountArgs} args - Arguments to filter ProxyUsers to count.
     * @example
     * // Count the number of ProxyUsers
     * const count = await prisma.proxyUser.count({
     *   where: {
     *     // ... the filter for the ProxyUsers we want to count
     *   }
     * })
    **/
    count<T extends ProxyUserCountArgs>(
      args?: Subset<T, ProxyUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyUserAggregateArgs>(args: Subset<T, ProxyUserAggregateArgs>): Prisma.PrismaPromise<GetProxyUserAggregateType<T>>

    /**
     * Group by ProxyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyUserGroupByArgs['orderBy'] }
        : { orderBy?: ProxyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxyUser model
   */
  readonly fields: ProxyUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends ProxyUser$UserArgs<ExtArgs> = {}>(args?: Subset<T, ProxyUser$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CafeCoupons<T extends ProxyUser$CafeCouponsArgs<ExtArgs> = {}>(args?: Subset<T, ProxyUser$CafeCouponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WishlistProducts<T extends ProxyUser$WishlistProductsArgs<ExtArgs> = {}>(args?: Subset<T, ProxyUser$WishlistProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxyUser model
   */
  interface ProxyUserFieldRefs {
    readonly id: FieldRef<"ProxyUser", 'Int'>
    readonly memberId: FieldRef<"ProxyUser", 'String'>
    readonly createdAt: FieldRef<"ProxyUser", 'DateTime'>
    readonly proxyUserType: FieldRef<"ProxyUser", 'ProxyUserType'>
    readonly name: FieldRef<"ProxyUser", 'String'>
    readonly token: FieldRef<"ProxyUser", 'String'>
    readonly userId: FieldRef<"ProxyUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProxyUser findUnique
   */
  export type ProxyUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * Filter, which ProxyUser to fetch.
     */
    where: ProxyUserWhereUniqueInput
  }

  /**
   * ProxyUser findUniqueOrThrow
   */
  export type ProxyUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * Filter, which ProxyUser to fetch.
     */
    where: ProxyUserWhereUniqueInput
  }

  /**
   * ProxyUser findFirst
   */
  export type ProxyUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * Filter, which ProxyUser to fetch.
     */
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     */
    orderBy?: ProxyUserOrderByWithRelationInput | ProxyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyUsers.
     */
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyUsers.
     */
    distinct?: ProxyUserScalarFieldEnum | ProxyUserScalarFieldEnum[]
  }

  /**
   * ProxyUser findFirstOrThrow
   */
  export type ProxyUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * Filter, which ProxyUser to fetch.
     */
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     */
    orderBy?: ProxyUserOrderByWithRelationInput | ProxyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyUsers.
     */
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyUsers.
     */
    distinct?: ProxyUserScalarFieldEnum | ProxyUserScalarFieldEnum[]
  }

  /**
   * ProxyUser findMany
   */
  export type ProxyUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * Filter, which ProxyUsers to fetch.
     */
    where?: ProxyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyUsers to fetch.
     */
    orderBy?: ProxyUserOrderByWithRelationInput | ProxyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxyUsers.
     */
    cursor?: ProxyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyUsers.
     */
    skip?: number
    distinct?: ProxyUserScalarFieldEnum | ProxyUserScalarFieldEnum[]
  }

  /**
   * ProxyUser create
   */
  export type ProxyUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxyUser.
     */
    data: XOR<ProxyUserCreateInput, ProxyUserUncheckedCreateInput>
  }

  /**
   * ProxyUser createMany
   */
  export type ProxyUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxyUsers.
     */
    data: ProxyUserCreateManyInput | ProxyUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProxyUser createManyAndReturn
   */
  export type ProxyUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * The data used to create many ProxyUsers.
     */
    data: ProxyUserCreateManyInput | ProxyUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyUser update
   */
  export type ProxyUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxyUser.
     */
    data: XOR<ProxyUserUpdateInput, ProxyUserUncheckedUpdateInput>
    /**
     * Choose, which ProxyUser to update.
     */
    where: ProxyUserWhereUniqueInput
  }

  /**
   * ProxyUser updateMany
   */
  export type ProxyUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxyUsers.
     */
    data: XOR<ProxyUserUpdateManyMutationInput, ProxyUserUncheckedUpdateManyInput>
    /**
     * Filter which ProxyUsers to update
     */
    where?: ProxyUserWhereInput
    /**
     * Limit how many ProxyUsers to update.
     */
    limit?: number
  }

  /**
   * ProxyUser updateManyAndReturn
   */
  export type ProxyUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * The data used to update ProxyUsers.
     */
    data: XOR<ProxyUserUpdateManyMutationInput, ProxyUserUncheckedUpdateManyInput>
    /**
     * Filter which ProxyUsers to update
     */
    where?: ProxyUserWhereInput
    /**
     * Limit how many ProxyUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyUser upsert
   */
  export type ProxyUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxyUser to update in case it exists.
     */
    where: ProxyUserWhereUniqueInput
    /**
     * In case the ProxyUser found by the `where` argument doesn't exist, create a new ProxyUser with this data.
     */
    create: XOR<ProxyUserCreateInput, ProxyUserUncheckedCreateInput>
    /**
     * In case the ProxyUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyUserUpdateInput, ProxyUserUncheckedUpdateInput>
  }

  /**
   * ProxyUser delete
   */
  export type ProxyUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
    /**
     * Filter which ProxyUser to delete.
     */
    where: ProxyUserWhereUniqueInput
  }

  /**
   * ProxyUser deleteMany
   */
  export type ProxyUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyUsers to delete
     */
    where?: ProxyUserWhereInput
    /**
     * Limit how many ProxyUsers to delete.
     */
    limit?: number
  }

  /**
   * ProxyUser.User
   */
  export type ProxyUser$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProxyUser.CafeCoupons
   */
  export type ProxyUser$CafeCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    where?: CafeCouponWhereInput
    orderBy?: CafeCouponOrderByWithRelationInput | CafeCouponOrderByWithRelationInput[]
    cursor?: CafeCouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponScalarFieldEnum | CafeCouponScalarFieldEnum[]
  }

  /**
   * ProxyUser.WishlistProducts
   */
  export type ProxyUser$WishlistProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    where?: WishlistProductWhereInput
    orderBy?: WishlistProductOrderByWithRelationInput | WishlistProductOrderByWithRelationInput[]
    cursor?: WishlistProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistProductScalarFieldEnum | WishlistProductScalarFieldEnum[]
  }

  /**
   * ProxyUser without action
   */
  export type ProxyUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyUser
     */
    select?: ProxyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyUser
     */
    omit?: ProxyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyUserInclude<ExtArgs> | null
  }


  /**
   * Model CafeCoupon
   */

  export type AggregateCafeCoupon = {
    _count: CafeCouponCountAggregateOutputType | null
    _avg: CafeCouponAvgAggregateOutputType | null
    _sum: CafeCouponSumAggregateOutputType | null
    _min: CafeCouponMinAggregateOutputType | null
    _max: CafeCouponMaxAggregateOutputType | null
  }

  export type CafeCouponAvgAggregateOutputType = {
    id: number | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponSumAggregateOutputType = {
    id: number | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    content: string | null
    serialNumber: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    content: string | null
    serialNumber: string | null
    startDay: Date | null
    endDay: Date | null
    isDisable: boolean | null
    proxyUserId: number | null
    cafeCouponGroupId: number | null
  }

  export type CafeCouponCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    content: number
    serialNumber: number
    startDay: number
    endDay: number
    isDisable: number
    proxyUserId: number
    cafeCouponGroupId: number
    _all: number
  }


  export type CafeCouponAvgAggregateInputType = {
    id?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponSumAggregateInputType = {
    id?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    content?: true
    serialNumber?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    content?: true
    serialNumber?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
  }

  export type CafeCouponCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    content?: true
    serialNumber?: true
    startDay?: true
    endDay?: true
    isDisable?: true
    proxyUserId?: true
    cafeCouponGroupId?: true
    _all?: true
  }

  export type CafeCouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCoupon to aggregate.
     */
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     */
    orderBy?: CafeCouponOrderByWithRelationInput | CafeCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCoupons
    **/
    _count?: true | CafeCouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponMaxAggregateInputType
  }

  export type GetCafeCouponAggregateType<T extends CafeCouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCoupon[P]>
      : GetScalarType<T[P], AggregateCafeCoupon[P]>
  }




  export type CafeCouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponWhereInput
    orderBy?: CafeCouponOrderByWithAggregationInput | CafeCouponOrderByWithAggregationInput[]
    by: CafeCouponScalarFieldEnum[] | CafeCouponScalarFieldEnum
    having?: CafeCouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponCountAggregateInputType | true
    _avg?: CafeCouponAvgAggregateInputType
    _sum?: CafeCouponSumAggregateInputType
    _min?: CafeCouponMinAggregateInputType
    _max?: CafeCouponMaxAggregateInputType
  }

  export type CafeCouponGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    content: string
    serialNumber: string
    startDay: Date
    endDay: Date | null
    isDisable: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    _count: CafeCouponCountAggregateOutputType | null
    _avg: CafeCouponAvgAggregateOutputType | null
    _sum: CafeCouponSumAggregateOutputType | null
    _min: CafeCouponMinAggregateOutputType | null
    _max: CafeCouponMaxAggregateOutputType | null
  }

  type GetCafeCouponGroupByPayload<T extends CafeCouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeCouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    content?: boolean
    serialNumber?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    proxyUserId?: boolean
    cafeCouponGroupId?: boolean
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeCouponQRCodes?: boolean | CafeCoupon$CafeCouponQRCodesArgs<ExtArgs>
    CafeCouponHistories?: boolean | CafeCoupon$CafeCouponHistoriesArgs<ExtArgs>
    _count?: boolean | CafeCouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCoupon"]>

  export type CafeCouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    content?: boolean
    serialNumber?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    proxyUserId?: boolean
    cafeCouponGroupId?: boolean
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCoupon"]>

  export type CafeCouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    content?: boolean
    serialNumber?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    proxyUserId?: boolean
    cafeCouponGroupId?: boolean
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCoupon"]>

  export type CafeCouponSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    content?: boolean
    serialNumber?: boolean
    startDay?: boolean
    endDay?: boolean
    isDisable?: boolean
    proxyUserId?: boolean
    cafeCouponGroupId?: boolean
  }

  export type CafeCouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "content" | "serialNumber" | "startDay" | "endDay" | "isDisable" | "proxyUserId" | "cafeCouponGroupId", ExtArgs["result"]["cafeCoupon"]>
  export type CafeCouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
    CafeCouponQRCodes?: boolean | CafeCoupon$CafeCouponQRCodesArgs<ExtArgs>
    CafeCouponHistories?: boolean | CafeCoupon$CafeCouponHistoriesArgs<ExtArgs>
    _count?: boolean | CafeCouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CafeCouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
  }
  export type CafeCouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
    CafeCouponGroup?: boolean | CafeCouponGroupDefaultArgs<ExtArgs>
  }

  export type $CafeCouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeCoupon"
    objects: {
      ProxyUser: Prisma.$ProxyUserPayload<ExtArgs>
      CafeCouponGroup: Prisma.$CafeCouponGroupPayload<ExtArgs>
      CafeCouponQRCodes: Prisma.$CafeCouponQRCodePayload<ExtArgs>[]
      CafeCouponHistories: Prisma.$CafeCouponHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      content: string
      serialNumber: string
      startDay: Date
      endDay: Date | null
      isDisable: boolean
      proxyUserId: number
      cafeCouponGroupId: number
    }, ExtArgs["result"]["cafeCoupon"]>
    composites: {}
  }

  type CafeCouponGetPayload<S extends boolean | null | undefined | CafeCouponDefaultArgs> = $Result.GetResult<Prisma.$CafeCouponPayload, S>

  type CafeCouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeCouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeCouponCountAggregateInputType | true
    }

  export interface CafeCouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeCoupon'], meta: { name: 'CafeCoupon' } }
    /**
     * Find zero or one CafeCoupon that matches the filter.
     * @param {CafeCouponFindUniqueArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeCouponFindUniqueArgs>(args: SelectSubset<T, CafeCouponFindUniqueArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeCoupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeCouponFindUniqueOrThrowArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeCouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeCouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponFindFirstArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeCouponFindFirstArgs>(args?: SelectSubset<T, CafeCouponFindFirstArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCoupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponFindFirstOrThrowArgs} args - Arguments to find a CafeCoupon
     * @example
     * // Get one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeCouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeCouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCoupons
     * const cafeCoupons = await prisma.cafeCoupon.findMany()
     * 
     * // Get first 10 CafeCoupons
     * const cafeCoupons = await prisma.cafeCoupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeCouponWithIdOnly = await prisma.cafeCoupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeCouponFindManyArgs>(args?: SelectSubset<T, CafeCouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeCoupon.
     * @param {CafeCouponCreateArgs} args - Arguments to create a CafeCoupon.
     * @example
     * // Create one CafeCoupon
     * const CafeCoupon = await prisma.cafeCoupon.create({
     *   data: {
     *     // ... data to create a CafeCoupon
     *   }
     * })
     * 
     */
    create<T extends CafeCouponCreateArgs>(args: SelectSubset<T, CafeCouponCreateArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeCoupons.
     * @param {CafeCouponCreateManyArgs} args - Arguments to create many CafeCoupons.
     * @example
     * // Create many CafeCoupons
     * const cafeCoupon = await prisma.cafeCoupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeCouponCreateManyArgs>(args?: SelectSubset<T, CafeCouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeCoupons and returns the data saved in the database.
     * @param {CafeCouponCreateManyAndReturnArgs} args - Arguments to create many CafeCoupons.
     * @example
     * // Create many CafeCoupons
     * const cafeCoupon = await prisma.cafeCoupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeCoupons and only return the `id`
     * const cafeCouponWithIdOnly = await prisma.cafeCoupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeCouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeCouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeCoupon.
     * @param {CafeCouponDeleteArgs} args - Arguments to delete one CafeCoupon.
     * @example
     * // Delete one CafeCoupon
     * const CafeCoupon = await prisma.cafeCoupon.delete({
     *   where: {
     *     // ... filter to delete one CafeCoupon
     *   }
     * })
     * 
     */
    delete<T extends CafeCouponDeleteArgs>(args: SelectSubset<T, CafeCouponDeleteArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeCoupon.
     * @param {CafeCouponUpdateArgs} args - Arguments to update one CafeCoupon.
     * @example
     * // Update one CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeCouponUpdateArgs>(args: SelectSubset<T, CafeCouponUpdateArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeCoupons.
     * @param {CafeCouponDeleteManyArgs} args - Arguments to filter CafeCoupons to delete.
     * @example
     * // Delete a few CafeCoupons
     * const { count } = await prisma.cafeCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeCouponDeleteManyArgs>(args?: SelectSubset<T, CafeCouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCoupons
     * const cafeCoupon = await prisma.cafeCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeCouponUpdateManyArgs>(args: SelectSubset<T, CafeCouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCoupons and returns the data updated in the database.
     * @param {CafeCouponUpdateManyAndReturnArgs} args - Arguments to update many CafeCoupons.
     * @example
     * // Update many CafeCoupons
     * const cafeCoupon = await prisma.cafeCoupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeCoupons and only return the `id`
     * const cafeCouponWithIdOnly = await prisma.cafeCoupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeCouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeCouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeCoupon.
     * @param {CafeCouponUpsertArgs} args - Arguments to update or create a CafeCoupon.
     * @example
     * // Update or create a CafeCoupon
     * const cafeCoupon = await prisma.cafeCoupon.upsert({
     *   create: {
     *     // ... data to create a CafeCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCoupon we want to update
     *   }
     * })
     */
    upsert<T extends CafeCouponUpsertArgs>(args: SelectSubset<T, CafeCouponUpsertArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponCountArgs} args - Arguments to filter CafeCoupons to count.
     * @example
     * // Count the number of CafeCoupons
     * const count = await prisma.cafeCoupon.count({
     *   where: {
     *     // ... the filter for the CafeCoupons we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponCountArgs>(
      args?: Subset<T, CafeCouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponAggregateArgs>(args: Subset<T, CafeCouponAggregateArgs>): Prisma.PrismaPromise<GetCafeCouponAggregateType<T>>

    /**
     * Group by CafeCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeCoupon model
   */
  readonly fields: CafeCouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeCouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProxyUser<T extends ProxyUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProxyUserDefaultArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeCouponGroup<T extends CafeCouponGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeCouponGroupDefaultArgs<ExtArgs>>): Prisma__CafeCouponGroupClient<$Result.GetResult<Prisma.$CafeCouponGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeCouponQRCodes<T extends CafeCoupon$CafeCouponQRCodesArgs<ExtArgs> = {}>(args?: Subset<T, CafeCoupon$CafeCouponQRCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CafeCouponHistories<T extends CafeCoupon$CafeCouponHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, CafeCoupon$CafeCouponHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeCoupon model
   */
  interface CafeCouponFieldRefs {
    readonly id: FieldRef<"CafeCoupon", 'Int'>
    readonly createdAt: FieldRef<"CafeCoupon", 'DateTime'>
    readonly name: FieldRef<"CafeCoupon", 'String'>
    readonly content: FieldRef<"CafeCoupon", 'String'>
    readonly serialNumber: FieldRef<"CafeCoupon", 'String'>
    readonly startDay: FieldRef<"CafeCoupon", 'DateTime'>
    readonly endDay: FieldRef<"CafeCoupon", 'DateTime'>
    readonly isDisable: FieldRef<"CafeCoupon", 'Boolean'>
    readonly proxyUserId: FieldRef<"CafeCoupon", 'Int'>
    readonly cafeCouponGroupId: FieldRef<"CafeCoupon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CafeCoupon findUnique
   */
  export type CafeCouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * Filter, which CafeCoupon to fetch.
     */
    where: CafeCouponWhereUniqueInput
  }

  /**
   * CafeCoupon findUniqueOrThrow
   */
  export type CafeCouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * Filter, which CafeCoupon to fetch.
     */
    where: CafeCouponWhereUniqueInput
  }

  /**
   * CafeCoupon findFirst
   */
  export type CafeCouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * Filter, which CafeCoupon to fetch.
     */
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     */
    orderBy?: CafeCouponOrderByWithRelationInput | CafeCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCoupons.
     */
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCoupons.
     */
    distinct?: CafeCouponScalarFieldEnum | CafeCouponScalarFieldEnum[]
  }

  /**
   * CafeCoupon findFirstOrThrow
   */
  export type CafeCouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * Filter, which CafeCoupon to fetch.
     */
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     */
    orderBy?: CafeCouponOrderByWithRelationInput | CafeCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCoupons.
     */
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCoupons.
     */
    distinct?: CafeCouponScalarFieldEnum | CafeCouponScalarFieldEnum[]
  }

  /**
   * CafeCoupon findMany
   */
  export type CafeCouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * Filter, which CafeCoupons to fetch.
     */
    where?: CafeCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCoupons to fetch.
     */
    orderBy?: CafeCouponOrderByWithRelationInput | CafeCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCoupons.
     */
    cursor?: CafeCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCoupons.
     */
    skip?: number
    distinct?: CafeCouponScalarFieldEnum | CafeCouponScalarFieldEnum[]
  }

  /**
   * CafeCoupon create
   */
  export type CafeCouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeCoupon.
     */
    data: XOR<CafeCouponCreateInput, CafeCouponUncheckedCreateInput>
  }

  /**
   * CafeCoupon createMany
   */
  export type CafeCouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeCoupons.
     */
    data: CafeCouponCreateManyInput | CafeCouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeCoupon createManyAndReturn
   */
  export type CafeCouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * The data used to create many CafeCoupons.
     */
    data: CafeCouponCreateManyInput | CafeCouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCoupon update
   */
  export type CafeCouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeCoupon.
     */
    data: XOR<CafeCouponUpdateInput, CafeCouponUncheckedUpdateInput>
    /**
     * Choose, which CafeCoupon to update.
     */
    where: CafeCouponWhereUniqueInput
  }

  /**
   * CafeCoupon updateMany
   */
  export type CafeCouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeCoupons.
     */
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyInput>
    /**
     * Filter which CafeCoupons to update
     */
    where?: CafeCouponWhereInput
    /**
     * Limit how many CafeCoupons to update.
     */
    limit?: number
  }

  /**
   * CafeCoupon updateManyAndReturn
   */
  export type CafeCouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * The data used to update CafeCoupons.
     */
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyInput>
    /**
     * Filter which CafeCoupons to update
     */
    where?: CafeCouponWhereInput
    /**
     * Limit how many CafeCoupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCoupon upsert
   */
  export type CafeCouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeCoupon to update in case it exists.
     */
    where: CafeCouponWhereUniqueInput
    /**
     * In case the CafeCoupon found by the `where` argument doesn't exist, create a new CafeCoupon with this data.
     */
    create: XOR<CafeCouponCreateInput, CafeCouponUncheckedCreateInput>
    /**
     * In case the CafeCoupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeCouponUpdateInput, CafeCouponUncheckedUpdateInput>
  }

  /**
   * CafeCoupon delete
   */
  export type CafeCouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    /**
     * Filter which CafeCoupon to delete.
     */
    where: CafeCouponWhereUniqueInput
  }

  /**
   * CafeCoupon deleteMany
   */
  export type CafeCouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCoupons to delete
     */
    where?: CafeCouponWhereInput
    /**
     * Limit how many CafeCoupons to delete.
     */
    limit?: number
  }

  /**
   * CafeCoupon.CafeCouponQRCodes
   */
  export type CafeCoupon$CafeCouponQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    where?: CafeCouponQRCodeWhereInput
    orderBy?: CafeCouponQRCodeOrderByWithRelationInput | CafeCouponQRCodeOrderByWithRelationInput[]
    cursor?: CafeCouponQRCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponQRCodeScalarFieldEnum | CafeCouponQRCodeScalarFieldEnum[]
  }

  /**
   * CafeCoupon.CafeCouponHistories
   */
  export type CafeCoupon$CafeCouponHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    where?: CafeCouponHistoryWhereInput
    orderBy?: CafeCouponHistoryOrderByWithRelationInput | CafeCouponHistoryOrderByWithRelationInput[]
    cursor?: CafeCouponHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeCouponHistoryScalarFieldEnum | CafeCouponHistoryScalarFieldEnum[]
  }

  /**
   * CafeCoupon without action
   */
  export type CafeCouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
  }


  /**
   * Model CafeCouponHistory
   */

  export type AggregateCafeCouponHistory = {
    _count: CafeCouponHistoryCountAggregateOutputType | null
    _avg: CafeCouponHistoryAvgAggregateOutputType | null
    _sum: CafeCouponHistorySumAggregateOutputType | null
    _min: CafeCouponHistoryMinAggregateOutputType | null
    _max: CafeCouponHistoryMaxAggregateOutputType | null
  }

  export type CafeCouponHistoryAvgAggregateOutputType = {
    id: number | null
    cafeCouponId: number | null
    actorId: number | null
  }

  export type CafeCouponHistorySumAggregateOutputType = {
    id: number | null
    cafeCouponId: number | null
    actorId: number | null
  }

  export type CafeCouponHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    cafeCouponId: number | null
    eventType: $Enums.CafeCouponEventType | null
    description: string | null
    actorId: number | null
    statusBefore: $Enums.CafeCouponStatus | null
    statusAfter: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    cafeCouponId: number | null
    eventType: $Enums.CafeCouponEventType | null
    description: string | null
    actorId: number | null
    statusBefore: $Enums.CafeCouponStatus | null
    statusAfter: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    cafeCouponId: number
    eventType: number
    description: number
    actorId: number
    statusBefore: number
    statusAfter: number
    _all: number
  }


  export type CafeCouponHistoryAvgAggregateInputType = {
    id?: true
    cafeCouponId?: true
    actorId?: true
  }

  export type CafeCouponHistorySumAggregateInputType = {
    id?: true
    cafeCouponId?: true
    actorId?: true
  }

  export type CafeCouponHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    cafeCouponId?: true
    eventType?: true
    description?: true
    actorId?: true
    statusBefore?: true
    statusAfter?: true
  }

  export type CafeCouponHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    cafeCouponId?: true
    eventType?: true
    description?: true
    actorId?: true
    statusBefore?: true
    statusAfter?: true
  }

  export type CafeCouponHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    cafeCouponId?: true
    eventType?: true
    description?: true
    actorId?: true
    statusBefore?: true
    statusAfter?: true
    _all?: true
  }

  export type CafeCouponHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponHistory to aggregate.
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     */
    orderBy?: CafeCouponHistoryOrderByWithRelationInput | CafeCouponHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponHistories
    **/
    _count?: true | CafeCouponHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponHistoryMaxAggregateInputType
  }

  export type GetCafeCouponHistoryAggregateType<T extends CafeCouponHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponHistory[P]>
      : GetScalarType<T[P], AggregateCafeCouponHistory[P]>
  }




  export type CafeCouponHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponHistoryWhereInput
    orderBy?: CafeCouponHistoryOrderByWithAggregationInput | CafeCouponHistoryOrderByWithAggregationInput[]
    by: CafeCouponHistoryScalarFieldEnum[] | CafeCouponHistoryScalarFieldEnum
    having?: CafeCouponHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponHistoryCountAggregateInputType | true
    _avg?: CafeCouponHistoryAvgAggregateInputType
    _sum?: CafeCouponHistorySumAggregateInputType
    _min?: CafeCouponHistoryMinAggregateInputType
    _max?: CafeCouponHistoryMaxAggregateInputType
  }

  export type CafeCouponHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    cafeCouponId: number
    eventType: $Enums.CafeCouponEventType
    description: string
    actorId: number
    statusBefore: $Enums.CafeCouponStatus | null
    statusAfter: $Enums.CafeCouponStatus | null
    _count: CafeCouponHistoryCountAggregateOutputType | null
    _avg: CafeCouponHistoryAvgAggregateOutputType | null
    _sum: CafeCouponHistorySumAggregateOutputType | null
    _min: CafeCouponHistoryMinAggregateOutputType | null
    _max: CafeCouponHistoryMaxAggregateOutputType | null
  }

  type GetCafeCouponHistoryGroupByPayload<T extends CafeCouponHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeCouponHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    cafeCouponId?: boolean
    eventType?: boolean
    description?: boolean
    actorId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
    CafeCoupon?: boolean | CafeCouponDefaultArgs<ExtArgs>
    Actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponHistory"]>

  export type CafeCouponHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    cafeCouponId?: boolean
    eventType?: boolean
    description?: boolean
    actorId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
    CafeCoupon?: boolean | CafeCouponDefaultArgs<ExtArgs>
    Actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponHistory"]>

  export type CafeCouponHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    cafeCouponId?: boolean
    eventType?: boolean
    description?: boolean
    actorId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
    CafeCoupon?: boolean | CafeCouponDefaultArgs<ExtArgs>
    Actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponHistory"]>

  export type CafeCouponHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    cafeCouponId?: boolean
    eventType?: boolean
    description?: boolean
    actorId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
  }

  export type CafeCouponHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "cafeCouponId" | "eventType" | "description" | "actorId" | "statusBefore" | "statusAfter", ExtArgs["result"]["cafeCouponHistory"]>
  export type CafeCouponHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupon?: boolean | CafeCouponDefaultArgs<ExtArgs>
    Actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CafeCouponHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupon?: boolean | CafeCouponDefaultArgs<ExtArgs>
    Actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CafeCouponHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupon?: boolean | CafeCouponDefaultArgs<ExtArgs>
    Actor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CafeCouponHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeCouponHistory"
    objects: {
      CafeCoupon: Prisma.$CafeCouponPayload<ExtArgs>
      Actor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      cafeCouponId: number
      eventType: $Enums.CafeCouponEventType
      description: string
      actorId: number
      statusBefore: $Enums.CafeCouponStatus | null
      statusAfter: $Enums.CafeCouponStatus | null
    }, ExtArgs["result"]["cafeCouponHistory"]>
    composites: {}
  }

  type CafeCouponHistoryGetPayload<S extends boolean | null | undefined | CafeCouponHistoryDefaultArgs> = $Result.GetResult<Prisma.$CafeCouponHistoryPayload, S>

  type CafeCouponHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeCouponHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeCouponHistoryCountAggregateInputType | true
    }

  export interface CafeCouponHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeCouponHistory'], meta: { name: 'CafeCouponHistory' } }
    /**
     * Find zero or one CafeCouponHistory that matches the filter.
     * @param {CafeCouponHistoryFindUniqueArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeCouponHistoryFindUniqueArgs>(args: SelectSubset<T, CafeCouponHistoryFindUniqueArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeCouponHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeCouponHistoryFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeCouponHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeCouponHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryFindFirstArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeCouponHistoryFindFirstArgs>(args?: SelectSubset<T, CafeCouponHistoryFindFirstArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryFindFirstOrThrowArgs} args - Arguments to find a CafeCouponHistory
     * @example
     * // Get one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeCouponHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeCouponHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeCouponHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponHistories
     * const cafeCouponHistories = await prisma.cafeCouponHistory.findMany()
     * 
     * // Get first 10 CafeCouponHistories
     * const cafeCouponHistories = await prisma.cafeCouponHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeCouponHistoryWithIdOnly = await prisma.cafeCouponHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeCouponHistoryFindManyArgs>(args?: SelectSubset<T, CafeCouponHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeCouponHistory.
     * @param {CafeCouponHistoryCreateArgs} args - Arguments to create a CafeCouponHistory.
     * @example
     * // Create one CafeCouponHistory
     * const CafeCouponHistory = await prisma.cafeCouponHistory.create({
     *   data: {
     *     // ... data to create a CafeCouponHistory
     *   }
     * })
     * 
     */
    create<T extends CafeCouponHistoryCreateArgs>(args: SelectSubset<T, CafeCouponHistoryCreateArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeCouponHistories.
     * @param {CafeCouponHistoryCreateManyArgs} args - Arguments to create many CafeCouponHistories.
     * @example
     * // Create many CafeCouponHistories
     * const cafeCouponHistory = await prisma.cafeCouponHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeCouponHistoryCreateManyArgs>(args?: SelectSubset<T, CafeCouponHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeCouponHistories and returns the data saved in the database.
     * @param {CafeCouponHistoryCreateManyAndReturnArgs} args - Arguments to create many CafeCouponHistories.
     * @example
     * // Create many CafeCouponHistories
     * const cafeCouponHistory = await prisma.cafeCouponHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeCouponHistories and only return the `id`
     * const cafeCouponHistoryWithIdOnly = await prisma.cafeCouponHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeCouponHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeCouponHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeCouponHistory.
     * @param {CafeCouponHistoryDeleteArgs} args - Arguments to delete one CafeCouponHistory.
     * @example
     * // Delete one CafeCouponHistory
     * const CafeCouponHistory = await prisma.cafeCouponHistory.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponHistory
     *   }
     * })
     * 
     */
    delete<T extends CafeCouponHistoryDeleteArgs>(args: SelectSubset<T, CafeCouponHistoryDeleteArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeCouponHistory.
     * @param {CafeCouponHistoryUpdateArgs} args - Arguments to update one CafeCouponHistory.
     * @example
     * // Update one CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeCouponHistoryUpdateArgs>(args: SelectSubset<T, CafeCouponHistoryUpdateArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeCouponHistories.
     * @param {CafeCouponHistoryDeleteManyArgs} args - Arguments to filter CafeCouponHistories to delete.
     * @example
     * // Delete a few CafeCouponHistories
     * const { count } = await prisma.cafeCouponHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeCouponHistoryDeleteManyArgs>(args?: SelectSubset<T, CafeCouponHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponHistories
     * const cafeCouponHistory = await prisma.cafeCouponHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeCouponHistoryUpdateManyArgs>(args: SelectSubset<T, CafeCouponHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponHistories and returns the data updated in the database.
     * @param {CafeCouponHistoryUpdateManyAndReturnArgs} args - Arguments to update many CafeCouponHistories.
     * @example
     * // Update many CafeCouponHistories
     * const cafeCouponHistory = await prisma.cafeCouponHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeCouponHistories and only return the `id`
     * const cafeCouponHistoryWithIdOnly = await prisma.cafeCouponHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeCouponHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeCouponHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeCouponHistory.
     * @param {CafeCouponHistoryUpsertArgs} args - Arguments to update or create a CafeCouponHistory.
     * @example
     * // Update or create a CafeCouponHistory
     * const cafeCouponHistory = await prisma.cafeCouponHistory.upsert({
     *   create: {
     *     // ... data to create a CafeCouponHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponHistory we want to update
     *   }
     * })
     */
    upsert<T extends CafeCouponHistoryUpsertArgs>(args: SelectSubset<T, CafeCouponHistoryUpsertArgs<ExtArgs>>): Prisma__CafeCouponHistoryClient<$Result.GetResult<Prisma.$CafeCouponHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeCouponHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryCountArgs} args - Arguments to filter CafeCouponHistories to count.
     * @example
     * // Count the number of CafeCouponHistories
     * const count = await prisma.cafeCouponHistory.count({
     *   where: {
     *     // ... the filter for the CafeCouponHistories we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponHistoryCountArgs>(
      args?: Subset<T, CafeCouponHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponHistoryAggregateArgs>(args: Subset<T, CafeCouponHistoryAggregateArgs>): Prisma.PrismaPromise<GetCafeCouponHistoryAggregateType<T>>

    /**
     * Group by CafeCouponHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeCouponHistory model
   */
  readonly fields: CafeCouponHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeCouponHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeCoupon<T extends CafeCouponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeCouponDefaultArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeCouponHistory model
   */
  interface CafeCouponHistoryFieldRefs {
    readonly id: FieldRef<"CafeCouponHistory", 'Int'>
    readonly createdAt: FieldRef<"CafeCouponHistory", 'DateTime'>
    readonly cafeCouponId: FieldRef<"CafeCouponHistory", 'Int'>
    readonly eventType: FieldRef<"CafeCouponHistory", 'CafeCouponEventType'>
    readonly description: FieldRef<"CafeCouponHistory", 'String'>
    readonly actorId: FieldRef<"CafeCouponHistory", 'Int'>
    readonly statusBefore: FieldRef<"CafeCouponHistory", 'CafeCouponStatus'>
    readonly statusAfter: FieldRef<"CafeCouponHistory", 'CafeCouponStatus'>
  }
    

  // Custom InputTypes
  /**
   * CafeCouponHistory findUnique
   */
  export type CafeCouponHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     */
    where: CafeCouponHistoryWhereUniqueInput
  }

  /**
   * CafeCouponHistory findUniqueOrThrow
   */
  export type CafeCouponHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     */
    where: CafeCouponHistoryWhereUniqueInput
  }

  /**
   * CafeCouponHistory findFirst
   */
  export type CafeCouponHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     */
    orderBy?: CafeCouponHistoryOrderByWithRelationInput | CafeCouponHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponHistories.
     */
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponHistories.
     */
    distinct?: CafeCouponHistoryScalarFieldEnum | CafeCouponHistoryScalarFieldEnum[]
  }

  /**
   * CafeCouponHistory findFirstOrThrow
   */
  export type CafeCouponHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponHistory to fetch.
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     */
    orderBy?: CafeCouponHistoryOrderByWithRelationInput | CafeCouponHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponHistories.
     */
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponHistories.
     */
    distinct?: CafeCouponHistoryScalarFieldEnum | CafeCouponHistoryScalarFieldEnum[]
  }

  /**
   * CafeCouponHistory findMany
   */
  export type CafeCouponHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponHistories to fetch.
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponHistories to fetch.
     */
    orderBy?: CafeCouponHistoryOrderByWithRelationInput | CafeCouponHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponHistories.
     */
    cursor?: CafeCouponHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponHistories.
     */
    skip?: number
    distinct?: CafeCouponHistoryScalarFieldEnum | CafeCouponHistoryScalarFieldEnum[]
  }

  /**
   * CafeCouponHistory create
   */
  export type CafeCouponHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeCouponHistory.
     */
    data: XOR<CafeCouponHistoryCreateInput, CafeCouponHistoryUncheckedCreateInput>
  }

  /**
   * CafeCouponHistory createMany
   */
  export type CafeCouponHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeCouponHistories.
     */
    data: CafeCouponHistoryCreateManyInput | CafeCouponHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeCouponHistory createManyAndReturn
   */
  export type CafeCouponHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many CafeCouponHistories.
     */
    data: CafeCouponHistoryCreateManyInput | CafeCouponHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCouponHistory update
   */
  export type CafeCouponHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeCouponHistory.
     */
    data: XOR<CafeCouponHistoryUpdateInput, CafeCouponHistoryUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponHistory to update.
     */
    where: CafeCouponHistoryWhereUniqueInput
  }

  /**
   * CafeCouponHistory updateMany
   */
  export type CafeCouponHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeCouponHistories.
     */
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponHistories to update
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * Limit how many CafeCouponHistories to update.
     */
    limit?: number
  }

  /**
   * CafeCouponHistory updateManyAndReturn
   */
  export type CafeCouponHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * The data used to update CafeCouponHistories.
     */
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponHistories to update
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * Limit how many CafeCouponHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCouponHistory upsert
   */
  export type CafeCouponHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeCouponHistory to update in case it exists.
     */
    where: CafeCouponHistoryWhereUniqueInput
    /**
     * In case the CafeCouponHistory found by the `where` argument doesn't exist, create a new CafeCouponHistory with this data.
     */
    create: XOR<CafeCouponHistoryCreateInput, CafeCouponHistoryUncheckedCreateInput>
    /**
     * In case the CafeCouponHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeCouponHistoryUpdateInput, CafeCouponHistoryUncheckedUpdateInput>
  }

  /**
   * CafeCouponHistory delete
   */
  export type CafeCouponHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
    /**
     * Filter which CafeCouponHistory to delete.
     */
    where: CafeCouponHistoryWhereUniqueInput
  }

  /**
   * CafeCouponHistory deleteMany
   */
  export type CafeCouponHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponHistories to delete
     */
    where?: CafeCouponHistoryWhereInput
    /**
     * Limit how many CafeCouponHistories to delete.
     */
    limit?: number
  }

  /**
   * CafeCouponHistory without action
   */
  export type CafeCouponHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponHistory
     */
    select?: CafeCouponHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponHistory
     */
    omit?: CafeCouponHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponHistoryInclude<ExtArgs> | null
  }


  /**
   * Model CafeCouponQRCode
   */

  export type AggregateCafeCouponQRCode = {
    _count: CafeCouponQRCodeCountAggregateOutputType | null
    _avg: CafeCouponQRCodeAvgAggregateOutputType | null
    _sum: CafeCouponQRCodeSumAggregateOutputType | null
    _min: CafeCouponQRCodeMinAggregateOutputType | null
    _max: CafeCouponQRCodeMaxAggregateOutputType | null
  }

  export type CafeCouponQRCodeAvgAggregateOutputType = {
    cafeCouponId: number | null
    size: number | null
  }

  export type CafeCouponQRCodeSumAggregateOutputType = {
    cafeCouponId: number | null
    size: number | null
  }

  export type CafeCouponQRCodeMinAggregateOutputType = {
    serialNumber: string | null
    createdAt: Date | null
    isDisable: boolean | null
    cafeCouponId: number | null
    size: number | null
    base64Data: string | null
  }

  export type CafeCouponQRCodeMaxAggregateOutputType = {
    serialNumber: string | null
    createdAt: Date | null
    isDisable: boolean | null
    cafeCouponId: number | null
    size: number | null
    base64Data: string | null
  }

  export type CafeCouponQRCodeCountAggregateOutputType = {
    serialNumber: number
    createdAt: number
    isDisable: number
    cafeCouponId: number
    size: number
    base64Data: number
    _all: number
  }


  export type CafeCouponQRCodeAvgAggregateInputType = {
    cafeCouponId?: true
    size?: true
  }

  export type CafeCouponQRCodeSumAggregateInputType = {
    cafeCouponId?: true
    size?: true
  }

  export type CafeCouponQRCodeMinAggregateInputType = {
    serialNumber?: true
    createdAt?: true
    isDisable?: true
    cafeCouponId?: true
    size?: true
    base64Data?: true
  }

  export type CafeCouponQRCodeMaxAggregateInputType = {
    serialNumber?: true
    createdAt?: true
    isDisable?: true
    cafeCouponId?: true
    size?: true
    base64Data?: true
  }

  export type CafeCouponQRCodeCountAggregateInputType = {
    serialNumber?: true
    createdAt?: true
    isDisable?: true
    cafeCouponId?: true
    size?: true
    base64Data?: true
    _all?: true
  }

  export type CafeCouponQRCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponQRCode to aggregate.
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     */
    orderBy?: CafeCouponQRCodeOrderByWithRelationInput | CafeCouponQRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeCouponQRCodes
    **/
    _count?: true | CafeCouponQRCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeCouponQRCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeCouponQRCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeCouponQRCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeCouponQRCodeMaxAggregateInputType
  }

  export type GetCafeCouponQRCodeAggregateType<T extends CafeCouponQRCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeCouponQRCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeCouponQRCode[P]>
      : GetScalarType<T[P], AggregateCafeCouponQRCode[P]>
  }




  export type CafeCouponQRCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeCouponQRCodeWhereInput
    orderBy?: CafeCouponQRCodeOrderByWithAggregationInput | CafeCouponQRCodeOrderByWithAggregationInput[]
    by: CafeCouponQRCodeScalarFieldEnum[] | CafeCouponQRCodeScalarFieldEnum
    having?: CafeCouponQRCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCouponQRCodeCountAggregateInputType | true
    _avg?: CafeCouponQRCodeAvgAggregateInputType
    _sum?: CafeCouponQRCodeSumAggregateInputType
    _min?: CafeCouponQRCodeMinAggregateInputType
    _max?: CafeCouponQRCodeMaxAggregateInputType
  }

  export type CafeCouponQRCodeGroupByOutputType = {
    serialNumber: string
    createdAt: Date
    isDisable: boolean
    cafeCouponId: number | null
    size: number
    base64Data: string
    _count: CafeCouponQRCodeCountAggregateOutputType | null
    _avg: CafeCouponQRCodeAvgAggregateOutputType | null
    _sum: CafeCouponQRCodeSumAggregateOutputType | null
    _min: CafeCouponQRCodeMinAggregateOutputType | null
    _max: CafeCouponQRCodeMaxAggregateOutputType | null
  }

  type GetCafeCouponQRCodeGroupByPayload<T extends CafeCouponQRCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeCouponQRCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeCouponQRCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeCouponQRCodeGroupByOutputType[P]>
            : GetScalarType<T[P], CafeCouponQRCodeGroupByOutputType[P]>
        }
      >
    >


  export type CafeCouponQRCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serialNumber?: boolean
    createdAt?: boolean
    isDisable?: boolean
    cafeCouponId?: boolean
    size?: boolean
    base64Data?: boolean
    CafeCoupon?: boolean | CafeCouponQRCode$CafeCouponArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponQRCode"]>

  export type CafeCouponQRCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serialNumber?: boolean
    createdAt?: boolean
    isDisable?: boolean
    cafeCouponId?: boolean
    size?: boolean
    base64Data?: boolean
    CafeCoupon?: boolean | CafeCouponQRCode$CafeCouponArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponQRCode"]>

  export type CafeCouponQRCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serialNumber?: boolean
    createdAt?: boolean
    isDisable?: boolean
    cafeCouponId?: boolean
    size?: boolean
    base64Data?: boolean
    CafeCoupon?: boolean | CafeCouponQRCode$CafeCouponArgs<ExtArgs>
  }, ExtArgs["result"]["cafeCouponQRCode"]>

  export type CafeCouponQRCodeSelectScalar = {
    serialNumber?: boolean
    createdAt?: boolean
    isDisable?: boolean
    cafeCouponId?: boolean
    size?: boolean
    base64Data?: boolean
  }

  export type CafeCouponQRCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"serialNumber" | "createdAt" | "isDisable" | "cafeCouponId" | "size" | "base64Data", ExtArgs["result"]["cafeCouponQRCode"]>
  export type CafeCouponQRCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupon?: boolean | CafeCouponQRCode$CafeCouponArgs<ExtArgs>
  }
  export type CafeCouponQRCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupon?: boolean | CafeCouponQRCode$CafeCouponArgs<ExtArgs>
  }
  export type CafeCouponQRCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeCoupon?: boolean | CafeCouponQRCode$CafeCouponArgs<ExtArgs>
  }

  export type $CafeCouponQRCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeCouponQRCode"
    objects: {
      CafeCoupon: Prisma.$CafeCouponPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      serialNumber: string
      createdAt: Date
      isDisable: boolean
      cafeCouponId: number | null
      size: number
      base64Data: string
    }, ExtArgs["result"]["cafeCouponQRCode"]>
    composites: {}
  }

  type CafeCouponQRCodeGetPayload<S extends boolean | null | undefined | CafeCouponQRCodeDefaultArgs> = $Result.GetResult<Prisma.$CafeCouponQRCodePayload, S>

  type CafeCouponQRCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeCouponQRCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeCouponQRCodeCountAggregateInputType | true
    }

  export interface CafeCouponQRCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeCouponQRCode'], meta: { name: 'CafeCouponQRCode' } }
    /**
     * Find zero or one CafeCouponQRCode that matches the filter.
     * @param {CafeCouponQRCodeFindUniqueArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeCouponQRCodeFindUniqueArgs>(args: SelectSubset<T, CafeCouponQRCodeFindUniqueArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeCouponQRCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeCouponQRCodeFindUniqueOrThrowArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeCouponQRCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeCouponQRCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponQRCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeFindFirstArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeCouponQRCodeFindFirstArgs>(args?: SelectSubset<T, CafeCouponQRCodeFindFirstArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeCouponQRCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeFindFirstOrThrowArgs} args - Arguments to find a CafeCouponQRCode
     * @example
     * // Get one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeCouponQRCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeCouponQRCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeCouponQRCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeCouponQRCodes
     * const cafeCouponQRCodes = await prisma.cafeCouponQRCode.findMany()
     * 
     * // Get first 10 CafeCouponQRCodes
     * const cafeCouponQRCodes = await prisma.cafeCouponQRCode.findMany({ take: 10 })
     * 
     * // Only select the `serialNumber`
     * const cafeCouponQRCodeWithSerialNumberOnly = await prisma.cafeCouponQRCode.findMany({ select: { serialNumber: true } })
     * 
     */
    findMany<T extends CafeCouponQRCodeFindManyArgs>(args?: SelectSubset<T, CafeCouponQRCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeCouponQRCode.
     * @param {CafeCouponQRCodeCreateArgs} args - Arguments to create a CafeCouponQRCode.
     * @example
     * // Create one CafeCouponQRCode
     * const CafeCouponQRCode = await prisma.cafeCouponQRCode.create({
     *   data: {
     *     // ... data to create a CafeCouponQRCode
     *   }
     * })
     * 
     */
    create<T extends CafeCouponQRCodeCreateArgs>(args: SelectSubset<T, CafeCouponQRCodeCreateArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeCouponQRCodes.
     * @param {CafeCouponQRCodeCreateManyArgs} args - Arguments to create many CafeCouponQRCodes.
     * @example
     * // Create many CafeCouponQRCodes
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeCouponQRCodeCreateManyArgs>(args?: SelectSubset<T, CafeCouponQRCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeCouponQRCodes and returns the data saved in the database.
     * @param {CafeCouponQRCodeCreateManyAndReturnArgs} args - Arguments to create many CafeCouponQRCodes.
     * @example
     * // Create many CafeCouponQRCodes
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeCouponQRCodes and only return the `serialNumber`
     * const cafeCouponQRCodeWithSerialNumberOnly = await prisma.cafeCouponQRCode.createManyAndReturn({
     *   select: { serialNumber: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeCouponQRCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeCouponQRCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeCouponQRCode.
     * @param {CafeCouponQRCodeDeleteArgs} args - Arguments to delete one CafeCouponQRCode.
     * @example
     * // Delete one CafeCouponQRCode
     * const CafeCouponQRCode = await prisma.cafeCouponQRCode.delete({
     *   where: {
     *     // ... filter to delete one CafeCouponQRCode
     *   }
     * })
     * 
     */
    delete<T extends CafeCouponQRCodeDeleteArgs>(args: SelectSubset<T, CafeCouponQRCodeDeleteArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeCouponQRCode.
     * @param {CafeCouponQRCodeUpdateArgs} args - Arguments to update one CafeCouponQRCode.
     * @example
     * // Update one CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeCouponQRCodeUpdateArgs>(args: SelectSubset<T, CafeCouponQRCodeUpdateArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeCouponQRCodes.
     * @param {CafeCouponQRCodeDeleteManyArgs} args - Arguments to filter CafeCouponQRCodes to delete.
     * @example
     * // Delete a few CafeCouponQRCodes
     * const { count } = await prisma.cafeCouponQRCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeCouponQRCodeDeleteManyArgs>(args?: SelectSubset<T, CafeCouponQRCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponQRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeCouponQRCodes
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeCouponQRCodeUpdateManyArgs>(args: SelectSubset<T, CafeCouponQRCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeCouponQRCodes and returns the data updated in the database.
     * @param {CafeCouponQRCodeUpdateManyAndReturnArgs} args - Arguments to update many CafeCouponQRCodes.
     * @example
     * // Update many CafeCouponQRCodes
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeCouponQRCodes and only return the `serialNumber`
     * const cafeCouponQRCodeWithSerialNumberOnly = await prisma.cafeCouponQRCode.updateManyAndReturn({
     *   select: { serialNumber: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeCouponQRCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeCouponQRCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeCouponQRCode.
     * @param {CafeCouponQRCodeUpsertArgs} args - Arguments to update or create a CafeCouponQRCode.
     * @example
     * // Update or create a CafeCouponQRCode
     * const cafeCouponQRCode = await prisma.cafeCouponQRCode.upsert({
     *   create: {
     *     // ... data to create a CafeCouponQRCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeCouponQRCode we want to update
     *   }
     * })
     */
    upsert<T extends CafeCouponQRCodeUpsertArgs>(args: SelectSubset<T, CafeCouponQRCodeUpsertArgs<ExtArgs>>): Prisma__CafeCouponQRCodeClient<$Result.GetResult<Prisma.$CafeCouponQRCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeCouponQRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeCountArgs} args - Arguments to filter CafeCouponQRCodes to count.
     * @example
     * // Count the number of CafeCouponQRCodes
     * const count = await prisma.cafeCouponQRCode.count({
     *   where: {
     *     // ... the filter for the CafeCouponQRCodes we want to count
     *   }
     * })
    **/
    count<T extends CafeCouponQRCodeCountArgs>(
      args?: Subset<T, CafeCouponQRCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCouponQRCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeCouponQRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeCouponQRCodeAggregateArgs>(args: Subset<T, CafeCouponQRCodeAggregateArgs>): Prisma.PrismaPromise<GetCafeCouponQRCodeAggregateType<T>>

    /**
     * Group by CafeCouponQRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCouponQRCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeCouponQRCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeCouponQRCodeGroupByArgs['orderBy'] }
        : { orderBy?: CafeCouponQRCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeCouponQRCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeCouponQRCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeCouponQRCode model
   */
  readonly fields: CafeCouponQRCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeCouponQRCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeCouponQRCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeCoupon<T extends CafeCouponQRCode$CafeCouponArgs<ExtArgs> = {}>(args?: Subset<T, CafeCouponQRCode$CafeCouponArgs<ExtArgs>>): Prisma__CafeCouponClient<$Result.GetResult<Prisma.$CafeCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeCouponQRCode model
   */
  interface CafeCouponQRCodeFieldRefs {
    readonly serialNumber: FieldRef<"CafeCouponQRCode", 'String'>
    readonly createdAt: FieldRef<"CafeCouponQRCode", 'DateTime'>
    readonly isDisable: FieldRef<"CafeCouponQRCode", 'Boolean'>
    readonly cafeCouponId: FieldRef<"CafeCouponQRCode", 'Int'>
    readonly size: FieldRef<"CafeCouponQRCode", 'Int'>
    readonly base64Data: FieldRef<"CafeCouponQRCode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CafeCouponQRCode findUnique
   */
  export type CafeCouponQRCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     */
    where: CafeCouponQRCodeWhereUniqueInput
  }

  /**
   * CafeCouponQRCode findUniqueOrThrow
   */
  export type CafeCouponQRCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     */
    where: CafeCouponQRCodeWhereUniqueInput
  }

  /**
   * CafeCouponQRCode findFirst
   */
  export type CafeCouponQRCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     */
    orderBy?: CafeCouponQRCodeOrderByWithRelationInput | CafeCouponQRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponQRCodes.
     */
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponQRCodes.
     */
    distinct?: CafeCouponQRCodeScalarFieldEnum | CafeCouponQRCodeScalarFieldEnum[]
  }

  /**
   * CafeCouponQRCode findFirstOrThrow
   */
  export type CafeCouponQRCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponQRCode to fetch.
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     */
    orderBy?: CafeCouponQRCodeOrderByWithRelationInput | CafeCouponQRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeCouponQRCodes.
     */
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeCouponQRCodes.
     */
    distinct?: CafeCouponQRCodeScalarFieldEnum | CafeCouponQRCodeScalarFieldEnum[]
  }

  /**
   * CafeCouponQRCode findMany
   */
  export type CafeCouponQRCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * Filter, which CafeCouponQRCodes to fetch.
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeCouponQRCodes to fetch.
     */
    orderBy?: CafeCouponQRCodeOrderByWithRelationInput | CafeCouponQRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeCouponQRCodes.
     */
    cursor?: CafeCouponQRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeCouponQRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeCouponQRCodes.
     */
    skip?: number
    distinct?: CafeCouponQRCodeScalarFieldEnum | CafeCouponQRCodeScalarFieldEnum[]
  }

  /**
   * CafeCouponQRCode create
   */
  export type CafeCouponQRCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeCouponQRCode.
     */
    data: XOR<CafeCouponQRCodeCreateInput, CafeCouponQRCodeUncheckedCreateInput>
  }

  /**
   * CafeCouponQRCode createMany
   */
  export type CafeCouponQRCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeCouponQRCodes.
     */
    data: CafeCouponQRCodeCreateManyInput | CafeCouponQRCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeCouponQRCode createManyAndReturn
   */
  export type CafeCouponQRCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * The data used to create many CafeCouponQRCodes.
     */
    data: CafeCouponQRCodeCreateManyInput | CafeCouponQRCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCouponQRCode update
   */
  export type CafeCouponQRCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeCouponQRCode.
     */
    data: XOR<CafeCouponQRCodeUpdateInput, CafeCouponQRCodeUncheckedUpdateInput>
    /**
     * Choose, which CafeCouponQRCode to update.
     */
    where: CafeCouponQRCodeWhereUniqueInput
  }

  /**
   * CafeCouponQRCode updateMany
   */
  export type CafeCouponQRCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeCouponQRCodes.
     */
    data: XOR<CafeCouponQRCodeUpdateManyMutationInput, CafeCouponQRCodeUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponQRCodes to update
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * Limit how many CafeCouponQRCodes to update.
     */
    limit?: number
  }

  /**
   * CafeCouponQRCode updateManyAndReturn
   */
  export type CafeCouponQRCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * The data used to update CafeCouponQRCodes.
     */
    data: XOR<CafeCouponQRCodeUpdateManyMutationInput, CafeCouponQRCodeUncheckedUpdateManyInput>
    /**
     * Filter which CafeCouponQRCodes to update
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * Limit how many CafeCouponQRCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeCouponQRCode upsert
   */
  export type CafeCouponQRCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeCouponQRCode to update in case it exists.
     */
    where: CafeCouponQRCodeWhereUniqueInput
    /**
     * In case the CafeCouponQRCode found by the `where` argument doesn't exist, create a new CafeCouponQRCode with this data.
     */
    create: XOR<CafeCouponQRCodeCreateInput, CafeCouponQRCodeUncheckedCreateInput>
    /**
     * In case the CafeCouponQRCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeCouponQRCodeUpdateInput, CafeCouponQRCodeUncheckedUpdateInput>
  }

  /**
   * CafeCouponQRCode delete
   */
  export type CafeCouponQRCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
    /**
     * Filter which CafeCouponQRCode to delete.
     */
    where: CafeCouponQRCodeWhereUniqueInput
  }

  /**
   * CafeCouponQRCode deleteMany
   */
  export type CafeCouponQRCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeCouponQRCodes to delete
     */
    where?: CafeCouponQRCodeWhereInput
    /**
     * Limit how many CafeCouponQRCodes to delete.
     */
    limit?: number
  }

  /**
   * CafeCouponQRCode.CafeCoupon
   */
  export type CafeCouponQRCode$CafeCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCoupon
     */
    select?: CafeCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCoupon
     */
    omit?: CafeCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponInclude<ExtArgs> | null
    where?: CafeCouponWhereInput
  }

  /**
   * CafeCouponQRCode without action
   */
  export type CafeCouponQRCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCouponQRCode
     */
    select?: CafeCouponQRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeCouponQRCode
     */
    omit?: CafeCouponQRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeCouponQRCodeInclude<ExtArgs> | null
  }


  /**
   * Model MetaViewerInfo
   */

  export type AggregateMetaViewerInfo = {
    _count: MetaViewerInfoCountAggregateOutputType | null
    _avg: MetaViewerInfoAvgAggregateOutputType | null
    _sum: MetaViewerInfoSumAggregateOutputType | null
    _min: MetaViewerInfoMinAggregateOutputType | null
    _max: MetaViewerInfoMaxAggregateOutputType | null
  }

  export type MetaViewerInfoAvgAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoSumAggregateOutputType = {
    id: number | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    code: string | null
    isDisable: boolean | null
    cafeInfoId: number | null
  }

  export type MetaViewerInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    code: number
    isDisable: number
    worldData: number
    cafeInfoId: number
    _all: number
  }


  export type MetaViewerInfoAvgAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoSumAggregateInputType = {
    id?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    isDisable?: true
    cafeInfoId?: true
  }

  export type MetaViewerInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    code?: true
    isDisable?: true
    worldData?: true
    cafeInfoId?: true
    _all?: true
  }

  export type MetaViewerInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaViewerInfo to aggregate.
     */
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     */
    orderBy?: MetaViewerInfoOrderByWithRelationInput | MetaViewerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaViewerInfos
    **/
    _count?: true | MetaViewerInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaViewerInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaViewerInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaViewerInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaViewerInfoMaxAggregateInputType
  }

  export type GetMetaViewerInfoAggregateType<T extends MetaViewerInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaViewerInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaViewerInfo[P]>
      : GetScalarType<T[P], AggregateMetaViewerInfo[P]>
  }




  export type MetaViewerInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerInfoWhereInput
    orderBy?: MetaViewerInfoOrderByWithAggregationInput | MetaViewerInfoOrderByWithAggregationInput[]
    by: MetaViewerInfoScalarFieldEnum[] | MetaViewerInfoScalarFieldEnum
    having?: MetaViewerInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaViewerInfoCountAggregateInputType | true
    _avg?: MetaViewerInfoAvgAggregateInputType
    _sum?: MetaViewerInfoSumAggregateInputType
    _min?: MetaViewerInfoMinAggregateInputType
    _max?: MetaViewerInfoMaxAggregateInputType
  }

  export type MetaViewerInfoGroupByOutputType = {
    id: number
    createdAt: Date
    code: string
    isDisable: boolean
    worldData: JsonValue
    cafeInfoId: number
    _count: MetaViewerInfoCountAggregateOutputType | null
    _avg: MetaViewerInfoAvgAggregateOutputType | null
    _sum: MetaViewerInfoSumAggregateOutputType | null
    _min: MetaViewerInfoMinAggregateOutputType | null
    _max: MetaViewerInfoMaxAggregateOutputType | null
  }

  type GetMetaViewerInfoGroupByPayload<T extends MetaViewerInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetaViewerInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaViewerInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaViewerInfoGroupByOutputType[P]>
            : GetScalarType<T[P], MetaViewerInfoGroupByOutputType[P]>
        }
      >
    >


  export type MetaViewerInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    code?: boolean
    isDisable?: boolean
    worldData?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
    MetaViewerMaps?: boolean | MetaViewerInfo$MetaViewerMapsArgs<ExtArgs>
    ActiveMaps?: boolean | MetaViewerInfo$ActiveMapsArgs<ExtArgs>
    _count?: boolean | MetaViewerInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerInfo"]>

  export type MetaViewerInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    code?: boolean
    isDisable?: boolean
    worldData?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerInfo"]>

  export type MetaViewerInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    code?: boolean
    isDisable?: boolean
    worldData?: boolean
    cafeInfoId?: boolean
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerInfo"]>

  export type MetaViewerInfoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    code?: boolean
    isDisable?: boolean
    worldData?: boolean
    cafeInfoId?: boolean
  }

  export type MetaViewerInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "code" | "isDisable" | "worldData" | "cafeInfoId", ExtArgs["result"]["metaViewerInfo"]>
  export type MetaViewerInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
    MetaViewerMaps?: boolean | MetaViewerInfo$MetaViewerMapsArgs<ExtArgs>
    ActiveMaps?: boolean | MetaViewerInfo$ActiveMapsArgs<ExtArgs>
    _count?: boolean | MetaViewerInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MetaViewerInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }
  export type MetaViewerInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CafeInfo?: boolean | CafeInfoDefaultArgs<ExtArgs>
  }

  export type $MetaViewerInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MetaViewerInfo"
    objects: {
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs>
      MetaViewerMaps: Prisma.$MetaViewerMapPayload<ExtArgs>[]
      ActiveMaps: Prisma.$MetaViewerActiveMapPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      code: string
      isDisable: boolean
      worldData: Prisma.JsonValue
      cafeInfoId: number
    }, ExtArgs["result"]["metaViewerInfo"]>
    composites: {}
  }

  type MetaViewerInfoGetPayload<S extends boolean | null | undefined | MetaViewerInfoDefaultArgs> = $Result.GetResult<Prisma.$MetaViewerInfoPayload, S>

  type MetaViewerInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetaViewerInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetaViewerInfoCountAggregateInputType | true
    }

  export interface MetaViewerInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MetaViewerInfo'], meta: { name: 'MetaViewerInfo' } }
    /**
     * Find zero or one MetaViewerInfo that matches the filter.
     * @param {MetaViewerInfoFindUniqueArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetaViewerInfoFindUniqueArgs>(args: SelectSubset<T, MetaViewerInfoFindUniqueArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetaViewerInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetaViewerInfoFindUniqueOrThrowArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetaViewerInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, MetaViewerInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaViewerInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoFindFirstArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetaViewerInfoFindFirstArgs>(args?: SelectSubset<T, MetaViewerInfoFindFirstArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaViewerInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoFindFirstOrThrowArgs} args - Arguments to find a MetaViewerInfo
     * @example
     * // Get one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetaViewerInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, MetaViewerInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetaViewerInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaViewerInfos
     * const metaViewerInfos = await prisma.metaViewerInfo.findMany()
     * 
     * // Get first 10 MetaViewerInfos
     * const metaViewerInfos = await prisma.metaViewerInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaViewerInfoWithIdOnly = await prisma.metaViewerInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetaViewerInfoFindManyArgs>(args?: SelectSubset<T, MetaViewerInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetaViewerInfo.
     * @param {MetaViewerInfoCreateArgs} args - Arguments to create a MetaViewerInfo.
     * @example
     * // Create one MetaViewerInfo
     * const MetaViewerInfo = await prisma.metaViewerInfo.create({
     *   data: {
     *     // ... data to create a MetaViewerInfo
     *   }
     * })
     * 
     */
    create<T extends MetaViewerInfoCreateArgs>(args: SelectSubset<T, MetaViewerInfoCreateArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetaViewerInfos.
     * @param {MetaViewerInfoCreateManyArgs} args - Arguments to create many MetaViewerInfos.
     * @example
     * // Create many MetaViewerInfos
     * const metaViewerInfo = await prisma.metaViewerInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetaViewerInfoCreateManyArgs>(args?: SelectSubset<T, MetaViewerInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MetaViewerInfos and returns the data saved in the database.
     * @param {MetaViewerInfoCreateManyAndReturnArgs} args - Arguments to create many MetaViewerInfos.
     * @example
     * // Create many MetaViewerInfos
     * const metaViewerInfo = await prisma.metaViewerInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MetaViewerInfos and only return the `id`
     * const metaViewerInfoWithIdOnly = await prisma.metaViewerInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetaViewerInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, MetaViewerInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MetaViewerInfo.
     * @param {MetaViewerInfoDeleteArgs} args - Arguments to delete one MetaViewerInfo.
     * @example
     * // Delete one MetaViewerInfo
     * const MetaViewerInfo = await prisma.metaViewerInfo.delete({
     *   where: {
     *     // ... filter to delete one MetaViewerInfo
     *   }
     * })
     * 
     */
    delete<T extends MetaViewerInfoDeleteArgs>(args: SelectSubset<T, MetaViewerInfoDeleteArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetaViewerInfo.
     * @param {MetaViewerInfoUpdateArgs} args - Arguments to update one MetaViewerInfo.
     * @example
     * // Update one MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetaViewerInfoUpdateArgs>(args: SelectSubset<T, MetaViewerInfoUpdateArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetaViewerInfos.
     * @param {MetaViewerInfoDeleteManyArgs} args - Arguments to filter MetaViewerInfos to delete.
     * @example
     * // Delete a few MetaViewerInfos
     * const { count } = await prisma.metaViewerInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetaViewerInfoDeleteManyArgs>(args?: SelectSubset<T, MetaViewerInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaViewerInfos
     * const metaViewerInfo = await prisma.metaViewerInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetaViewerInfoUpdateManyArgs>(args: SelectSubset<T, MetaViewerInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerInfos and returns the data updated in the database.
     * @param {MetaViewerInfoUpdateManyAndReturnArgs} args - Arguments to update many MetaViewerInfos.
     * @example
     * // Update many MetaViewerInfos
     * const metaViewerInfo = await prisma.metaViewerInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MetaViewerInfos and only return the `id`
     * const metaViewerInfoWithIdOnly = await prisma.metaViewerInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetaViewerInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, MetaViewerInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MetaViewerInfo.
     * @param {MetaViewerInfoUpsertArgs} args - Arguments to update or create a MetaViewerInfo.
     * @example
     * // Update or create a MetaViewerInfo
     * const metaViewerInfo = await prisma.metaViewerInfo.upsert({
     *   create: {
     *     // ... data to create a MetaViewerInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaViewerInfo we want to update
     *   }
     * })
     */
    upsert<T extends MetaViewerInfoUpsertArgs>(args: SelectSubset<T, MetaViewerInfoUpsertArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetaViewerInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoCountArgs} args - Arguments to filter MetaViewerInfos to count.
     * @example
     * // Count the number of MetaViewerInfos
     * const count = await prisma.metaViewerInfo.count({
     *   where: {
     *     // ... the filter for the MetaViewerInfos we want to count
     *   }
     * })
    **/
    count<T extends MetaViewerInfoCountArgs>(
      args?: Subset<T, MetaViewerInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaViewerInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaViewerInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaViewerInfoAggregateArgs>(args: Subset<T, MetaViewerInfoAggregateArgs>): Prisma.PrismaPromise<GetMetaViewerInfoAggregateType<T>>

    /**
     * Group by MetaViewerInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaViewerInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaViewerInfoGroupByArgs['orderBy'] }
        : { orderBy?: MetaViewerInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaViewerInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaViewerInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MetaViewerInfo model
   */
  readonly fields: MetaViewerInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaViewerInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetaViewerInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CafeInfo<T extends CafeInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeInfoDefaultArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MetaViewerMaps<T extends MetaViewerInfo$MetaViewerMapsArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerInfo$MetaViewerMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ActiveMaps<T extends MetaViewerInfo$ActiveMapsArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerInfo$ActiveMapsArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MetaViewerInfo model
   */
  interface MetaViewerInfoFieldRefs {
    readonly id: FieldRef<"MetaViewerInfo", 'Int'>
    readonly createdAt: FieldRef<"MetaViewerInfo", 'DateTime'>
    readonly code: FieldRef<"MetaViewerInfo", 'String'>
    readonly isDisable: FieldRef<"MetaViewerInfo", 'Boolean'>
    readonly worldData: FieldRef<"MetaViewerInfo", 'Json'>
    readonly cafeInfoId: FieldRef<"MetaViewerInfo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MetaViewerInfo findUnique
   */
  export type MetaViewerInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     */
    where: MetaViewerInfoWhereUniqueInput
  }

  /**
   * MetaViewerInfo findUniqueOrThrow
   */
  export type MetaViewerInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     */
    where: MetaViewerInfoWhereUniqueInput
  }

  /**
   * MetaViewerInfo findFirst
   */
  export type MetaViewerInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     */
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     */
    orderBy?: MetaViewerInfoOrderByWithRelationInput | MetaViewerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerInfos.
     */
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerInfos.
     */
    distinct?: MetaViewerInfoScalarFieldEnum | MetaViewerInfoScalarFieldEnum[]
  }

  /**
   * MetaViewerInfo findFirstOrThrow
   */
  export type MetaViewerInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerInfo to fetch.
     */
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     */
    orderBy?: MetaViewerInfoOrderByWithRelationInput | MetaViewerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerInfos.
     */
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerInfos.
     */
    distinct?: MetaViewerInfoScalarFieldEnum | MetaViewerInfoScalarFieldEnum[]
  }

  /**
   * MetaViewerInfo findMany
   */
  export type MetaViewerInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerInfos to fetch.
     */
    where?: MetaViewerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerInfos to fetch.
     */
    orderBy?: MetaViewerInfoOrderByWithRelationInput | MetaViewerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaViewerInfos.
     */
    cursor?: MetaViewerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerInfos.
     */
    skip?: number
    distinct?: MetaViewerInfoScalarFieldEnum | MetaViewerInfoScalarFieldEnum[]
  }

  /**
   * MetaViewerInfo create
   */
  export type MetaViewerInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a MetaViewerInfo.
     */
    data: XOR<MetaViewerInfoCreateInput, MetaViewerInfoUncheckedCreateInput>
  }

  /**
   * MetaViewerInfo createMany
   */
  export type MetaViewerInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MetaViewerInfos.
     */
    data: MetaViewerInfoCreateManyInput | MetaViewerInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetaViewerInfo createManyAndReturn
   */
  export type MetaViewerInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * The data used to create many MetaViewerInfos.
     */
    data: MetaViewerInfoCreateManyInput | MetaViewerInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaViewerInfo update
   */
  export type MetaViewerInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a MetaViewerInfo.
     */
    data: XOR<MetaViewerInfoUpdateInput, MetaViewerInfoUncheckedUpdateInput>
    /**
     * Choose, which MetaViewerInfo to update.
     */
    where: MetaViewerInfoWhereUniqueInput
  }

  /**
   * MetaViewerInfo updateMany
   */
  export type MetaViewerInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MetaViewerInfos.
     */
    data: XOR<MetaViewerInfoUpdateManyMutationInput, MetaViewerInfoUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerInfos to update
     */
    where?: MetaViewerInfoWhereInput
    /**
     * Limit how many MetaViewerInfos to update.
     */
    limit?: number
  }

  /**
   * MetaViewerInfo updateManyAndReturn
   */
  export type MetaViewerInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * The data used to update MetaViewerInfos.
     */
    data: XOR<MetaViewerInfoUpdateManyMutationInput, MetaViewerInfoUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerInfos to update
     */
    where?: MetaViewerInfoWhereInput
    /**
     * Limit how many MetaViewerInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaViewerInfo upsert
   */
  export type MetaViewerInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the MetaViewerInfo to update in case it exists.
     */
    where: MetaViewerInfoWhereUniqueInput
    /**
     * In case the MetaViewerInfo found by the `where` argument doesn't exist, create a new MetaViewerInfo with this data.
     */
    create: XOR<MetaViewerInfoCreateInput, MetaViewerInfoUncheckedCreateInput>
    /**
     * In case the MetaViewerInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetaViewerInfoUpdateInput, MetaViewerInfoUncheckedUpdateInput>
  }

  /**
   * MetaViewerInfo delete
   */
  export type MetaViewerInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
    /**
     * Filter which MetaViewerInfo to delete.
     */
    where: MetaViewerInfoWhereUniqueInput
  }

  /**
   * MetaViewerInfo deleteMany
   */
  export type MetaViewerInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaViewerInfos to delete
     */
    where?: MetaViewerInfoWhereInput
    /**
     * Limit how many MetaViewerInfos to delete.
     */
    limit?: number
  }

  /**
   * MetaViewerInfo.MetaViewerMaps
   */
  export type MetaViewerInfo$MetaViewerMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    where?: MetaViewerMapWhereInput
    orderBy?: MetaViewerMapOrderByWithRelationInput | MetaViewerMapOrderByWithRelationInput[]
    cursor?: MetaViewerMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetaViewerMapScalarFieldEnum | MetaViewerMapScalarFieldEnum[]
  }

  /**
   * MetaViewerInfo.ActiveMaps
   */
  export type MetaViewerInfo$ActiveMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    where?: MetaViewerActiveMapWhereInput
  }

  /**
   * MetaViewerInfo without action
   */
  export type MetaViewerInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerInfo
     */
    select?: MetaViewerInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerInfo
     */
    omit?: MetaViewerInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerInfoInclude<ExtArgs> | null
  }


  /**
   * Model MetaViewerMap
   */

  export type AggregateMetaViewerMap = {
    _count: MetaViewerMapCountAggregateOutputType | null
    _avg: MetaViewerMapAvgAggregateOutputType | null
    _sum: MetaViewerMapSumAggregateOutputType | null
    _min: MetaViewerMapMinAggregateOutputType | null
    _max: MetaViewerMapMaxAggregateOutputType | null
  }

  export type MetaViewerMapAvgAggregateOutputType = {
    id: number | null
    version: number | null
    size: number | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapSumAggregateOutputType = {
    id: number | null
    version: number | null
    size: number | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.MetaMapType | null
    version: number | null
    url: string | null
    size: number | null
    contentKey: string | null
    isDraco: boolean | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.MetaMapType | null
    version: number | null
    url: string | null
    size: number | null
    contentKey: string | null
    isDraco: boolean | null
    metaViewerInfoId: number | null
  }

  export type MetaViewerMapCountAggregateOutputType = {
    id: number
    createdAt: number
    type: number
    version: number
    url: number
    size: number
    contentKey: number
    isDraco: number
    metaViewerInfoId: number
    _all: number
  }


  export type MetaViewerMapAvgAggregateInputType = {
    id?: true
    version?: true
    size?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapSumAggregateInputType = {
    id?: true
    version?: true
    size?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapMinAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    version?: true
    url?: true
    size?: true
    contentKey?: true
    isDraco?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapMaxAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    version?: true
    url?: true
    size?: true
    contentKey?: true
    isDraco?: true
    metaViewerInfoId?: true
  }

  export type MetaViewerMapCountAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    version?: true
    url?: true
    size?: true
    contentKey?: true
    isDraco?: true
    metaViewerInfoId?: true
    _all?: true
  }

  export type MetaViewerMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaViewerMap to aggregate.
     */
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     */
    orderBy?: MetaViewerMapOrderByWithRelationInput | MetaViewerMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaViewerMaps
    **/
    _count?: true | MetaViewerMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaViewerMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaViewerMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaViewerMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaViewerMapMaxAggregateInputType
  }

  export type GetMetaViewerMapAggregateType<T extends MetaViewerMapAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaViewerMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaViewerMap[P]>
      : GetScalarType<T[P], AggregateMetaViewerMap[P]>
  }




  export type MetaViewerMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerMapWhereInput
    orderBy?: MetaViewerMapOrderByWithAggregationInput | MetaViewerMapOrderByWithAggregationInput[]
    by: MetaViewerMapScalarFieldEnum[] | MetaViewerMapScalarFieldEnum
    having?: MetaViewerMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaViewerMapCountAggregateInputType | true
    _avg?: MetaViewerMapAvgAggregateInputType
    _sum?: MetaViewerMapSumAggregateInputType
    _min?: MetaViewerMapMinAggregateInputType
    _max?: MetaViewerMapMaxAggregateInputType
  }

  export type MetaViewerMapGroupByOutputType = {
    id: number
    createdAt: Date
    type: $Enums.MetaMapType
    version: number
    url: string
    size: number
    contentKey: string | null
    isDraco: boolean
    metaViewerInfoId: number
    _count: MetaViewerMapCountAggregateOutputType | null
    _avg: MetaViewerMapAvgAggregateOutputType | null
    _sum: MetaViewerMapSumAggregateOutputType | null
    _min: MetaViewerMapMinAggregateOutputType | null
    _max: MetaViewerMapMaxAggregateOutputType | null
  }

  type GetMetaViewerMapGroupByPayload<T extends MetaViewerMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetaViewerMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaViewerMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaViewerMapGroupByOutputType[P]>
            : GetScalarType<T[P], MetaViewerMapGroupByOutputType[P]>
        }
      >
    >


  export type MetaViewerMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    type?: boolean
    version?: boolean
    url?: boolean
    size?: boolean
    contentKey?: boolean
    isDraco?: boolean
    metaViewerInfoId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderFor?: boolean | MetaViewerMap$ActiveRenderForArgs<ExtArgs>
    ActiveColliderFor?: boolean | MetaViewerMap$ActiveColliderForArgs<ExtArgs>
    _count?: boolean | MetaViewerMapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerMap"]>

  export type MetaViewerMapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    type?: boolean
    version?: boolean
    url?: boolean
    size?: boolean
    contentKey?: boolean
    isDraco?: boolean
    metaViewerInfoId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerMap"]>

  export type MetaViewerMapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    type?: boolean
    version?: boolean
    url?: boolean
    size?: boolean
    contentKey?: boolean
    isDraco?: boolean
    metaViewerInfoId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerMap"]>

  export type MetaViewerMapSelectScalar = {
    id?: boolean
    createdAt?: boolean
    type?: boolean
    version?: boolean
    url?: boolean
    size?: boolean
    contentKey?: boolean
    isDraco?: boolean
    metaViewerInfoId?: boolean
  }

  export type MetaViewerMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "type" | "version" | "url" | "size" | "contentKey" | "isDraco" | "metaViewerInfoId", ExtArgs["result"]["metaViewerMap"]>
  export type MetaViewerMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderFor?: boolean | MetaViewerMap$ActiveRenderForArgs<ExtArgs>
    ActiveColliderFor?: boolean | MetaViewerMap$ActiveColliderForArgs<ExtArgs>
    _count?: boolean | MetaViewerMapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MetaViewerMapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
  }
  export type MetaViewerMapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
  }

  export type $MetaViewerMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MetaViewerMap"
    objects: {
      MetaViewerInfo: Prisma.$MetaViewerInfoPayload<ExtArgs>
      ActiveRenderFor: Prisma.$MetaViewerActiveMapPayload<ExtArgs>[]
      ActiveColliderFor: Prisma.$MetaViewerActiveMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      type: $Enums.MetaMapType
      version: number
      url: string
      size: number
      contentKey: string | null
      isDraco: boolean
      metaViewerInfoId: number
    }, ExtArgs["result"]["metaViewerMap"]>
    composites: {}
  }

  type MetaViewerMapGetPayload<S extends boolean | null | undefined | MetaViewerMapDefaultArgs> = $Result.GetResult<Prisma.$MetaViewerMapPayload, S>

  type MetaViewerMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetaViewerMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetaViewerMapCountAggregateInputType | true
    }

  export interface MetaViewerMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MetaViewerMap'], meta: { name: 'MetaViewerMap' } }
    /**
     * Find zero or one MetaViewerMap that matches the filter.
     * @param {MetaViewerMapFindUniqueArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetaViewerMapFindUniqueArgs>(args: SelectSubset<T, MetaViewerMapFindUniqueArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetaViewerMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetaViewerMapFindUniqueOrThrowArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetaViewerMapFindUniqueOrThrowArgs>(args: SelectSubset<T, MetaViewerMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaViewerMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapFindFirstArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetaViewerMapFindFirstArgs>(args?: SelectSubset<T, MetaViewerMapFindFirstArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaViewerMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapFindFirstOrThrowArgs} args - Arguments to find a MetaViewerMap
     * @example
     * // Get one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetaViewerMapFindFirstOrThrowArgs>(args?: SelectSubset<T, MetaViewerMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetaViewerMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaViewerMaps
     * const metaViewerMaps = await prisma.metaViewerMap.findMany()
     * 
     * // Get first 10 MetaViewerMaps
     * const metaViewerMaps = await prisma.metaViewerMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaViewerMapWithIdOnly = await prisma.metaViewerMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetaViewerMapFindManyArgs>(args?: SelectSubset<T, MetaViewerMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetaViewerMap.
     * @param {MetaViewerMapCreateArgs} args - Arguments to create a MetaViewerMap.
     * @example
     * // Create one MetaViewerMap
     * const MetaViewerMap = await prisma.metaViewerMap.create({
     *   data: {
     *     // ... data to create a MetaViewerMap
     *   }
     * })
     * 
     */
    create<T extends MetaViewerMapCreateArgs>(args: SelectSubset<T, MetaViewerMapCreateArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetaViewerMaps.
     * @param {MetaViewerMapCreateManyArgs} args - Arguments to create many MetaViewerMaps.
     * @example
     * // Create many MetaViewerMaps
     * const metaViewerMap = await prisma.metaViewerMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetaViewerMapCreateManyArgs>(args?: SelectSubset<T, MetaViewerMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MetaViewerMaps and returns the data saved in the database.
     * @param {MetaViewerMapCreateManyAndReturnArgs} args - Arguments to create many MetaViewerMaps.
     * @example
     * // Create many MetaViewerMaps
     * const metaViewerMap = await prisma.metaViewerMap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MetaViewerMaps and only return the `id`
     * const metaViewerMapWithIdOnly = await prisma.metaViewerMap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetaViewerMapCreateManyAndReturnArgs>(args?: SelectSubset<T, MetaViewerMapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MetaViewerMap.
     * @param {MetaViewerMapDeleteArgs} args - Arguments to delete one MetaViewerMap.
     * @example
     * // Delete one MetaViewerMap
     * const MetaViewerMap = await prisma.metaViewerMap.delete({
     *   where: {
     *     // ... filter to delete one MetaViewerMap
     *   }
     * })
     * 
     */
    delete<T extends MetaViewerMapDeleteArgs>(args: SelectSubset<T, MetaViewerMapDeleteArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetaViewerMap.
     * @param {MetaViewerMapUpdateArgs} args - Arguments to update one MetaViewerMap.
     * @example
     * // Update one MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetaViewerMapUpdateArgs>(args: SelectSubset<T, MetaViewerMapUpdateArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetaViewerMaps.
     * @param {MetaViewerMapDeleteManyArgs} args - Arguments to filter MetaViewerMaps to delete.
     * @example
     * // Delete a few MetaViewerMaps
     * const { count } = await prisma.metaViewerMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetaViewerMapDeleteManyArgs>(args?: SelectSubset<T, MetaViewerMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaViewerMaps
     * const metaViewerMap = await prisma.metaViewerMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetaViewerMapUpdateManyArgs>(args: SelectSubset<T, MetaViewerMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerMaps and returns the data updated in the database.
     * @param {MetaViewerMapUpdateManyAndReturnArgs} args - Arguments to update many MetaViewerMaps.
     * @example
     * // Update many MetaViewerMaps
     * const metaViewerMap = await prisma.metaViewerMap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MetaViewerMaps and only return the `id`
     * const metaViewerMapWithIdOnly = await prisma.metaViewerMap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetaViewerMapUpdateManyAndReturnArgs>(args: SelectSubset<T, MetaViewerMapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MetaViewerMap.
     * @param {MetaViewerMapUpsertArgs} args - Arguments to update or create a MetaViewerMap.
     * @example
     * // Update or create a MetaViewerMap
     * const metaViewerMap = await prisma.metaViewerMap.upsert({
     *   create: {
     *     // ... data to create a MetaViewerMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaViewerMap we want to update
     *   }
     * })
     */
    upsert<T extends MetaViewerMapUpsertArgs>(args: SelectSubset<T, MetaViewerMapUpsertArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetaViewerMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapCountArgs} args - Arguments to filter MetaViewerMaps to count.
     * @example
     * // Count the number of MetaViewerMaps
     * const count = await prisma.metaViewerMap.count({
     *   where: {
     *     // ... the filter for the MetaViewerMaps we want to count
     *   }
     * })
    **/
    count<T extends MetaViewerMapCountArgs>(
      args?: Subset<T, MetaViewerMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaViewerMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaViewerMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaViewerMapAggregateArgs>(args: Subset<T, MetaViewerMapAggregateArgs>): Prisma.PrismaPromise<GetMetaViewerMapAggregateType<T>>

    /**
     * Group by MetaViewerMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaViewerMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaViewerMapGroupByArgs['orderBy'] }
        : { orderBy?: MetaViewerMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaViewerMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaViewerMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MetaViewerMap model
   */
  readonly fields: MetaViewerMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaViewerMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetaViewerMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MetaViewerInfo<T extends MetaViewerInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerInfoDefaultArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ActiveRenderFor<T extends MetaViewerMap$ActiveRenderForArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerMap$ActiveRenderForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ActiveColliderFor<T extends MetaViewerMap$ActiveColliderForArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerMap$ActiveColliderForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MetaViewerMap model
   */
  interface MetaViewerMapFieldRefs {
    readonly id: FieldRef<"MetaViewerMap", 'Int'>
    readonly createdAt: FieldRef<"MetaViewerMap", 'DateTime'>
    readonly type: FieldRef<"MetaViewerMap", 'MetaMapType'>
    readonly version: FieldRef<"MetaViewerMap", 'Float'>
    readonly url: FieldRef<"MetaViewerMap", 'String'>
    readonly size: FieldRef<"MetaViewerMap", 'Int'>
    readonly contentKey: FieldRef<"MetaViewerMap", 'String'>
    readonly isDraco: FieldRef<"MetaViewerMap", 'Boolean'>
    readonly metaViewerInfoId: FieldRef<"MetaViewerMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MetaViewerMap findUnique
   */
  export type MetaViewerMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerMap to fetch.
     */
    where: MetaViewerMapWhereUniqueInput
  }

  /**
   * MetaViewerMap findUniqueOrThrow
   */
  export type MetaViewerMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerMap to fetch.
     */
    where: MetaViewerMapWhereUniqueInput
  }

  /**
   * MetaViewerMap findFirst
   */
  export type MetaViewerMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerMap to fetch.
     */
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     */
    orderBy?: MetaViewerMapOrderByWithRelationInput | MetaViewerMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerMaps.
     */
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerMaps.
     */
    distinct?: MetaViewerMapScalarFieldEnum | MetaViewerMapScalarFieldEnum[]
  }

  /**
   * MetaViewerMap findFirstOrThrow
   */
  export type MetaViewerMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerMap to fetch.
     */
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     */
    orderBy?: MetaViewerMapOrderByWithRelationInput | MetaViewerMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerMaps.
     */
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerMaps.
     */
    distinct?: MetaViewerMapScalarFieldEnum | MetaViewerMapScalarFieldEnum[]
  }

  /**
   * MetaViewerMap findMany
   */
  export type MetaViewerMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerMaps to fetch.
     */
    where?: MetaViewerMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerMaps to fetch.
     */
    orderBy?: MetaViewerMapOrderByWithRelationInput | MetaViewerMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaViewerMaps.
     */
    cursor?: MetaViewerMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerMaps.
     */
    skip?: number
    distinct?: MetaViewerMapScalarFieldEnum | MetaViewerMapScalarFieldEnum[]
  }

  /**
   * MetaViewerMap create
   */
  export type MetaViewerMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * The data needed to create a MetaViewerMap.
     */
    data: XOR<MetaViewerMapCreateInput, MetaViewerMapUncheckedCreateInput>
  }

  /**
   * MetaViewerMap createMany
   */
  export type MetaViewerMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MetaViewerMaps.
     */
    data: MetaViewerMapCreateManyInput | MetaViewerMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetaViewerMap createManyAndReturn
   */
  export type MetaViewerMapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * The data used to create many MetaViewerMaps.
     */
    data: MetaViewerMapCreateManyInput | MetaViewerMapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaViewerMap update
   */
  export type MetaViewerMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * The data needed to update a MetaViewerMap.
     */
    data: XOR<MetaViewerMapUpdateInput, MetaViewerMapUncheckedUpdateInput>
    /**
     * Choose, which MetaViewerMap to update.
     */
    where: MetaViewerMapWhereUniqueInput
  }

  /**
   * MetaViewerMap updateMany
   */
  export type MetaViewerMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MetaViewerMaps.
     */
    data: XOR<MetaViewerMapUpdateManyMutationInput, MetaViewerMapUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerMaps to update
     */
    where?: MetaViewerMapWhereInput
    /**
     * Limit how many MetaViewerMaps to update.
     */
    limit?: number
  }

  /**
   * MetaViewerMap updateManyAndReturn
   */
  export type MetaViewerMapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * The data used to update MetaViewerMaps.
     */
    data: XOR<MetaViewerMapUpdateManyMutationInput, MetaViewerMapUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerMaps to update
     */
    where?: MetaViewerMapWhereInput
    /**
     * Limit how many MetaViewerMaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaViewerMap upsert
   */
  export type MetaViewerMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * The filter to search for the MetaViewerMap to update in case it exists.
     */
    where: MetaViewerMapWhereUniqueInput
    /**
     * In case the MetaViewerMap found by the `where` argument doesn't exist, create a new MetaViewerMap with this data.
     */
    create: XOR<MetaViewerMapCreateInput, MetaViewerMapUncheckedCreateInput>
    /**
     * In case the MetaViewerMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetaViewerMapUpdateInput, MetaViewerMapUncheckedUpdateInput>
  }

  /**
   * MetaViewerMap delete
   */
  export type MetaViewerMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
    /**
     * Filter which MetaViewerMap to delete.
     */
    where: MetaViewerMapWhereUniqueInput
  }

  /**
   * MetaViewerMap deleteMany
   */
  export type MetaViewerMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaViewerMaps to delete
     */
    where?: MetaViewerMapWhereInput
    /**
     * Limit how many MetaViewerMaps to delete.
     */
    limit?: number
  }

  /**
   * MetaViewerMap.ActiveRenderFor
   */
  export type MetaViewerMap$ActiveRenderForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    where?: MetaViewerActiveMapWhereInput
    orderBy?: MetaViewerActiveMapOrderByWithRelationInput | MetaViewerActiveMapOrderByWithRelationInput[]
    cursor?: MetaViewerActiveMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetaViewerActiveMapScalarFieldEnum | MetaViewerActiveMapScalarFieldEnum[]
  }

  /**
   * MetaViewerMap.ActiveColliderFor
   */
  export type MetaViewerMap$ActiveColliderForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    where?: MetaViewerActiveMapWhereInput
    orderBy?: MetaViewerActiveMapOrderByWithRelationInput | MetaViewerActiveMapOrderByWithRelationInput[]
    cursor?: MetaViewerActiveMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetaViewerActiveMapScalarFieldEnum | MetaViewerActiveMapScalarFieldEnum[]
  }

  /**
   * MetaViewerMap without action
   */
  export type MetaViewerMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerMap
     */
    select?: MetaViewerMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerMap
     */
    omit?: MetaViewerMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerMapInclude<ExtArgs> | null
  }


  /**
   * Model MetaViewerActiveMap
   */

  export type AggregateMetaViewerActiveMap = {
    _count: MetaViewerActiveMapCountAggregateOutputType | null
    _avg: MetaViewerActiveMapAvgAggregateOutputType | null
    _sum: MetaViewerActiveMapSumAggregateOutputType | null
    _min: MetaViewerActiveMapMinAggregateOutputType | null
    _max: MetaViewerActiveMapMaxAggregateOutputType | null
  }

  export type MetaViewerActiveMapAvgAggregateOutputType = {
    id: number | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapSumAggregateOutputType = {
    id: number | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapMinAggregateOutputType = {
    id: number | null
    updatedAt: Date | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapMaxAggregateOutputType = {
    id: number | null
    updatedAt: Date | null
    metaViewerInfoId: number | null
    activeRenderMapId: number | null
    activeColliderMapId: number | null
  }

  export type MetaViewerActiveMapCountAggregateOutputType = {
    id: number
    updatedAt: number
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
    _all: number
  }


  export type MetaViewerActiveMapAvgAggregateInputType = {
    id?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapSumAggregateInputType = {
    id?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapMinAggregateInputType = {
    id?: true
    updatedAt?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapMaxAggregateInputType = {
    id?: true
    updatedAt?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
  }

  export type MetaViewerActiveMapCountAggregateInputType = {
    id?: true
    updatedAt?: true
    metaViewerInfoId?: true
    activeRenderMapId?: true
    activeColliderMapId?: true
    _all?: true
  }

  export type MetaViewerActiveMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaViewerActiveMap to aggregate.
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     */
    orderBy?: MetaViewerActiveMapOrderByWithRelationInput | MetaViewerActiveMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaViewerActiveMaps
    **/
    _count?: true | MetaViewerActiveMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaViewerActiveMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaViewerActiveMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaViewerActiveMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaViewerActiveMapMaxAggregateInputType
  }

  export type GetMetaViewerActiveMapAggregateType<T extends MetaViewerActiveMapAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaViewerActiveMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaViewerActiveMap[P]>
      : GetScalarType<T[P], AggregateMetaViewerActiveMap[P]>
  }




  export type MetaViewerActiveMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaViewerActiveMapWhereInput
    orderBy?: MetaViewerActiveMapOrderByWithAggregationInput | MetaViewerActiveMapOrderByWithAggregationInput[]
    by: MetaViewerActiveMapScalarFieldEnum[] | MetaViewerActiveMapScalarFieldEnum
    having?: MetaViewerActiveMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaViewerActiveMapCountAggregateInputType | true
    _avg?: MetaViewerActiveMapAvgAggregateInputType
    _sum?: MetaViewerActiveMapSumAggregateInputType
    _min?: MetaViewerActiveMapMinAggregateInputType
    _max?: MetaViewerActiveMapMaxAggregateInputType
  }

  export type MetaViewerActiveMapGroupByOutputType = {
    id: number
    updatedAt: Date
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
    _count: MetaViewerActiveMapCountAggregateOutputType | null
    _avg: MetaViewerActiveMapAvgAggregateOutputType | null
    _sum: MetaViewerActiveMapSumAggregateOutputType | null
    _min: MetaViewerActiveMapMinAggregateOutputType | null
    _max: MetaViewerActiveMapMaxAggregateOutputType | null
  }

  type GetMetaViewerActiveMapGroupByPayload<T extends MetaViewerActiveMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetaViewerActiveMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaViewerActiveMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaViewerActiveMapGroupByOutputType[P]>
            : GetScalarType<T[P], MetaViewerActiveMapGroupByOutputType[P]>
        }
      >
    >


  export type MetaViewerActiveMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    updatedAt?: boolean
    metaViewerInfoId?: boolean
    activeRenderMapId?: boolean
    activeColliderMapId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
    ActiveColliderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerActiveMap"]>

  export type MetaViewerActiveMapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    updatedAt?: boolean
    metaViewerInfoId?: boolean
    activeRenderMapId?: boolean
    activeColliderMapId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
    ActiveColliderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerActiveMap"]>

  export type MetaViewerActiveMapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    updatedAt?: boolean
    metaViewerInfoId?: boolean
    activeRenderMapId?: boolean
    activeColliderMapId?: boolean
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
    ActiveColliderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaViewerActiveMap"]>

  export type MetaViewerActiveMapSelectScalar = {
    id?: boolean
    updatedAt?: boolean
    metaViewerInfoId?: boolean
    activeRenderMapId?: boolean
    activeColliderMapId?: boolean
  }

  export type MetaViewerActiveMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "updatedAt" | "metaViewerInfoId" | "activeRenderMapId" | "activeColliderMapId", ExtArgs["result"]["metaViewerActiveMap"]>
  export type MetaViewerActiveMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
    ActiveColliderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
  }
  export type MetaViewerActiveMapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
    ActiveColliderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
  }
  export type MetaViewerActiveMapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MetaViewerInfo?: boolean | MetaViewerInfoDefaultArgs<ExtArgs>
    ActiveRenderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
    ActiveColliderMap?: boolean | MetaViewerMapDefaultArgs<ExtArgs>
  }

  export type $MetaViewerActiveMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MetaViewerActiveMap"
    objects: {
      MetaViewerInfo: Prisma.$MetaViewerInfoPayload<ExtArgs>
      ActiveRenderMap: Prisma.$MetaViewerMapPayload<ExtArgs>
      ActiveColliderMap: Prisma.$MetaViewerMapPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      updatedAt: Date
      metaViewerInfoId: number
      activeRenderMapId: number
      activeColliderMapId: number
    }, ExtArgs["result"]["metaViewerActiveMap"]>
    composites: {}
  }

  type MetaViewerActiveMapGetPayload<S extends boolean | null | undefined | MetaViewerActiveMapDefaultArgs> = $Result.GetResult<Prisma.$MetaViewerActiveMapPayload, S>

  type MetaViewerActiveMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetaViewerActiveMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetaViewerActiveMapCountAggregateInputType | true
    }

  export interface MetaViewerActiveMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MetaViewerActiveMap'], meta: { name: 'MetaViewerActiveMap' } }
    /**
     * Find zero or one MetaViewerActiveMap that matches the filter.
     * @param {MetaViewerActiveMapFindUniqueArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetaViewerActiveMapFindUniqueArgs>(args: SelectSubset<T, MetaViewerActiveMapFindUniqueArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetaViewerActiveMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetaViewerActiveMapFindUniqueOrThrowArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetaViewerActiveMapFindUniqueOrThrowArgs>(args: SelectSubset<T, MetaViewerActiveMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaViewerActiveMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapFindFirstArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetaViewerActiveMapFindFirstArgs>(args?: SelectSubset<T, MetaViewerActiveMapFindFirstArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaViewerActiveMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapFindFirstOrThrowArgs} args - Arguments to find a MetaViewerActiveMap
     * @example
     * // Get one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetaViewerActiveMapFindFirstOrThrowArgs>(args?: SelectSubset<T, MetaViewerActiveMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetaViewerActiveMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaViewerActiveMaps
     * const metaViewerActiveMaps = await prisma.metaViewerActiveMap.findMany()
     * 
     * // Get first 10 MetaViewerActiveMaps
     * const metaViewerActiveMaps = await prisma.metaViewerActiveMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaViewerActiveMapWithIdOnly = await prisma.metaViewerActiveMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetaViewerActiveMapFindManyArgs>(args?: SelectSubset<T, MetaViewerActiveMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetaViewerActiveMap.
     * @param {MetaViewerActiveMapCreateArgs} args - Arguments to create a MetaViewerActiveMap.
     * @example
     * // Create one MetaViewerActiveMap
     * const MetaViewerActiveMap = await prisma.metaViewerActiveMap.create({
     *   data: {
     *     // ... data to create a MetaViewerActiveMap
     *   }
     * })
     * 
     */
    create<T extends MetaViewerActiveMapCreateArgs>(args: SelectSubset<T, MetaViewerActiveMapCreateArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetaViewerActiveMaps.
     * @param {MetaViewerActiveMapCreateManyArgs} args - Arguments to create many MetaViewerActiveMaps.
     * @example
     * // Create many MetaViewerActiveMaps
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetaViewerActiveMapCreateManyArgs>(args?: SelectSubset<T, MetaViewerActiveMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MetaViewerActiveMaps and returns the data saved in the database.
     * @param {MetaViewerActiveMapCreateManyAndReturnArgs} args - Arguments to create many MetaViewerActiveMaps.
     * @example
     * // Create many MetaViewerActiveMaps
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MetaViewerActiveMaps and only return the `id`
     * const metaViewerActiveMapWithIdOnly = await prisma.metaViewerActiveMap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetaViewerActiveMapCreateManyAndReturnArgs>(args?: SelectSubset<T, MetaViewerActiveMapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MetaViewerActiveMap.
     * @param {MetaViewerActiveMapDeleteArgs} args - Arguments to delete one MetaViewerActiveMap.
     * @example
     * // Delete one MetaViewerActiveMap
     * const MetaViewerActiveMap = await prisma.metaViewerActiveMap.delete({
     *   where: {
     *     // ... filter to delete one MetaViewerActiveMap
     *   }
     * })
     * 
     */
    delete<T extends MetaViewerActiveMapDeleteArgs>(args: SelectSubset<T, MetaViewerActiveMapDeleteArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetaViewerActiveMap.
     * @param {MetaViewerActiveMapUpdateArgs} args - Arguments to update one MetaViewerActiveMap.
     * @example
     * // Update one MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetaViewerActiveMapUpdateArgs>(args: SelectSubset<T, MetaViewerActiveMapUpdateArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetaViewerActiveMaps.
     * @param {MetaViewerActiveMapDeleteManyArgs} args - Arguments to filter MetaViewerActiveMaps to delete.
     * @example
     * // Delete a few MetaViewerActiveMaps
     * const { count } = await prisma.metaViewerActiveMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetaViewerActiveMapDeleteManyArgs>(args?: SelectSubset<T, MetaViewerActiveMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerActiveMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaViewerActiveMaps
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetaViewerActiveMapUpdateManyArgs>(args: SelectSubset<T, MetaViewerActiveMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaViewerActiveMaps and returns the data updated in the database.
     * @param {MetaViewerActiveMapUpdateManyAndReturnArgs} args - Arguments to update many MetaViewerActiveMaps.
     * @example
     * // Update many MetaViewerActiveMaps
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MetaViewerActiveMaps and only return the `id`
     * const metaViewerActiveMapWithIdOnly = await prisma.metaViewerActiveMap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetaViewerActiveMapUpdateManyAndReturnArgs>(args: SelectSubset<T, MetaViewerActiveMapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MetaViewerActiveMap.
     * @param {MetaViewerActiveMapUpsertArgs} args - Arguments to update or create a MetaViewerActiveMap.
     * @example
     * // Update or create a MetaViewerActiveMap
     * const metaViewerActiveMap = await prisma.metaViewerActiveMap.upsert({
     *   create: {
     *     // ... data to create a MetaViewerActiveMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaViewerActiveMap we want to update
     *   }
     * })
     */
    upsert<T extends MetaViewerActiveMapUpsertArgs>(args: SelectSubset<T, MetaViewerActiveMapUpsertArgs<ExtArgs>>): Prisma__MetaViewerActiveMapClient<$Result.GetResult<Prisma.$MetaViewerActiveMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetaViewerActiveMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapCountArgs} args - Arguments to filter MetaViewerActiveMaps to count.
     * @example
     * // Count the number of MetaViewerActiveMaps
     * const count = await prisma.metaViewerActiveMap.count({
     *   where: {
     *     // ... the filter for the MetaViewerActiveMaps we want to count
     *   }
     * })
    **/
    count<T extends MetaViewerActiveMapCountArgs>(
      args?: Subset<T, MetaViewerActiveMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaViewerActiveMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaViewerActiveMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaViewerActiveMapAggregateArgs>(args: Subset<T, MetaViewerActiveMapAggregateArgs>): Prisma.PrismaPromise<GetMetaViewerActiveMapAggregateType<T>>

    /**
     * Group by MetaViewerActiveMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaViewerActiveMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaViewerActiveMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaViewerActiveMapGroupByArgs['orderBy'] }
        : { orderBy?: MetaViewerActiveMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaViewerActiveMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaViewerActiveMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MetaViewerActiveMap model
   */
  readonly fields: MetaViewerActiveMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaViewerActiveMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetaViewerActiveMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MetaViewerInfo<T extends MetaViewerInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerInfoDefaultArgs<ExtArgs>>): Prisma__MetaViewerInfoClient<$Result.GetResult<Prisma.$MetaViewerInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ActiveRenderMap<T extends MetaViewerMapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerMapDefaultArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ActiveColliderMap<T extends MetaViewerMapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MetaViewerMapDefaultArgs<ExtArgs>>): Prisma__MetaViewerMapClient<$Result.GetResult<Prisma.$MetaViewerMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MetaViewerActiveMap model
   */
  interface MetaViewerActiveMapFieldRefs {
    readonly id: FieldRef<"MetaViewerActiveMap", 'Int'>
    readonly updatedAt: FieldRef<"MetaViewerActiveMap", 'DateTime'>
    readonly metaViewerInfoId: FieldRef<"MetaViewerActiveMap", 'Int'>
    readonly activeRenderMapId: FieldRef<"MetaViewerActiveMap", 'Int'>
    readonly activeColliderMapId: FieldRef<"MetaViewerActiveMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MetaViewerActiveMap findUnique
   */
  export type MetaViewerActiveMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     */
    where: MetaViewerActiveMapWhereUniqueInput
  }

  /**
   * MetaViewerActiveMap findUniqueOrThrow
   */
  export type MetaViewerActiveMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     */
    where: MetaViewerActiveMapWhereUniqueInput
  }

  /**
   * MetaViewerActiveMap findFirst
   */
  export type MetaViewerActiveMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     */
    orderBy?: MetaViewerActiveMapOrderByWithRelationInput | MetaViewerActiveMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerActiveMaps.
     */
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerActiveMaps.
     */
    distinct?: MetaViewerActiveMapScalarFieldEnum | MetaViewerActiveMapScalarFieldEnum[]
  }

  /**
   * MetaViewerActiveMap findFirstOrThrow
   */
  export type MetaViewerActiveMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerActiveMap to fetch.
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     */
    orderBy?: MetaViewerActiveMapOrderByWithRelationInput | MetaViewerActiveMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaViewerActiveMaps.
     */
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaViewerActiveMaps.
     */
    distinct?: MetaViewerActiveMapScalarFieldEnum | MetaViewerActiveMapScalarFieldEnum[]
  }

  /**
   * MetaViewerActiveMap findMany
   */
  export type MetaViewerActiveMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * Filter, which MetaViewerActiveMaps to fetch.
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaViewerActiveMaps to fetch.
     */
    orderBy?: MetaViewerActiveMapOrderByWithRelationInput | MetaViewerActiveMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaViewerActiveMaps.
     */
    cursor?: MetaViewerActiveMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaViewerActiveMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaViewerActiveMaps.
     */
    skip?: number
    distinct?: MetaViewerActiveMapScalarFieldEnum | MetaViewerActiveMapScalarFieldEnum[]
  }

  /**
   * MetaViewerActiveMap create
   */
  export type MetaViewerActiveMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * The data needed to create a MetaViewerActiveMap.
     */
    data: XOR<MetaViewerActiveMapCreateInput, MetaViewerActiveMapUncheckedCreateInput>
  }

  /**
   * MetaViewerActiveMap createMany
   */
  export type MetaViewerActiveMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MetaViewerActiveMaps.
     */
    data: MetaViewerActiveMapCreateManyInput | MetaViewerActiveMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetaViewerActiveMap createManyAndReturn
   */
  export type MetaViewerActiveMapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * The data used to create many MetaViewerActiveMaps.
     */
    data: MetaViewerActiveMapCreateManyInput | MetaViewerActiveMapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaViewerActiveMap update
   */
  export type MetaViewerActiveMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * The data needed to update a MetaViewerActiveMap.
     */
    data: XOR<MetaViewerActiveMapUpdateInput, MetaViewerActiveMapUncheckedUpdateInput>
    /**
     * Choose, which MetaViewerActiveMap to update.
     */
    where: MetaViewerActiveMapWhereUniqueInput
  }

  /**
   * MetaViewerActiveMap updateMany
   */
  export type MetaViewerActiveMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MetaViewerActiveMaps.
     */
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerActiveMaps to update
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * Limit how many MetaViewerActiveMaps to update.
     */
    limit?: number
  }

  /**
   * MetaViewerActiveMap updateManyAndReturn
   */
  export type MetaViewerActiveMapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * The data used to update MetaViewerActiveMaps.
     */
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyInput>
    /**
     * Filter which MetaViewerActiveMaps to update
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * Limit how many MetaViewerActiveMaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaViewerActiveMap upsert
   */
  export type MetaViewerActiveMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * The filter to search for the MetaViewerActiveMap to update in case it exists.
     */
    where: MetaViewerActiveMapWhereUniqueInput
    /**
     * In case the MetaViewerActiveMap found by the `where` argument doesn't exist, create a new MetaViewerActiveMap with this data.
     */
    create: XOR<MetaViewerActiveMapCreateInput, MetaViewerActiveMapUncheckedCreateInput>
    /**
     * In case the MetaViewerActiveMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetaViewerActiveMapUpdateInput, MetaViewerActiveMapUncheckedUpdateInput>
  }

  /**
   * MetaViewerActiveMap delete
   */
  export type MetaViewerActiveMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
    /**
     * Filter which MetaViewerActiveMap to delete.
     */
    where: MetaViewerActiveMapWhereUniqueInput
  }

  /**
   * MetaViewerActiveMap deleteMany
   */
  export type MetaViewerActiveMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaViewerActiveMaps to delete
     */
    where?: MetaViewerActiveMapWhereInput
    /**
     * Limit how many MetaViewerActiveMaps to delete.
     */
    limit?: number
  }

  /**
   * MetaViewerActiveMap without action
   */
  export type MetaViewerActiveMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaViewerActiveMap
     */
    select?: MetaViewerActiveMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaViewerActiveMap
     */
    omit?: MetaViewerActiveMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaViewerActiveMapInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    description: string | null
    isDisable: boolean | null
    code: string | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    description: string | null
    isDisable: boolean | null
    code: string | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    description: number
    isDisable: number
    code: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    description?: true
    isDisable?: true
    code?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    description?: true
    isDisable?: true
    code?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    description?: true
    isDisable?: true
    code?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    description: string | null
    isDisable: boolean
    code: string
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    description?: boolean
    isDisable?: boolean
    code?: boolean
    AncestorCategories?: boolean | ProductCategory$AncestorCategoriesArgs<ExtArgs>
    DescendantCategories?: boolean | ProductCategory$DescendantCategoriesArgs<ExtArgs>
    Products?: boolean | ProductCategory$ProductsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    description?: boolean
    isDisable?: boolean
    code?: boolean
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    description?: boolean
    isDisable?: boolean
    code?: boolean
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    description?: boolean
    isDisable?: boolean
    code?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "description" | "isDisable" | "code", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategories?: boolean | ProductCategory$AncestorCategoriesArgs<ExtArgs>
    DescendantCategories?: boolean | ProductCategory$DescendantCategoriesArgs<ExtArgs>
    Products?: boolean | ProductCategory$ProductsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      AncestorCategories: Prisma.$ClosureProductCategoryPayload<ExtArgs>[]
      DescendantCategories: Prisma.$ClosureProductCategoryPayload<ExtArgs>[]
      Products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      description: string | null
      isDisable: boolean
      code: string
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AncestorCategories<T extends ProductCategory$AncestorCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$AncestorCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DescendantCategories<T extends ProductCategory$DescendantCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$DescendantCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Products<T extends ProductCategory$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$ProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'Int'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly isDisable: FieldRef<"ProductCategory", 'Boolean'>
    readonly code: FieldRef<"ProductCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.AncestorCategories
   */
  export type ProductCategory$AncestorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    where?: ClosureProductCategoryWhereInput
    orderBy?: ClosureProductCategoryOrderByWithRelationInput | ClosureProductCategoryOrderByWithRelationInput[]
    cursor?: ClosureProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClosureProductCategoryScalarFieldEnum | ClosureProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.DescendantCategories
   */
  export type ProductCategory$DescendantCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    where?: ClosureProductCategoryWhereInput
    orderBy?: ClosureProductCategoryOrderByWithRelationInput | ClosureProductCategoryOrderByWithRelationInput[]
    cursor?: ClosureProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClosureProductCategoryScalarFieldEnum | ClosureProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.Products
   */
  export type ProductCategory$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ClosureProductCategory
   */

  export type AggregateClosureProductCategory = {
    _count: ClosureProductCategoryCountAggregateOutputType | null
    _avg: ClosureProductCategoryAvgAggregateOutputType | null
    _sum: ClosureProductCategorySumAggregateOutputType | null
    _min: ClosureProductCategoryMinAggregateOutputType | null
    _max: ClosureProductCategoryMaxAggregateOutputType | null
  }

  export type ClosureProductCategoryAvgAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategorySumAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategoryMinAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategoryMaxAggregateOutputType = {
    ancestor: number | null
    descendant: number | null
    depth: number | null
  }

  export type ClosureProductCategoryCountAggregateOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _all: number
  }


  export type ClosureProductCategoryAvgAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategorySumAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategoryMinAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategoryMaxAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
  }

  export type ClosureProductCategoryCountAggregateInputType = {
    ancestor?: true
    descendant?: true
    depth?: true
    _all?: true
  }

  export type ClosureProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClosureProductCategory to aggregate.
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     */
    orderBy?: ClosureProductCategoryOrderByWithRelationInput | ClosureProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClosureProductCategories
    **/
    _count?: true | ClosureProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClosureProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClosureProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClosureProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClosureProductCategoryMaxAggregateInputType
  }

  export type GetClosureProductCategoryAggregateType<T extends ClosureProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateClosureProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClosureProductCategory[P]>
      : GetScalarType<T[P], AggregateClosureProductCategory[P]>
  }




  export type ClosureProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosureProductCategoryWhereInput
    orderBy?: ClosureProductCategoryOrderByWithAggregationInput | ClosureProductCategoryOrderByWithAggregationInput[]
    by: ClosureProductCategoryScalarFieldEnum[] | ClosureProductCategoryScalarFieldEnum
    having?: ClosureProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClosureProductCategoryCountAggregateInputType | true
    _avg?: ClosureProductCategoryAvgAggregateInputType
    _sum?: ClosureProductCategorySumAggregateInputType
    _min?: ClosureProductCategoryMinAggregateInputType
    _max?: ClosureProductCategoryMaxAggregateInputType
  }

  export type ClosureProductCategoryGroupByOutputType = {
    ancestor: number
    descendant: number
    depth: number
    _count: ClosureProductCategoryCountAggregateOutputType | null
    _avg: ClosureProductCategoryAvgAggregateOutputType | null
    _sum: ClosureProductCategorySumAggregateOutputType | null
    _min: ClosureProductCategoryMinAggregateOutputType | null
    _max: ClosureProductCategoryMaxAggregateOutputType | null
  }

  type GetClosureProductCategoryGroupByPayload<T extends ClosureProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClosureProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClosureProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClosureProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ClosureProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ClosureProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closureProductCategory"]>

  export type ClosureProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closureProductCategory"]>

  export type ClosureProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
    AncestorCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closureProductCategory"]>

  export type ClosureProductCategorySelectScalar = {
    ancestor?: boolean
    descendant?: boolean
    depth?: boolean
  }

  export type ClosureProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ancestor" | "descendant" | "depth", ExtArgs["result"]["closureProductCategory"]>
  export type ClosureProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }
  export type ClosureProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }
  export type ClosureProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AncestorCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    DescendantCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }

  export type $ClosureProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClosureProductCategory"
    objects: {
      AncestorCategory: Prisma.$ProductCategoryPayload<ExtArgs>
      DescendantCategory: Prisma.$ProductCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ancestor: number
      descendant: number
      depth: number
    }, ExtArgs["result"]["closureProductCategory"]>
    composites: {}
  }

  type ClosureProductCategoryGetPayload<S extends boolean | null | undefined | ClosureProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ClosureProductCategoryPayload, S>

  type ClosureProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClosureProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClosureProductCategoryCountAggregateInputType | true
    }

  export interface ClosureProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClosureProductCategory'], meta: { name: 'ClosureProductCategory' } }
    /**
     * Find zero or one ClosureProductCategory that matches the filter.
     * @param {ClosureProductCategoryFindUniqueArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClosureProductCategoryFindUniqueArgs>(args: SelectSubset<T, ClosureProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClosureProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClosureProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClosureProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ClosureProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClosureProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryFindFirstArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClosureProductCategoryFindFirstArgs>(args?: SelectSubset<T, ClosureProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClosureProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ClosureProductCategory
     * @example
     * // Get one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClosureProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ClosureProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClosureProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClosureProductCategories
     * const closureProductCategories = await prisma.closureProductCategory.findMany()
     * 
     * // Get first 10 ClosureProductCategories
     * const closureProductCategories = await prisma.closureProductCategory.findMany({ take: 10 })
     * 
     * // Only select the `ancestor`
     * const closureProductCategoryWithAncestorOnly = await prisma.closureProductCategory.findMany({ select: { ancestor: true } })
     * 
     */
    findMany<T extends ClosureProductCategoryFindManyArgs>(args?: SelectSubset<T, ClosureProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClosureProductCategory.
     * @param {ClosureProductCategoryCreateArgs} args - Arguments to create a ClosureProductCategory.
     * @example
     * // Create one ClosureProductCategory
     * const ClosureProductCategory = await prisma.closureProductCategory.create({
     *   data: {
     *     // ... data to create a ClosureProductCategory
     *   }
     * })
     * 
     */
    create<T extends ClosureProductCategoryCreateArgs>(args: SelectSubset<T, ClosureProductCategoryCreateArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClosureProductCategories.
     * @param {ClosureProductCategoryCreateManyArgs} args - Arguments to create many ClosureProductCategories.
     * @example
     * // Create many ClosureProductCategories
     * const closureProductCategory = await prisma.closureProductCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClosureProductCategoryCreateManyArgs>(args?: SelectSubset<T, ClosureProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClosureProductCategories and returns the data saved in the database.
     * @param {ClosureProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ClosureProductCategories.
     * @example
     * // Create many ClosureProductCategories
     * const closureProductCategory = await prisma.closureProductCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClosureProductCategories and only return the `ancestor`
     * const closureProductCategoryWithAncestorOnly = await prisma.closureProductCategory.createManyAndReturn({
     *   select: { ancestor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClosureProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ClosureProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClosureProductCategory.
     * @param {ClosureProductCategoryDeleteArgs} args - Arguments to delete one ClosureProductCategory.
     * @example
     * // Delete one ClosureProductCategory
     * const ClosureProductCategory = await prisma.closureProductCategory.delete({
     *   where: {
     *     // ... filter to delete one ClosureProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ClosureProductCategoryDeleteArgs>(args: SelectSubset<T, ClosureProductCategoryDeleteArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClosureProductCategory.
     * @param {ClosureProductCategoryUpdateArgs} args - Arguments to update one ClosureProductCategory.
     * @example
     * // Update one ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClosureProductCategoryUpdateArgs>(args: SelectSubset<T, ClosureProductCategoryUpdateArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClosureProductCategories.
     * @param {ClosureProductCategoryDeleteManyArgs} args - Arguments to filter ClosureProductCategories to delete.
     * @example
     * // Delete a few ClosureProductCategories
     * const { count } = await prisma.closureProductCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClosureProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ClosureProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClosureProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClosureProductCategories
     * const closureProductCategory = await prisma.closureProductCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClosureProductCategoryUpdateManyArgs>(args: SelectSubset<T, ClosureProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClosureProductCategories and returns the data updated in the database.
     * @param {ClosureProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ClosureProductCategories.
     * @example
     * // Update many ClosureProductCategories
     * const closureProductCategory = await prisma.closureProductCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClosureProductCategories and only return the `ancestor`
     * const closureProductCategoryWithAncestorOnly = await prisma.closureProductCategory.updateManyAndReturn({
     *   select: { ancestor: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClosureProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ClosureProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClosureProductCategory.
     * @param {ClosureProductCategoryUpsertArgs} args - Arguments to update or create a ClosureProductCategory.
     * @example
     * // Update or create a ClosureProductCategory
     * const closureProductCategory = await prisma.closureProductCategory.upsert({
     *   create: {
     *     // ... data to create a ClosureProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClosureProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ClosureProductCategoryUpsertArgs>(args: SelectSubset<T, ClosureProductCategoryUpsertArgs<ExtArgs>>): Prisma__ClosureProductCategoryClient<$Result.GetResult<Prisma.$ClosureProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClosureProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryCountArgs} args - Arguments to filter ClosureProductCategories to count.
     * @example
     * // Count the number of ClosureProductCategories
     * const count = await prisma.closureProductCategory.count({
     *   where: {
     *     // ... the filter for the ClosureProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ClosureProductCategoryCountArgs>(
      args?: Subset<T, ClosureProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClosureProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClosureProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClosureProductCategoryAggregateArgs>(args: Subset<T, ClosureProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetClosureProductCategoryAggregateType<T>>

    /**
     * Group by ClosureProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosureProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClosureProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClosureProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ClosureProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClosureProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosureProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClosureProductCategory model
   */
  readonly fields: ClosureProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClosureProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClosureProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AncestorCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DescendantCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClosureProductCategory model
   */
  interface ClosureProductCategoryFieldRefs {
    readonly ancestor: FieldRef<"ClosureProductCategory", 'Int'>
    readonly descendant: FieldRef<"ClosureProductCategory", 'Int'>
    readonly depth: FieldRef<"ClosureProductCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClosureProductCategory findUnique
   */
  export type ClosureProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     */
    where: ClosureProductCategoryWhereUniqueInput
  }

  /**
   * ClosureProductCategory findUniqueOrThrow
   */
  export type ClosureProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     */
    where: ClosureProductCategoryWhereUniqueInput
  }

  /**
   * ClosureProductCategory findFirst
   */
  export type ClosureProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     */
    orderBy?: ClosureProductCategoryOrderByWithRelationInput | ClosureProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureProductCategories.
     */
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureProductCategories.
     */
    distinct?: ClosureProductCategoryScalarFieldEnum | ClosureProductCategoryScalarFieldEnum[]
  }

  /**
   * ClosureProductCategory findFirstOrThrow
   */
  export type ClosureProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureProductCategory to fetch.
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     */
    orderBy?: ClosureProductCategoryOrderByWithRelationInput | ClosureProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClosureProductCategories.
     */
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClosureProductCategories.
     */
    distinct?: ClosureProductCategoryScalarFieldEnum | ClosureProductCategoryScalarFieldEnum[]
  }

  /**
   * ClosureProductCategory findMany
   */
  export type ClosureProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ClosureProductCategories to fetch.
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClosureProductCategories to fetch.
     */
    orderBy?: ClosureProductCategoryOrderByWithRelationInput | ClosureProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClosureProductCategories.
     */
    cursor?: ClosureProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClosureProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClosureProductCategories.
     */
    skip?: number
    distinct?: ClosureProductCategoryScalarFieldEnum | ClosureProductCategoryScalarFieldEnum[]
  }

  /**
   * ClosureProductCategory create
   */
  export type ClosureProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ClosureProductCategory.
     */
    data: XOR<ClosureProductCategoryCreateInput, ClosureProductCategoryUncheckedCreateInput>
  }

  /**
   * ClosureProductCategory createMany
   */
  export type ClosureProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClosureProductCategories.
     */
    data: ClosureProductCategoryCreateManyInput | ClosureProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClosureProductCategory createManyAndReturn
   */
  export type ClosureProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ClosureProductCategories.
     */
    data: ClosureProductCategoryCreateManyInput | ClosureProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClosureProductCategory update
   */
  export type ClosureProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ClosureProductCategory.
     */
    data: XOR<ClosureProductCategoryUpdateInput, ClosureProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ClosureProductCategory to update.
     */
    where: ClosureProductCategoryWhereUniqueInput
  }

  /**
   * ClosureProductCategory updateMany
   */
  export type ClosureProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClosureProductCategories.
     */
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ClosureProductCategories to update
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * Limit how many ClosureProductCategories to update.
     */
    limit?: number
  }

  /**
   * ClosureProductCategory updateManyAndReturn
   */
  export type ClosureProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ClosureProductCategories.
     */
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ClosureProductCategories to update
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * Limit how many ClosureProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClosureProductCategory upsert
   */
  export type ClosureProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ClosureProductCategory to update in case it exists.
     */
    where: ClosureProductCategoryWhereUniqueInput
    /**
     * In case the ClosureProductCategory found by the `where` argument doesn't exist, create a new ClosureProductCategory with this data.
     */
    create: XOR<ClosureProductCategoryCreateInput, ClosureProductCategoryUncheckedCreateInput>
    /**
     * In case the ClosureProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClosureProductCategoryUpdateInput, ClosureProductCategoryUncheckedUpdateInput>
  }

  /**
   * ClosureProductCategory delete
   */
  export type ClosureProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ClosureProductCategory to delete.
     */
    where: ClosureProductCategoryWhereUniqueInput
  }

  /**
   * ClosureProductCategory deleteMany
   */
  export type ClosureProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClosureProductCategories to delete
     */
    where?: ClosureProductCategoryWhereInput
    /**
     * Limit how many ClosureProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ClosureProductCategory without action
   */
  export type ClosureProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosureProductCategory
     */
    select?: ClosureProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClosureProductCategory
     */
    omit?: ClosureProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosureProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    categoryId: number | null
    cafeInfoId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    categoryId: number | null
    cafeInfoId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    isDisable: boolean | null
    isAvailable: boolean | null
    categoryId: number | null
    cafeInfoId: number | null
    productRedirectUrl: string | null
    isSignature: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    isDisable: boolean | null
    isAvailable: boolean | null
    categoryId: number | null
    cafeInfoId: number | null
    productRedirectUrl: string | null
    isSignature: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    code: number
    description: number
    price: number
    originalPrice: number
    stockQuantity: number
    minOrderQuantity: number
    isDisable: number
    isAvailable: number
    categoryId: number
    cafeInfoId: number
    productRedirectUrl: number
    isSignature: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    categoryId?: true
    cafeInfoId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    categoryId?: true
    cafeInfoId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    description?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    isDisable?: true
    isAvailable?: true
    categoryId?: true
    cafeInfoId?: true
    productRedirectUrl?: true
    isSignature?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    description?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    isDisable?: true
    isAvailable?: true
    categoryId?: true
    cafeInfoId?: true
    productRedirectUrl?: true
    isSignature?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    description?: true
    price?: true
    originalPrice?: true
    stockQuantity?: true
    minOrderQuantity?: true
    isDisable?: true
    isAvailable?: true
    categoryId?: true
    cafeInfoId?: true
    productRedirectUrl?: true
    isSignature?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    code: string
    description: string | null
    price: number
    originalPrice: number | null
    stockQuantity: number
    minOrderQuantity: number
    isDisable: boolean
    isAvailable: boolean
    categoryId: number
    cafeInfoId: number | null
    productRedirectUrl: string | null
    isSignature: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    isDisable?: boolean
    isAvailable?: boolean
    categoryId?: boolean
    cafeInfoId?: boolean
    productRedirectUrl?: boolean
    isSignature?: boolean
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    CafeInfo?: boolean | Product$CafeInfoArgs<ExtArgs>
    WishlistProducts?: boolean | Product$WishlistProductsArgs<ExtArgs>
    ProductImages?: boolean | Product$ProductImagesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    isDisable?: boolean
    isAvailable?: boolean
    categoryId?: boolean
    cafeInfoId?: boolean
    productRedirectUrl?: boolean
    isSignature?: boolean
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    CafeInfo?: boolean | Product$CafeInfoArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    isDisable?: boolean
    isAvailable?: boolean
    categoryId?: boolean
    cafeInfoId?: boolean
    productRedirectUrl?: boolean
    isSignature?: boolean
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    CafeInfo?: boolean | Product$CafeInfoArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    isDisable?: boolean
    isAvailable?: boolean
    categoryId?: boolean
    cafeInfoId?: boolean
    productRedirectUrl?: boolean
    isSignature?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "code" | "description" | "price" | "originalPrice" | "stockQuantity" | "minOrderQuantity" | "isDisable" | "isAvailable" | "categoryId" | "cafeInfoId" | "productRedirectUrl" | "isSignature", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    CafeInfo?: boolean | Product$CafeInfoArgs<ExtArgs>
    WishlistProducts?: boolean | Product$WishlistProductsArgs<ExtArgs>
    ProductImages?: boolean | Product$ProductImagesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    CafeInfo?: boolean | Product$CafeInfoArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    CafeInfo?: boolean | Product$CafeInfoArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>
      CafeInfo: Prisma.$CafeInfoPayload<ExtArgs> | null
      WishlistProducts: Prisma.$WishlistProductPayload<ExtArgs>[]
      ProductImages: Prisma.$ProductImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      code: string
      description: string | null
      price: number
      originalPrice: number | null
      stockQuantity: number
      minOrderQuantity: number
      isDisable: boolean
      isAvailable: boolean
      categoryId: number
      cafeInfoId: number | null
      productRedirectUrl: string | null
      isSignature: boolean
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CafeInfo<T extends Product$CafeInfoArgs<ExtArgs> = {}>(args?: Subset<T, Product$CafeInfoArgs<ExtArgs>>): Prisma__CafeInfoClient<$Result.GetResult<Prisma.$CafeInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    WishlistProducts<T extends Product$WishlistProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$WishlistProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductImages<T extends Product$ProductImagesArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Int'>
    readonly originalPrice: FieldRef<"Product", 'Int'>
    readonly stockQuantity: FieldRef<"Product", 'Int'>
    readonly minOrderQuantity: FieldRef<"Product", 'Int'>
    readonly isDisable: FieldRef<"Product", 'Boolean'>
    readonly isAvailable: FieldRef<"Product", 'Boolean'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly cafeInfoId: FieldRef<"Product", 'Int'>
    readonly productRedirectUrl: FieldRef<"Product", 'String'>
    readonly isSignature: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.CafeInfo
   */
  export type Product$CafeInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeInfo
     */
    select?: CafeInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeInfo
     */
    omit?: CafeInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInfoInclude<ExtArgs> | null
    where?: CafeInfoWhereInput
  }

  /**
   * Product.WishlistProducts
   */
  export type Product$WishlistProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    where?: WishlistProductWhereInput
    orderBy?: WishlistProductOrderByWithRelationInput | WishlistProductOrderByWithRelationInput[]
    cursor?: WishlistProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistProductScalarFieldEnum | WishlistProductScalarFieldEnum[]
  }

  /**
   * Product.ProductImages
   */
  export type Product$ProductImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model WishlistProduct
   */

  export type AggregateWishlistProduct = {
    _count: WishlistProductCountAggregateOutputType | null
    _avg: WishlistProductAvgAggregateOutputType | null
    _sum: WishlistProductSumAggregateOutputType | null
    _min: WishlistProductMinAggregateOutputType | null
    _max: WishlistProductMaxAggregateOutputType | null
  }

  export type WishlistProductAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductSumAggregateOutputType = {
    id: number | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    productId: number | null
    proxyUserId: number | null
  }

  export type WishlistProductCountAggregateOutputType = {
    id: number
    createdAt: number
    productId: number
    proxyUserId: number
    _all: number
  }


  export type WishlistProductAvgAggregateInputType = {
    id?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductSumAggregateInputType = {
    id?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductMinAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductMaxAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    proxyUserId?: true
  }

  export type WishlistProductCountAggregateInputType = {
    id?: true
    createdAt?: true
    productId?: true
    proxyUserId?: true
    _all?: true
  }

  export type WishlistProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistProduct to aggregate.
     */
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     */
    orderBy?: WishlistProductOrderByWithRelationInput | WishlistProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistProducts
    **/
    _count?: true | WishlistProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistProductMaxAggregateInputType
  }

  export type GetWishlistProductAggregateType<T extends WishlistProductAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistProduct[P]>
      : GetScalarType<T[P], AggregateWishlistProduct[P]>
  }




  export type WishlistProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistProductWhereInput
    orderBy?: WishlistProductOrderByWithAggregationInput | WishlistProductOrderByWithAggregationInput[]
    by: WishlistProductScalarFieldEnum[] | WishlistProductScalarFieldEnum
    having?: WishlistProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistProductCountAggregateInputType | true
    _avg?: WishlistProductAvgAggregateInputType
    _sum?: WishlistProductSumAggregateInputType
    _min?: WishlistProductMinAggregateInputType
    _max?: WishlistProductMaxAggregateInputType
  }

  export type WishlistProductGroupByOutputType = {
    id: number
    createdAt: Date
    productId: number
    proxyUserId: number
    _count: WishlistProductCountAggregateOutputType | null
    _avg: WishlistProductAvgAggregateOutputType | null
    _sum: WishlistProductSumAggregateOutputType | null
    _min: WishlistProductMinAggregateOutputType | null
    _max: WishlistProductMaxAggregateOutputType | null
  }

  type GetWishlistProductGroupByPayload<T extends WishlistProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistProductGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistProductGroupByOutputType[P]>
        }
      >
    >


  export type WishlistProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    proxyUserId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistProduct"]>

  export type WishlistProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    proxyUserId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistProduct"]>

  export type WishlistProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    proxyUserId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistProduct"]>

  export type WishlistProductSelectScalar = {
    id?: boolean
    createdAt?: boolean
    productId?: boolean
    proxyUserId?: boolean
  }

  export type WishlistProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "productId" | "proxyUserId", ExtArgs["result"]["wishlistProduct"]>
  export type WishlistProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
  }
  export type WishlistProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
  }
  export type WishlistProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProxyUser?: boolean | ProxyUserDefaultArgs<ExtArgs>
  }

  export type $WishlistProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistProduct"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
      ProxyUser: Prisma.$ProxyUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      productId: number
      proxyUserId: number
    }, ExtArgs["result"]["wishlistProduct"]>
    composites: {}
  }

  type WishlistProductGetPayload<S extends boolean | null | undefined | WishlistProductDefaultArgs> = $Result.GetResult<Prisma.$WishlistProductPayload, S>

  type WishlistProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistProductCountAggregateInputType | true
    }

  export interface WishlistProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistProduct'], meta: { name: 'WishlistProduct' } }
    /**
     * Find zero or one WishlistProduct that matches the filter.
     * @param {WishlistProductFindUniqueArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistProductFindUniqueArgs>(args: SelectSubset<T, WishlistProductFindUniqueArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WishlistProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistProductFindUniqueOrThrowArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistProductFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductFindFirstArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistProductFindFirstArgs>(args?: SelectSubset<T, WishlistProductFindFirstArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductFindFirstOrThrowArgs} args - Arguments to find a WishlistProduct
     * @example
     * // Get one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistProductFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WishlistProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistProducts
     * const wishlistProducts = await prisma.wishlistProduct.findMany()
     * 
     * // Get first 10 WishlistProducts
     * const wishlistProducts = await prisma.wishlistProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistProductWithIdOnly = await prisma.wishlistProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistProductFindManyArgs>(args?: SelectSubset<T, WishlistProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WishlistProduct.
     * @param {WishlistProductCreateArgs} args - Arguments to create a WishlistProduct.
     * @example
     * // Create one WishlistProduct
     * const WishlistProduct = await prisma.wishlistProduct.create({
     *   data: {
     *     // ... data to create a WishlistProduct
     *   }
     * })
     * 
     */
    create<T extends WishlistProductCreateArgs>(args: SelectSubset<T, WishlistProductCreateArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WishlistProducts.
     * @param {WishlistProductCreateManyArgs} args - Arguments to create many WishlistProducts.
     * @example
     * // Create many WishlistProducts
     * const wishlistProduct = await prisma.wishlistProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistProductCreateManyArgs>(args?: SelectSubset<T, WishlistProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishlistProducts and returns the data saved in the database.
     * @param {WishlistProductCreateManyAndReturnArgs} args - Arguments to create many WishlistProducts.
     * @example
     * // Create many WishlistProducts
     * const wishlistProduct = await prisma.wishlistProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishlistProducts and only return the `id`
     * const wishlistProductWithIdOnly = await prisma.wishlistProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistProductCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WishlistProduct.
     * @param {WishlistProductDeleteArgs} args - Arguments to delete one WishlistProduct.
     * @example
     * // Delete one WishlistProduct
     * const WishlistProduct = await prisma.wishlistProduct.delete({
     *   where: {
     *     // ... filter to delete one WishlistProduct
     *   }
     * })
     * 
     */
    delete<T extends WishlistProductDeleteArgs>(args: SelectSubset<T, WishlistProductDeleteArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WishlistProduct.
     * @param {WishlistProductUpdateArgs} args - Arguments to update one WishlistProduct.
     * @example
     * // Update one WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistProductUpdateArgs>(args: SelectSubset<T, WishlistProductUpdateArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WishlistProducts.
     * @param {WishlistProductDeleteManyArgs} args - Arguments to filter WishlistProducts to delete.
     * @example
     * // Delete a few WishlistProducts
     * const { count } = await prisma.wishlistProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistProductDeleteManyArgs>(args?: SelectSubset<T, WishlistProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistProducts
     * const wishlistProduct = await prisma.wishlistProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistProductUpdateManyArgs>(args: SelectSubset<T, WishlistProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistProducts and returns the data updated in the database.
     * @param {WishlistProductUpdateManyAndReturnArgs} args - Arguments to update many WishlistProducts.
     * @example
     * // Update many WishlistProducts
     * const wishlistProduct = await prisma.wishlistProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WishlistProducts and only return the `id`
     * const wishlistProductWithIdOnly = await prisma.wishlistProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WishlistProductUpdateManyAndReturnArgs>(args: SelectSubset<T, WishlistProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WishlistProduct.
     * @param {WishlistProductUpsertArgs} args - Arguments to update or create a WishlistProduct.
     * @example
     * // Update or create a WishlistProduct
     * const wishlistProduct = await prisma.wishlistProduct.upsert({
     *   create: {
     *     // ... data to create a WishlistProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistProduct we want to update
     *   }
     * })
     */
    upsert<T extends WishlistProductUpsertArgs>(args: SelectSubset<T, WishlistProductUpsertArgs<ExtArgs>>): Prisma__WishlistProductClient<$Result.GetResult<Prisma.$WishlistProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WishlistProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductCountArgs} args - Arguments to filter WishlistProducts to count.
     * @example
     * // Count the number of WishlistProducts
     * const count = await prisma.wishlistProduct.count({
     *   where: {
     *     // ... the filter for the WishlistProducts we want to count
     *   }
     * })
    **/
    count<T extends WishlistProductCountArgs>(
      args?: Subset<T, WishlistProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistProductAggregateArgs>(args: Subset<T, WishlistProductAggregateArgs>): Prisma.PrismaPromise<GetWishlistProductAggregateType<T>>

    /**
     * Group by WishlistProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistProductGroupByArgs['orderBy'] }
        : { orderBy?: WishlistProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishlistProduct model
   */
  readonly fields: WishlistProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProxyUser<T extends ProxyUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProxyUserDefaultArgs<ExtArgs>>): Prisma__ProxyUserClient<$Result.GetResult<Prisma.$ProxyUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishlistProduct model
   */
  interface WishlistProductFieldRefs {
    readonly id: FieldRef<"WishlistProduct", 'Int'>
    readonly createdAt: FieldRef<"WishlistProduct", 'DateTime'>
    readonly productId: FieldRef<"WishlistProduct", 'Int'>
    readonly proxyUserId: FieldRef<"WishlistProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WishlistProduct findUnique
   */
  export type WishlistProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * Filter, which WishlistProduct to fetch.
     */
    where: WishlistProductWhereUniqueInput
  }

  /**
   * WishlistProduct findUniqueOrThrow
   */
  export type WishlistProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * Filter, which WishlistProduct to fetch.
     */
    where: WishlistProductWhereUniqueInput
  }

  /**
   * WishlistProduct findFirst
   */
  export type WishlistProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * Filter, which WishlistProduct to fetch.
     */
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     */
    orderBy?: WishlistProductOrderByWithRelationInput | WishlistProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistProducts.
     */
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistProducts.
     */
    distinct?: WishlistProductScalarFieldEnum | WishlistProductScalarFieldEnum[]
  }

  /**
   * WishlistProduct findFirstOrThrow
   */
  export type WishlistProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * Filter, which WishlistProduct to fetch.
     */
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     */
    orderBy?: WishlistProductOrderByWithRelationInput | WishlistProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistProducts.
     */
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistProducts.
     */
    distinct?: WishlistProductScalarFieldEnum | WishlistProductScalarFieldEnum[]
  }

  /**
   * WishlistProduct findMany
   */
  export type WishlistProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * Filter, which WishlistProducts to fetch.
     */
    where?: WishlistProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistProducts to fetch.
     */
    orderBy?: WishlistProductOrderByWithRelationInput | WishlistProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistProducts.
     */
    cursor?: WishlistProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistProducts.
     */
    skip?: number
    distinct?: WishlistProductScalarFieldEnum | WishlistProductScalarFieldEnum[]
  }

  /**
   * WishlistProduct create
   */
  export type WishlistProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistProduct.
     */
    data: XOR<WishlistProductCreateInput, WishlistProductUncheckedCreateInput>
  }

  /**
   * WishlistProduct createMany
   */
  export type WishlistProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistProducts.
     */
    data: WishlistProductCreateManyInput | WishlistProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishlistProduct createManyAndReturn
   */
  export type WishlistProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * The data used to create many WishlistProducts.
     */
    data: WishlistProductCreateManyInput | WishlistProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistProduct update
   */
  export type WishlistProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistProduct.
     */
    data: XOR<WishlistProductUpdateInput, WishlistProductUncheckedUpdateInput>
    /**
     * Choose, which WishlistProduct to update.
     */
    where: WishlistProductWhereUniqueInput
  }

  /**
   * WishlistProduct updateMany
   */
  export type WishlistProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistProducts.
     */
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyInput>
    /**
     * Filter which WishlistProducts to update
     */
    where?: WishlistProductWhereInput
    /**
     * Limit how many WishlistProducts to update.
     */
    limit?: number
  }

  /**
   * WishlistProduct updateManyAndReturn
   */
  export type WishlistProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * The data used to update WishlistProducts.
     */
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyInput>
    /**
     * Filter which WishlistProducts to update
     */
    where?: WishlistProductWhereInput
    /**
     * Limit how many WishlistProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistProduct upsert
   */
  export type WishlistProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistProduct to update in case it exists.
     */
    where: WishlistProductWhereUniqueInput
    /**
     * In case the WishlistProduct found by the `where` argument doesn't exist, create a new WishlistProduct with this data.
     */
    create: XOR<WishlistProductCreateInput, WishlistProductUncheckedCreateInput>
    /**
     * In case the WishlistProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistProductUpdateInput, WishlistProductUncheckedUpdateInput>
  }

  /**
   * WishlistProduct delete
   */
  export type WishlistProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
    /**
     * Filter which WishlistProduct to delete.
     */
    where: WishlistProductWhereUniqueInput
  }

  /**
   * WishlistProduct deleteMany
   */
  export type WishlistProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistProducts to delete
     */
    where?: WishlistProductWhereInput
    /**
     * Limit how many WishlistProducts to delete.
     */
    limit?: number
  }

  /**
   * WishlistProduct without action
   */
  export type WishlistProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistProduct
     */
    select?: WishlistProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistProduct
     */
    omit?: WishlistProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    productId: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    size: number | null
    productId: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isDisable: boolean | null
    isThumb: boolean | null
    productId: number | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    url: string | null
    thumbnailUrl: string | null
    width: number | null
    height: number | null
    size: number | null
    isDisable: boolean | null
    isThumb: boolean | null
    productId: number | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    createdAt: number
    url: number
    thumbnailUrl: number
    width: number
    height: number
    size: number
    isDisable: number
    isThumb: number
    productId: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    productId?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    size?: true
    productId?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isDisable?: true
    isThumb?: true
    productId?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isDisable?: true
    isThumb?: true
    productId?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    createdAt?: true
    url?: true
    thumbnailUrl?: true
    width?: true
    height?: true
    size?: true
    isDisable?: true
    isThumb?: true
    productId?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: number
    createdAt: Date
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable: boolean
    isThumb: boolean
    productId: number
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isDisable?: boolean
    isThumb?: boolean
    productId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isDisable?: boolean
    isThumb?: boolean
    productId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isDisable?: boolean
    isThumb?: boolean
    productId?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    width?: boolean
    height?: boolean
    size?: boolean
    isDisable?: boolean
    isThumb?: boolean
    productId?: boolean
  }

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "url" | "thumbnailUrl" | "width" | "height" | "size" | "isDisable" | "isThumb" | "productId", ExtArgs["result"]["productImage"]>
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      url: string
      thumbnailUrl: string
      width: number
      height: number
      size: number
      isDisable: boolean
      isThumb: boolean
      productId: number
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductImages and returns the data saved in the database.
     * @param {ProductImageCreateManyAndReturnArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages and returns the data updated in the database.
     * @param {ProductImageUpdateManyAndReturnArgs} args - Arguments to update many ProductImages.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'Int'>
    readonly createdAt: FieldRef<"ProductImage", 'DateTime'>
    readonly url: FieldRef<"ProductImage", 'String'>
    readonly thumbnailUrl: FieldRef<"ProductImage", 'String'>
    readonly width: FieldRef<"ProductImage", 'Int'>
    readonly height: FieldRef<"ProductImage", 'Int'>
    readonly size: FieldRef<"ProductImage", 'Int'>
    readonly isDisable: FieldRef<"ProductImage", 'Boolean'>
    readonly isThumb: FieldRef<"ProductImage", 'Boolean'>
    readonly productId: FieldRef<"ProductImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage createManyAndReturn
   */
  export type ProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImage updateManyAndReturn
   */
  export type ProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    loginId: 'loginId',
    loginPw: 'loginPw',
    username: 'username',
    loginType: 'loginType',
    userType: 'userType',
    nickname: 'nickname',
    email: 'email',
    isDisable: 'isDisable'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    content: 'content',
    link: 'link',
    userId: 'userId'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    content: 'content',
    link: 'link',
    startDay: 'startDay',
    endDay: 'endDay',
    isDisable: 'isDisable',
    isReplyAvaliable: 'isReplyAvaliable',
    userId: 'userId',
    boardType: 'boardType'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const BoardImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    width: 'width',
    height: 'height',
    size: 'size',
    isThumb: 'isThumb',
    isDisable: 'isDisable',
    boardId: 'boardId'
  };

  export type BoardImageScalarFieldEnum = (typeof BoardImageScalarFieldEnum)[keyof typeof BoardImageScalarFieldEnum]


  export const BoardReplyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    content: 'content',
    isDisable: 'isDisable',
    userId: 'userId',
    boardId: 'boardId',
    boardReplyId: 'boardReplyId'
  };

  export type BoardReplyScalarFieldEnum = (typeof BoardReplyScalarFieldEnum)[keyof typeof BoardReplyScalarFieldEnum]


  export const CafeBoardScalarFieldEnum: {
    boardId: 'boardId',
    cafeInfoId: 'cafeInfoId',
    createdAt: 'createdAt'
  };

  export type CafeBoardScalarFieldEnum = (typeof CafeBoardScalarFieldEnum)[keyof typeof CafeBoardScalarFieldEnum]


  export const RegionCategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    isDisable: 'isDisable',
    govermentType: 'govermentType'
  };

  export type RegionCategoryScalarFieldEnum = (typeof RegionCategoryScalarFieldEnum)[keyof typeof RegionCategoryScalarFieldEnum]


  export const ClosureRegionCategoryScalarFieldEnum: {
    ancestor: 'ancestor',
    descendant: 'descendant',
    depth: 'depth'
  };

  export type ClosureRegionCategoryScalarFieldEnum = (typeof ClosureRegionCategoryScalarFieldEnum)[keyof typeof ClosureRegionCategoryScalarFieldEnum]


  export const CafeInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isDisable: 'isDisable',
    name: 'name',
    code: 'code',
    regionCategoryId: 'regionCategoryId',
    address: 'address',
    directions: 'directions',
    businessNumber: 'businessNumber',
    ceoName: 'ceoName'
  };

  export type CafeInfoScalarFieldEnum = (typeof CafeInfoScalarFieldEnum)[keyof typeof CafeInfoScalarFieldEnum]


  export const CafeThumbnailImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    width: 'width',
    height: 'height',
    size: 'size',
    priority: 'priority',
    isDisable: 'isDisable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeThumbnailImageScalarFieldEnum = (typeof CafeThumbnailImageScalarFieldEnum)[keyof typeof CafeThumbnailImageScalarFieldEnum]


  export const CafeVirtualImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    width: 'width',
    height: 'height',
    size: 'size',
    priority: 'priority',
    isDisable: 'isDisable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeVirtualImageScalarFieldEnum = (typeof CafeVirtualImageScalarFieldEnum)[keyof typeof CafeVirtualImageScalarFieldEnum]


  export const CafeRealImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    width: 'width',
    height: 'height',
    size: 'size',
    priority: 'priority',
    isDisable: 'isDisable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeRealImageScalarFieldEnum = (typeof CafeRealImageScalarFieldEnum)[keyof typeof CafeRealImageScalarFieldEnum]


  export const CafeVirtualLinkScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    url: 'url',
    type: 'type',
    isDisable: 'isDisable',
    isAvaliable: 'isAvaliable',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeVirtualLinkScalarFieldEnum = (typeof CafeVirtualLinkScalarFieldEnum)[keyof typeof CafeVirtualLinkScalarFieldEnum]


  export const CafeVirtualLinkThumbnailImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    width: 'width',
    height: 'height',
    size: 'size',
    cafeVirtualLinkId: 'cafeVirtualLinkId'
  };

  export type CafeVirtualLinkThumbnailImageScalarFieldEnum = (typeof CafeVirtualLinkThumbnailImageScalarFieldEnum)[keyof typeof CafeVirtualLinkThumbnailImageScalarFieldEnum]


  export const CafeCouponGroupScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    code: 'code',
    name: 'name',
    tag: 'tag',
    description: 'description',
    isDisable: 'isDisable',
    startDay: 'startDay',
    endDay: 'endDay',
    issuanceStartDay: 'issuanceStartDay',
    issuanceEndDay: 'issuanceEndDay'
  };

  export type CafeCouponGroupScalarFieldEnum = (typeof CafeCouponGroupScalarFieldEnum)[keyof typeof CafeCouponGroupScalarFieldEnum]


  export const CafeCouponGoupPartnerScalarFieldEnum: {
    cafeCouponGroupId: 'cafeCouponGroupId',
    cafeInfoId: 'cafeInfoId'
  };

  export type CafeCouponGoupPartnerScalarFieldEnum = (typeof CafeCouponGoupPartnerScalarFieldEnum)[keyof typeof CafeCouponGoupPartnerScalarFieldEnum]


  export const ProxyUserScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    createdAt: 'createdAt',
    proxyUserType: 'proxyUserType',
    name: 'name',
    token: 'token',
    userId: 'userId'
  };

  export type ProxyUserScalarFieldEnum = (typeof ProxyUserScalarFieldEnum)[keyof typeof ProxyUserScalarFieldEnum]


  export const CafeCouponScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    content: 'content',
    serialNumber: 'serialNumber',
    startDay: 'startDay',
    endDay: 'endDay',
    isDisable: 'isDisable',
    proxyUserId: 'proxyUserId',
    cafeCouponGroupId: 'cafeCouponGroupId'
  };

  export type CafeCouponScalarFieldEnum = (typeof CafeCouponScalarFieldEnum)[keyof typeof CafeCouponScalarFieldEnum]


  export const CafeCouponHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    cafeCouponId: 'cafeCouponId',
    eventType: 'eventType',
    description: 'description',
    actorId: 'actorId',
    statusBefore: 'statusBefore',
    statusAfter: 'statusAfter'
  };

  export type CafeCouponHistoryScalarFieldEnum = (typeof CafeCouponHistoryScalarFieldEnum)[keyof typeof CafeCouponHistoryScalarFieldEnum]


  export const CafeCouponQRCodeScalarFieldEnum: {
    serialNumber: 'serialNumber',
    createdAt: 'createdAt',
    isDisable: 'isDisable',
    cafeCouponId: 'cafeCouponId',
    size: 'size',
    base64Data: 'base64Data'
  };

  export type CafeCouponQRCodeScalarFieldEnum = (typeof CafeCouponQRCodeScalarFieldEnum)[keyof typeof CafeCouponQRCodeScalarFieldEnum]


  export const MetaViewerInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    code: 'code',
    isDisable: 'isDisable',
    worldData: 'worldData',
    cafeInfoId: 'cafeInfoId'
  };

  export type MetaViewerInfoScalarFieldEnum = (typeof MetaViewerInfoScalarFieldEnum)[keyof typeof MetaViewerInfoScalarFieldEnum]


  export const MetaViewerMapScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    type: 'type',
    version: 'version',
    url: 'url',
    size: 'size',
    contentKey: 'contentKey',
    isDraco: 'isDraco',
    metaViewerInfoId: 'metaViewerInfoId'
  };

  export type MetaViewerMapScalarFieldEnum = (typeof MetaViewerMapScalarFieldEnum)[keyof typeof MetaViewerMapScalarFieldEnum]


  export const MetaViewerActiveMapScalarFieldEnum: {
    id: 'id',
    updatedAt: 'updatedAt',
    metaViewerInfoId: 'metaViewerInfoId',
    activeRenderMapId: 'activeRenderMapId',
    activeColliderMapId: 'activeColliderMapId'
  };

  export type MetaViewerActiveMapScalarFieldEnum = (typeof MetaViewerActiveMapScalarFieldEnum)[keyof typeof MetaViewerActiveMapScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    description: 'description',
    isDisable: 'isDisable',
    code: 'code'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ClosureProductCategoryScalarFieldEnum: {
    ancestor: 'ancestor',
    descendant: 'descendant',
    depth: 'depth'
  };

  export type ClosureProductCategoryScalarFieldEnum = (typeof ClosureProductCategoryScalarFieldEnum)[keyof typeof ClosureProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    code: 'code',
    description: 'description',
    price: 'price',
    originalPrice: 'originalPrice',
    stockQuantity: 'stockQuantity',
    minOrderQuantity: 'minOrderQuantity',
    isDisable: 'isDisable',
    isAvailable: 'isAvailable',
    categoryId: 'categoryId',
    cafeInfoId: 'cafeInfoId',
    productRedirectUrl: 'productRedirectUrl',
    isSignature: 'isSignature'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const WishlistProductScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    productId: 'productId',
    proxyUserId: 'proxyUserId'
  };

  export type WishlistProductScalarFieldEnum = (typeof WishlistProductScalarFieldEnum)[keyof typeof WishlistProductScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    width: 'width',
    height: 'height',
    size: 'size',
    isDisable: 'isDisable',
    isThumb: 'isThumb',
    productId: 'productId'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'LoginType'
   */
  export type EnumLoginTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginType'>
    


  /**
   * Reference to a field of type 'LoginType[]'
   */
  export type ListEnumLoginTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginType[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BoardType'
   */
  export type EnumBoardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BoardType'>
    


  /**
   * Reference to a field of type 'BoardType[]'
   */
  export type ListEnumBoardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BoardType[]'>
    


  /**
   * Reference to a field of type 'GovermentType'
   */
  export type EnumGovermentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GovermentType'>
    


  /**
   * Reference to a field of type 'GovermentType[]'
   */
  export type ListEnumGovermentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GovermentType[]'>
    


  /**
   * Reference to a field of type 'ProxyUserType'
   */
  export type EnumProxyUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProxyUserType'>
    


  /**
   * Reference to a field of type 'ProxyUserType[]'
   */
  export type ListEnumProxyUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProxyUserType[]'>
    


  /**
   * Reference to a field of type 'CafeCouponEventType'
   */
  export type EnumCafeCouponEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CafeCouponEventType'>
    


  /**
   * Reference to a field of type 'CafeCouponEventType[]'
   */
  export type ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CafeCouponEventType[]'>
    


  /**
   * Reference to a field of type 'CafeCouponStatus'
   */
  export type EnumCafeCouponStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CafeCouponStatus'>
    


  /**
   * Reference to a field of type 'CafeCouponStatus[]'
   */
  export type ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CafeCouponStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'MetaMapType'
   */
  export type EnumMetaMapTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetaMapType'>
    


  /**
   * Reference to a field of type 'MetaMapType[]'
   */
  export type ListEnumMetaMapTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetaMapType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    loginId?: StringFilter<"User"> | string
    loginPw?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    loginType?: EnumLoginTypeFilter<"User"> | $Enums.LoginType
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    nickname?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    isDisable?: BoolFilter<"User"> | boolean
    Boards?: BoardListRelationFilter
    BoardReplies?: BoardReplyListRelationFilter
    Notices?: NoticeListRelationFilter
    ProxyUsers?: ProxyUserListRelationFilter
    CafeCouponHistories?: CafeCouponHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrderInput | SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
    Boards?: BoardOrderByRelationAggregateInput
    BoardReplies?: BoardReplyOrderByRelationAggregateInput
    Notices?: NoticeOrderByRelationAggregateInput
    ProxyUsers?: ProxyUserOrderByRelationAggregateInput
    CafeCouponHistories?: CafeCouponHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    loginUnique?: UserLoginUniqueCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    loginId?: StringFilter<"User"> | string
    loginPw?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    loginType?: EnumLoginTypeFilter<"User"> | $Enums.LoginType
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    nickname?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    isDisable?: BoolFilter<"User"> | boolean
    Boards?: BoardListRelationFilter
    BoardReplies?: BoardReplyListRelationFilter
    Notices?: NoticeListRelationFilter
    ProxyUsers?: ProxyUserListRelationFilter
    CafeCouponHistories?: CafeCouponHistoryListRelationFilter
  }, "id" | "loginUnique">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrderInput | SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    loginId?: StringWithAggregatesFilter<"User"> | string
    loginPw?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    loginType?: EnumLoginTypeWithAggregatesFilter<"User"> | $Enums.LoginType
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    nickname?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    isDisable?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    title?: StringFilter<"Notice"> | string
    content?: StringNullableFilter<"Notice"> | string | null
    link?: StringNullableFilter<"Notice"> | string | null
    userId?: IntFilter<"Notice"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    title?: StringFilter<"Notice"> | string
    content?: StringNullableFilter<"Notice"> | string | null
    link?: StringNullableFilter<"Notice"> | string | null
    userId?: IntFilter<"Notice"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    title?: StringWithAggregatesFilter<"Notice"> | string
    content?: StringNullableWithAggregatesFilter<"Notice"> | string | null
    link?: StringNullableWithAggregatesFilter<"Notice"> | string | null
    userId?: IntWithAggregatesFilter<"Notice"> | number
  }

  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: IntFilter<"Board"> | number
    createdAt?: DateTimeFilter<"Board"> | Date | string
    title?: StringFilter<"Board"> | string
    content?: StringNullableFilter<"Board"> | string | null
    link?: StringNullableFilter<"Board"> | string | null
    startDay?: DateTimeFilter<"Board"> | Date | string
    endDay?: DateTimeNullableFilter<"Board"> | Date | string | null
    isDisable?: BoolFilter<"Board"> | boolean
    isReplyAvaliable?: BoolFilter<"Board"> | boolean
    userId?: IntFilter<"Board"> | number
    boardType?: EnumBoardTypeFilter<"Board"> | $Enums.BoardType
    BoardImages?: BoardImageListRelationFilter
    BoardReplies?: BoardReplyListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    CafeBoards?: CafeBoardListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    startDay?: SortOrder
    endDay?: SortOrderInput | SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
    BoardImages?: BoardImageOrderByRelationAggregateInput
    BoardReplies?: BoardReplyOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    CafeBoards?: CafeBoardOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    createdAt?: DateTimeFilter<"Board"> | Date | string
    title?: StringFilter<"Board"> | string
    content?: StringNullableFilter<"Board"> | string | null
    link?: StringNullableFilter<"Board"> | string | null
    startDay?: DateTimeFilter<"Board"> | Date | string
    endDay?: DateTimeNullableFilter<"Board"> | Date | string | null
    isDisable?: BoolFilter<"Board"> | boolean
    isReplyAvaliable?: BoolFilter<"Board"> | boolean
    userId?: IntFilter<"Board"> | number
    boardType?: EnumBoardTypeFilter<"Board"> | $Enums.BoardType
    BoardImages?: BoardImageListRelationFilter
    BoardReplies?: BoardReplyListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    CafeBoards?: CafeBoardListRelationFilter
  }, "id">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    startDay?: SortOrder
    endDay?: SortOrderInput | SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _avg?: BoardAvgOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
    _sum?: BoardSumOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Board"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    title?: StringWithAggregatesFilter<"Board"> | string
    content?: StringNullableWithAggregatesFilter<"Board"> | string | null
    link?: StringNullableWithAggregatesFilter<"Board"> | string | null
    startDay?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    endDay?: DateTimeNullableWithAggregatesFilter<"Board"> | Date | string | null
    isDisable?: BoolWithAggregatesFilter<"Board"> | boolean
    isReplyAvaliable?: BoolWithAggregatesFilter<"Board"> | boolean
    userId?: IntWithAggregatesFilter<"Board"> | number
    boardType?: EnumBoardTypeWithAggregatesFilter<"Board"> | $Enums.BoardType
  }

  export type BoardImageWhereInput = {
    AND?: BoardImageWhereInput | BoardImageWhereInput[]
    OR?: BoardImageWhereInput[]
    NOT?: BoardImageWhereInput | BoardImageWhereInput[]
    id?: IntFilter<"BoardImage"> | number
    createdAt?: DateTimeFilter<"BoardImage"> | Date | string
    url?: StringFilter<"BoardImage"> | string
    thumbnailUrl?: StringFilter<"BoardImage"> | string
    width?: IntFilter<"BoardImage"> | number
    height?: IntFilter<"BoardImage"> | number
    size?: IntFilter<"BoardImage"> | number
    isThumb?: BoolFilter<"BoardImage"> | boolean
    isDisable?: BoolFilter<"BoardImage"> | boolean
    boardId?: IntFilter<"BoardImage"> | number
    Board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
  }

  export type BoardImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
    Board?: BoardOrderByWithRelationInput
  }

  export type BoardImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BoardImageWhereInput | BoardImageWhereInput[]
    OR?: BoardImageWhereInput[]
    NOT?: BoardImageWhereInput | BoardImageWhereInput[]
    createdAt?: DateTimeFilter<"BoardImage"> | Date | string
    url?: StringFilter<"BoardImage"> | string
    thumbnailUrl?: StringFilter<"BoardImage"> | string
    width?: IntFilter<"BoardImage"> | number
    height?: IntFilter<"BoardImage"> | number
    size?: IntFilter<"BoardImage"> | number
    isThumb?: BoolFilter<"BoardImage"> | boolean
    isDisable?: BoolFilter<"BoardImage"> | boolean
    boardId?: IntFilter<"BoardImage"> | number
    Board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
  }, "id">

  export type BoardImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
    _count?: BoardImageCountOrderByAggregateInput
    _avg?: BoardImageAvgOrderByAggregateInput
    _max?: BoardImageMaxOrderByAggregateInput
    _min?: BoardImageMinOrderByAggregateInput
    _sum?: BoardImageSumOrderByAggregateInput
  }

  export type BoardImageScalarWhereWithAggregatesInput = {
    AND?: BoardImageScalarWhereWithAggregatesInput | BoardImageScalarWhereWithAggregatesInput[]
    OR?: BoardImageScalarWhereWithAggregatesInput[]
    NOT?: BoardImageScalarWhereWithAggregatesInput | BoardImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BoardImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BoardImage"> | Date | string
    url?: StringWithAggregatesFilter<"BoardImage"> | string
    thumbnailUrl?: StringWithAggregatesFilter<"BoardImage"> | string
    width?: IntWithAggregatesFilter<"BoardImage"> | number
    height?: IntWithAggregatesFilter<"BoardImage"> | number
    size?: IntWithAggregatesFilter<"BoardImage"> | number
    isThumb?: BoolWithAggregatesFilter<"BoardImage"> | boolean
    isDisable?: BoolWithAggregatesFilter<"BoardImage"> | boolean
    boardId?: IntWithAggregatesFilter<"BoardImage"> | number
  }

  export type BoardReplyWhereInput = {
    AND?: BoardReplyWhereInput | BoardReplyWhereInput[]
    OR?: BoardReplyWhereInput[]
    NOT?: BoardReplyWhereInput | BoardReplyWhereInput[]
    id?: IntFilter<"BoardReply"> | number
    createdAt?: DateTimeFilter<"BoardReply"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BoardReply"> | Date | string | null
    content?: StringFilter<"BoardReply"> | string
    isDisable?: BoolFilter<"BoardReply"> | boolean
    userId?: IntFilter<"BoardReply"> | number
    boardId?: IntFilter<"BoardReply"> | number
    boardReplyId?: IntNullableFilter<"BoardReply"> | number | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    BoardReply?: XOR<BoardReplyNullableScalarRelationFilter, BoardReplyWhereInput> | null
    BoardNestedReplies?: BoardReplyListRelationFilter
  }

  export type BoardReplyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    Board?: BoardOrderByWithRelationInput
    BoardReply?: BoardReplyOrderByWithRelationInput
    BoardNestedReplies?: BoardReplyOrderByRelationAggregateInput
  }

  export type BoardReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BoardReplyWhereInput | BoardReplyWhereInput[]
    OR?: BoardReplyWhereInput[]
    NOT?: BoardReplyWhereInput | BoardReplyWhereInput[]
    createdAt?: DateTimeFilter<"BoardReply"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BoardReply"> | Date | string | null
    content?: StringFilter<"BoardReply"> | string
    isDisable?: BoolFilter<"BoardReply"> | boolean
    userId?: IntFilter<"BoardReply"> | number
    boardId?: IntFilter<"BoardReply"> | number
    boardReplyId?: IntNullableFilter<"BoardReply"> | number | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    BoardReply?: XOR<BoardReplyNullableScalarRelationFilter, BoardReplyWhereInput> | null
    BoardNestedReplies?: BoardReplyListRelationFilter
  }, "id">

  export type BoardReplyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrderInput | SortOrder
    _count?: BoardReplyCountOrderByAggregateInput
    _avg?: BoardReplyAvgOrderByAggregateInput
    _max?: BoardReplyMaxOrderByAggregateInput
    _min?: BoardReplyMinOrderByAggregateInput
    _sum?: BoardReplySumOrderByAggregateInput
  }

  export type BoardReplyScalarWhereWithAggregatesInput = {
    AND?: BoardReplyScalarWhereWithAggregatesInput | BoardReplyScalarWhereWithAggregatesInput[]
    OR?: BoardReplyScalarWhereWithAggregatesInput[]
    NOT?: BoardReplyScalarWhereWithAggregatesInput | BoardReplyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BoardReply"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BoardReply"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BoardReply"> | Date | string | null
    content?: StringWithAggregatesFilter<"BoardReply"> | string
    isDisable?: BoolWithAggregatesFilter<"BoardReply"> | boolean
    userId?: IntWithAggregatesFilter<"BoardReply"> | number
    boardId?: IntWithAggregatesFilter<"BoardReply"> | number
    boardReplyId?: IntNullableWithAggregatesFilter<"BoardReply"> | number | null
  }

  export type CafeBoardWhereInput = {
    AND?: CafeBoardWhereInput | CafeBoardWhereInput[]
    OR?: CafeBoardWhereInput[]
    NOT?: CafeBoardWhereInput | CafeBoardWhereInput[]
    boardId?: IntFilter<"CafeBoard"> | number
    cafeInfoId?: IntFilter<"CafeBoard"> | number
    createdAt?: DateTimeFilter<"CafeBoard"> | Date | string
    Board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }

  export type CafeBoardOrderByWithRelationInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
    Board?: BoardOrderByWithRelationInput
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeBoardWhereUniqueInput = Prisma.AtLeast<{
    cafeBoardUnique?: CafeBoardCafeBoardUniqueCompoundUniqueInput
    AND?: CafeBoardWhereInput | CafeBoardWhereInput[]
    OR?: CafeBoardWhereInput[]
    NOT?: CafeBoardWhereInput | CafeBoardWhereInput[]
    boardId?: IntFilter<"CafeBoard"> | number
    cafeInfoId?: IntFilter<"CafeBoard"> | number
    createdAt?: DateTimeFilter<"CafeBoard"> | Date | string
    Board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }, "cafeBoardUnique">

  export type CafeBoardOrderByWithAggregationInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
    _count?: CafeBoardCountOrderByAggregateInput
    _avg?: CafeBoardAvgOrderByAggregateInput
    _max?: CafeBoardMaxOrderByAggregateInput
    _min?: CafeBoardMinOrderByAggregateInput
    _sum?: CafeBoardSumOrderByAggregateInput
  }

  export type CafeBoardScalarWhereWithAggregatesInput = {
    AND?: CafeBoardScalarWhereWithAggregatesInput | CafeBoardScalarWhereWithAggregatesInput[]
    OR?: CafeBoardScalarWhereWithAggregatesInput[]
    NOT?: CafeBoardScalarWhereWithAggregatesInput | CafeBoardScalarWhereWithAggregatesInput[]
    boardId?: IntWithAggregatesFilter<"CafeBoard"> | number
    cafeInfoId?: IntWithAggregatesFilter<"CafeBoard"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeBoard"> | Date | string
  }

  export type RegionCategoryWhereInput = {
    AND?: RegionCategoryWhereInput | RegionCategoryWhereInput[]
    OR?: RegionCategoryWhereInput[]
    NOT?: RegionCategoryWhereInput | RegionCategoryWhereInput[]
    id?: IntFilter<"RegionCategory"> | number
    createdAt?: DateTimeFilter<"RegionCategory"> | Date | string
    name?: StringFilter<"RegionCategory"> | string
    isDisable?: BoolFilter<"RegionCategory"> | boolean
    govermentType?: EnumGovermentTypeFilter<"RegionCategory"> | $Enums.GovermentType
    CafeInfos?: CafeInfoListRelationFilter
    AncestorCategories?: ClosureRegionCategoryListRelationFilter
    DescendantCategories?: ClosureRegionCategoryListRelationFilter
  }

  export type RegionCategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
    CafeInfos?: CafeInfoOrderByRelationAggregateInput
    AncestorCategories?: ClosureRegionCategoryOrderByRelationAggregateInput
    DescendantCategories?: ClosureRegionCategoryOrderByRelationAggregateInput
  }

  export type RegionCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionCategoryWhereInput | RegionCategoryWhereInput[]
    OR?: RegionCategoryWhereInput[]
    NOT?: RegionCategoryWhereInput | RegionCategoryWhereInput[]
    createdAt?: DateTimeFilter<"RegionCategory"> | Date | string
    name?: StringFilter<"RegionCategory"> | string
    isDisable?: BoolFilter<"RegionCategory"> | boolean
    govermentType?: EnumGovermentTypeFilter<"RegionCategory"> | $Enums.GovermentType
    CafeInfos?: CafeInfoListRelationFilter
    AncestorCategories?: ClosureRegionCategoryListRelationFilter
    DescendantCategories?: ClosureRegionCategoryListRelationFilter
  }, "id">

  export type RegionCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
    _count?: RegionCategoryCountOrderByAggregateInput
    _avg?: RegionCategoryAvgOrderByAggregateInput
    _max?: RegionCategoryMaxOrderByAggregateInput
    _min?: RegionCategoryMinOrderByAggregateInput
    _sum?: RegionCategorySumOrderByAggregateInput
  }

  export type RegionCategoryScalarWhereWithAggregatesInput = {
    AND?: RegionCategoryScalarWhereWithAggregatesInput | RegionCategoryScalarWhereWithAggregatesInput[]
    OR?: RegionCategoryScalarWhereWithAggregatesInput[]
    NOT?: RegionCategoryScalarWhereWithAggregatesInput | RegionCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegionCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RegionCategory"> | Date | string
    name?: StringWithAggregatesFilter<"RegionCategory"> | string
    isDisable?: BoolWithAggregatesFilter<"RegionCategory"> | boolean
    govermentType?: EnumGovermentTypeWithAggregatesFilter<"RegionCategory"> | $Enums.GovermentType
  }

  export type ClosureRegionCategoryWhereInput = {
    AND?: ClosureRegionCategoryWhereInput | ClosureRegionCategoryWhereInput[]
    OR?: ClosureRegionCategoryWhereInput[]
    NOT?: ClosureRegionCategoryWhereInput | ClosureRegionCategoryWhereInput[]
    ancestor?: IntFilter<"ClosureRegionCategory"> | number
    descendant?: IntFilter<"ClosureRegionCategory"> | number
    depth?: IntFilter<"ClosureRegionCategory"> | number
    AncestorCategory?: XOR<RegionCategoryScalarRelationFilter, RegionCategoryWhereInput>
    DescendantCategory?: XOR<RegionCategoryScalarRelationFilter, RegionCategoryWhereInput>
  }

  export type ClosureRegionCategoryOrderByWithRelationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    AncestorCategory?: RegionCategoryOrderByWithRelationInput
    DescendantCategory?: RegionCategoryOrderByWithRelationInput
  }

  export type ClosureRegionCategoryWhereUniqueInput = Prisma.AtLeast<{
    regionCategoryTreeUnique?: ClosureRegionCategoryRegionCategoryTreeUniqueCompoundUniqueInput
    AND?: ClosureRegionCategoryWhereInput | ClosureRegionCategoryWhereInput[]
    OR?: ClosureRegionCategoryWhereInput[]
    NOT?: ClosureRegionCategoryWhereInput | ClosureRegionCategoryWhereInput[]
    ancestor?: IntFilter<"ClosureRegionCategory"> | number
    descendant?: IntFilter<"ClosureRegionCategory"> | number
    depth?: IntFilter<"ClosureRegionCategory"> | number
    AncestorCategory?: XOR<RegionCategoryScalarRelationFilter, RegionCategoryWhereInput>
    DescendantCategory?: XOR<RegionCategoryScalarRelationFilter, RegionCategoryWhereInput>
  }, "regionCategoryTreeUnique">

  export type ClosureRegionCategoryOrderByWithAggregationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    _count?: ClosureRegionCategoryCountOrderByAggregateInput
    _avg?: ClosureRegionCategoryAvgOrderByAggregateInput
    _max?: ClosureRegionCategoryMaxOrderByAggregateInput
    _min?: ClosureRegionCategoryMinOrderByAggregateInput
    _sum?: ClosureRegionCategorySumOrderByAggregateInput
  }

  export type ClosureRegionCategoryScalarWhereWithAggregatesInput = {
    AND?: ClosureRegionCategoryScalarWhereWithAggregatesInput | ClosureRegionCategoryScalarWhereWithAggregatesInput[]
    OR?: ClosureRegionCategoryScalarWhereWithAggregatesInput[]
    NOT?: ClosureRegionCategoryScalarWhereWithAggregatesInput | ClosureRegionCategoryScalarWhereWithAggregatesInput[]
    ancestor?: IntWithAggregatesFilter<"ClosureRegionCategory"> | number
    descendant?: IntWithAggregatesFilter<"ClosureRegionCategory"> | number
    depth?: IntWithAggregatesFilter<"ClosureRegionCategory"> | number
  }

  export type CafeInfoWhereInput = {
    AND?: CafeInfoWhereInput | CafeInfoWhereInput[]
    OR?: CafeInfoWhereInput[]
    NOT?: CafeInfoWhereInput | CafeInfoWhereInput[]
    id?: IntFilter<"CafeInfo"> | number
    createdAt?: DateTimeFilter<"CafeInfo"> | Date | string
    isDisable?: BoolFilter<"CafeInfo"> | boolean
    name?: StringFilter<"CafeInfo"> | string
    code?: StringNullableFilter<"CafeInfo"> | string | null
    regionCategoryId?: IntFilter<"CafeInfo"> | number
    address?: StringFilter<"CafeInfo"> | string
    directions?: StringFilter<"CafeInfo"> | string
    businessNumber?: StringFilter<"CafeInfo"> | string
    ceoName?: StringFilter<"CafeInfo"> | string
    RegionCategory?: XOR<RegionCategoryScalarRelationFilter, RegionCategoryWhereInput>
    CafeVirtualLinks?: CafeVirtualLinkListRelationFilter
    CafeThumbnailImages?: CafeThumbnailImageListRelationFilter
    CafeVirtualImages?: CafeVirtualImageListRelationFilter
    CafeRealImages?: CafeRealImageListRelationFilter
    CafeCouponGroupPartners?: CafeCouponGoupPartnerListRelationFilter
    CafeBoards?: CafeBoardListRelationFilter
    MetaViewerInfos?: MetaViewerInfoListRelationFilter
    Products?: ProductListRelationFilter
  }

  export type CafeInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
    RegionCategory?: RegionCategoryOrderByWithRelationInput
    CafeVirtualLinks?: CafeVirtualLinkOrderByRelationAggregateInput
    CafeThumbnailImages?: CafeThumbnailImageOrderByRelationAggregateInput
    CafeVirtualImages?: CafeVirtualImageOrderByRelationAggregateInput
    CafeRealImages?: CafeRealImageOrderByRelationAggregateInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerOrderByRelationAggregateInput
    CafeBoards?: CafeBoardOrderByRelationAggregateInput
    MetaViewerInfos?: MetaViewerInfoOrderByRelationAggregateInput
    Products?: ProductOrderByRelationAggregateInput
  }

  export type CafeInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CafeInfoWhereInput | CafeInfoWhereInput[]
    OR?: CafeInfoWhereInput[]
    NOT?: CafeInfoWhereInput | CafeInfoWhereInput[]
    createdAt?: DateTimeFilter<"CafeInfo"> | Date | string
    isDisable?: BoolFilter<"CafeInfo"> | boolean
    name?: StringFilter<"CafeInfo"> | string
    regionCategoryId?: IntFilter<"CafeInfo"> | number
    address?: StringFilter<"CafeInfo"> | string
    directions?: StringFilter<"CafeInfo"> | string
    businessNumber?: StringFilter<"CafeInfo"> | string
    ceoName?: StringFilter<"CafeInfo"> | string
    RegionCategory?: XOR<RegionCategoryScalarRelationFilter, RegionCategoryWhereInput>
    CafeVirtualLinks?: CafeVirtualLinkListRelationFilter
    CafeThumbnailImages?: CafeThumbnailImageListRelationFilter
    CafeVirtualImages?: CafeVirtualImageListRelationFilter
    CafeRealImages?: CafeRealImageListRelationFilter
    CafeCouponGroupPartners?: CafeCouponGoupPartnerListRelationFilter
    CafeBoards?: CafeBoardListRelationFilter
    MetaViewerInfos?: MetaViewerInfoListRelationFilter
    Products?: ProductListRelationFilter
  }, "id" | "code">

  export type CafeInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
    _count?: CafeInfoCountOrderByAggregateInput
    _avg?: CafeInfoAvgOrderByAggregateInput
    _max?: CafeInfoMaxOrderByAggregateInput
    _min?: CafeInfoMinOrderByAggregateInput
    _sum?: CafeInfoSumOrderByAggregateInput
  }

  export type CafeInfoScalarWhereWithAggregatesInput = {
    AND?: CafeInfoScalarWhereWithAggregatesInput | CafeInfoScalarWhereWithAggregatesInput[]
    OR?: CafeInfoScalarWhereWithAggregatesInput[]
    NOT?: CafeInfoScalarWhereWithAggregatesInput | CafeInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeInfo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeInfo"> | Date | string
    isDisable?: BoolWithAggregatesFilter<"CafeInfo"> | boolean
    name?: StringWithAggregatesFilter<"CafeInfo"> | string
    code?: StringNullableWithAggregatesFilter<"CafeInfo"> | string | null
    regionCategoryId?: IntWithAggregatesFilter<"CafeInfo"> | number
    address?: StringWithAggregatesFilter<"CafeInfo"> | string
    directions?: StringWithAggregatesFilter<"CafeInfo"> | string
    businessNumber?: StringWithAggregatesFilter<"CafeInfo"> | string
    ceoName?: StringWithAggregatesFilter<"CafeInfo"> | string
  }

  export type CafeThumbnailImageWhereInput = {
    AND?: CafeThumbnailImageWhereInput | CafeThumbnailImageWhereInput[]
    OR?: CafeThumbnailImageWhereInput[]
    NOT?: CafeThumbnailImageWhereInput | CafeThumbnailImageWhereInput[]
    id?: IntFilter<"CafeThumbnailImage"> | number
    createdAt?: DateTimeFilter<"CafeThumbnailImage"> | Date | string
    url?: StringFilter<"CafeThumbnailImage"> | string
    thumbnailUrl?: StringFilter<"CafeThumbnailImage"> | string
    width?: IntFilter<"CafeThumbnailImage"> | number
    height?: IntFilter<"CafeThumbnailImage"> | number
    size?: IntFilter<"CafeThumbnailImage"> | number
    priority?: IntFilter<"CafeThumbnailImage"> | number
    isDisable?: BoolFilter<"CafeThumbnailImage"> | boolean
    cafeInfoId?: IntFilter<"CafeThumbnailImage"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }

  export type CafeThumbnailImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeThumbnailImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CafeThumbnailImageWhereInput | CafeThumbnailImageWhereInput[]
    OR?: CafeThumbnailImageWhereInput[]
    NOT?: CafeThumbnailImageWhereInput | CafeThumbnailImageWhereInput[]
    createdAt?: DateTimeFilter<"CafeThumbnailImage"> | Date | string
    url?: StringFilter<"CafeThumbnailImage"> | string
    thumbnailUrl?: StringFilter<"CafeThumbnailImage"> | string
    width?: IntFilter<"CafeThumbnailImage"> | number
    height?: IntFilter<"CafeThumbnailImage"> | number
    size?: IntFilter<"CafeThumbnailImage"> | number
    priority?: IntFilter<"CafeThumbnailImage"> | number
    isDisable?: BoolFilter<"CafeThumbnailImage"> | boolean
    cafeInfoId?: IntFilter<"CafeThumbnailImage"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }, "id">

  export type CafeThumbnailImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeThumbnailImageCountOrderByAggregateInput
    _avg?: CafeThumbnailImageAvgOrderByAggregateInput
    _max?: CafeThumbnailImageMaxOrderByAggregateInput
    _min?: CafeThumbnailImageMinOrderByAggregateInput
    _sum?: CafeThumbnailImageSumOrderByAggregateInput
  }

  export type CafeThumbnailImageScalarWhereWithAggregatesInput = {
    AND?: CafeThumbnailImageScalarWhereWithAggregatesInput | CafeThumbnailImageScalarWhereWithAggregatesInput[]
    OR?: CafeThumbnailImageScalarWhereWithAggregatesInput[]
    NOT?: CafeThumbnailImageScalarWhereWithAggregatesInput | CafeThumbnailImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeThumbnailImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeThumbnailImage"> | Date | string
    url?: StringWithAggregatesFilter<"CafeThumbnailImage"> | string
    thumbnailUrl?: StringWithAggregatesFilter<"CafeThumbnailImage"> | string
    width?: IntWithAggregatesFilter<"CafeThumbnailImage"> | number
    height?: IntWithAggregatesFilter<"CafeThumbnailImage"> | number
    size?: IntWithAggregatesFilter<"CafeThumbnailImage"> | number
    priority?: IntWithAggregatesFilter<"CafeThumbnailImage"> | number
    isDisable?: BoolWithAggregatesFilter<"CafeThumbnailImage"> | boolean
    cafeInfoId?: IntWithAggregatesFilter<"CafeThumbnailImage"> | number
  }

  export type CafeVirtualImageWhereInput = {
    AND?: CafeVirtualImageWhereInput | CafeVirtualImageWhereInput[]
    OR?: CafeVirtualImageWhereInput[]
    NOT?: CafeVirtualImageWhereInput | CafeVirtualImageWhereInput[]
    id?: IntFilter<"CafeVirtualImage"> | number
    createdAt?: DateTimeFilter<"CafeVirtualImage"> | Date | string
    url?: StringFilter<"CafeVirtualImage"> | string
    width?: IntFilter<"CafeVirtualImage"> | number
    height?: IntFilter<"CafeVirtualImage"> | number
    size?: IntFilter<"CafeVirtualImage"> | number
    priority?: IntFilter<"CafeVirtualImage"> | number
    isDisable?: BoolFilter<"CafeVirtualImage"> | boolean
    cafeInfoId?: IntFilter<"CafeVirtualImage"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }

  export type CafeVirtualImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeVirtualImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CafeVirtualImageWhereInput | CafeVirtualImageWhereInput[]
    OR?: CafeVirtualImageWhereInput[]
    NOT?: CafeVirtualImageWhereInput | CafeVirtualImageWhereInput[]
    createdAt?: DateTimeFilter<"CafeVirtualImage"> | Date | string
    url?: StringFilter<"CafeVirtualImage"> | string
    width?: IntFilter<"CafeVirtualImage"> | number
    height?: IntFilter<"CafeVirtualImage"> | number
    size?: IntFilter<"CafeVirtualImage"> | number
    priority?: IntFilter<"CafeVirtualImage"> | number
    isDisable?: BoolFilter<"CafeVirtualImage"> | boolean
    cafeInfoId?: IntFilter<"CafeVirtualImage"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }, "id">

  export type CafeVirtualImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeVirtualImageCountOrderByAggregateInput
    _avg?: CafeVirtualImageAvgOrderByAggregateInput
    _max?: CafeVirtualImageMaxOrderByAggregateInput
    _min?: CafeVirtualImageMinOrderByAggregateInput
    _sum?: CafeVirtualImageSumOrderByAggregateInput
  }

  export type CafeVirtualImageScalarWhereWithAggregatesInput = {
    AND?: CafeVirtualImageScalarWhereWithAggregatesInput | CafeVirtualImageScalarWhereWithAggregatesInput[]
    OR?: CafeVirtualImageScalarWhereWithAggregatesInput[]
    NOT?: CafeVirtualImageScalarWhereWithAggregatesInput | CafeVirtualImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeVirtualImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeVirtualImage"> | Date | string
    url?: StringWithAggregatesFilter<"CafeVirtualImage"> | string
    width?: IntWithAggregatesFilter<"CafeVirtualImage"> | number
    height?: IntWithAggregatesFilter<"CafeVirtualImage"> | number
    size?: IntWithAggregatesFilter<"CafeVirtualImage"> | number
    priority?: IntWithAggregatesFilter<"CafeVirtualImage"> | number
    isDisable?: BoolWithAggregatesFilter<"CafeVirtualImage"> | boolean
    cafeInfoId?: IntWithAggregatesFilter<"CafeVirtualImage"> | number
  }

  export type CafeRealImageWhereInput = {
    AND?: CafeRealImageWhereInput | CafeRealImageWhereInput[]
    OR?: CafeRealImageWhereInput[]
    NOT?: CafeRealImageWhereInput | CafeRealImageWhereInput[]
    id?: IntFilter<"CafeRealImage"> | number
    createdAt?: DateTimeFilter<"CafeRealImage"> | Date | string
    url?: StringFilter<"CafeRealImage"> | string
    width?: IntFilter<"CafeRealImage"> | number
    height?: IntFilter<"CafeRealImage"> | number
    size?: IntFilter<"CafeRealImage"> | number
    priority?: IntFilter<"CafeRealImage"> | number
    isDisable?: BoolFilter<"CafeRealImage"> | boolean
    cafeInfoId?: IntFilter<"CafeRealImage"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }

  export type CafeRealImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeRealImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CafeRealImageWhereInput | CafeRealImageWhereInput[]
    OR?: CafeRealImageWhereInput[]
    NOT?: CafeRealImageWhereInput | CafeRealImageWhereInput[]
    createdAt?: DateTimeFilter<"CafeRealImage"> | Date | string
    url?: StringFilter<"CafeRealImage"> | string
    width?: IntFilter<"CafeRealImage"> | number
    height?: IntFilter<"CafeRealImage"> | number
    size?: IntFilter<"CafeRealImage"> | number
    priority?: IntFilter<"CafeRealImage"> | number
    isDisable?: BoolFilter<"CafeRealImage"> | boolean
    cafeInfoId?: IntFilter<"CafeRealImage"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }, "id">

  export type CafeRealImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeRealImageCountOrderByAggregateInput
    _avg?: CafeRealImageAvgOrderByAggregateInput
    _max?: CafeRealImageMaxOrderByAggregateInput
    _min?: CafeRealImageMinOrderByAggregateInput
    _sum?: CafeRealImageSumOrderByAggregateInput
  }

  export type CafeRealImageScalarWhereWithAggregatesInput = {
    AND?: CafeRealImageScalarWhereWithAggregatesInput | CafeRealImageScalarWhereWithAggregatesInput[]
    OR?: CafeRealImageScalarWhereWithAggregatesInput[]
    NOT?: CafeRealImageScalarWhereWithAggregatesInput | CafeRealImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeRealImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeRealImage"> | Date | string
    url?: StringWithAggregatesFilter<"CafeRealImage"> | string
    width?: IntWithAggregatesFilter<"CafeRealImage"> | number
    height?: IntWithAggregatesFilter<"CafeRealImage"> | number
    size?: IntWithAggregatesFilter<"CafeRealImage"> | number
    priority?: IntWithAggregatesFilter<"CafeRealImage"> | number
    isDisable?: BoolWithAggregatesFilter<"CafeRealImage"> | boolean
    cafeInfoId?: IntWithAggregatesFilter<"CafeRealImage"> | number
  }

  export type CafeVirtualLinkWhereInput = {
    AND?: CafeVirtualLinkWhereInput | CafeVirtualLinkWhereInput[]
    OR?: CafeVirtualLinkWhereInput[]
    NOT?: CafeVirtualLinkWhereInput | CafeVirtualLinkWhereInput[]
    id?: IntFilter<"CafeVirtualLink"> | number
    createdAt?: DateTimeFilter<"CafeVirtualLink"> | Date | string
    name?: StringFilter<"CafeVirtualLink"> | string
    url?: StringFilter<"CafeVirtualLink"> | string
    type?: StringFilter<"CafeVirtualLink"> | string
    isDisable?: BoolFilter<"CafeVirtualLink"> | boolean
    isAvaliable?: BoolFilter<"CafeVirtualLink"> | boolean
    cafeInfoId?: IntFilter<"CafeVirtualLink"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
    CafeVirtualLinkThumbnailImage?: XOR<CafeVirtualLinkThumbnailImageNullableScalarRelationFilter, CafeVirtualLinkThumbnailImageWhereInput> | null
  }

  export type CafeVirtualLinkOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageOrderByWithRelationInput
  }

  export type CafeVirtualLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CafeVirtualLinkWhereInput | CafeVirtualLinkWhereInput[]
    OR?: CafeVirtualLinkWhereInput[]
    NOT?: CafeVirtualLinkWhereInput | CafeVirtualLinkWhereInput[]
    createdAt?: DateTimeFilter<"CafeVirtualLink"> | Date | string
    name?: StringFilter<"CafeVirtualLink"> | string
    url?: StringFilter<"CafeVirtualLink"> | string
    type?: StringFilter<"CafeVirtualLink"> | string
    isDisable?: BoolFilter<"CafeVirtualLink"> | boolean
    isAvaliable?: BoolFilter<"CafeVirtualLink"> | boolean
    cafeInfoId?: IntFilter<"CafeVirtualLink"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
    CafeVirtualLinkThumbnailImage?: XOR<CafeVirtualLinkThumbnailImageNullableScalarRelationFilter, CafeVirtualLinkThumbnailImageWhereInput> | null
  }, "id">

  export type CafeVirtualLinkOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeVirtualLinkCountOrderByAggregateInput
    _avg?: CafeVirtualLinkAvgOrderByAggregateInput
    _max?: CafeVirtualLinkMaxOrderByAggregateInput
    _min?: CafeVirtualLinkMinOrderByAggregateInput
    _sum?: CafeVirtualLinkSumOrderByAggregateInput
  }

  export type CafeVirtualLinkScalarWhereWithAggregatesInput = {
    AND?: CafeVirtualLinkScalarWhereWithAggregatesInput | CafeVirtualLinkScalarWhereWithAggregatesInput[]
    OR?: CafeVirtualLinkScalarWhereWithAggregatesInput[]
    NOT?: CafeVirtualLinkScalarWhereWithAggregatesInput | CafeVirtualLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeVirtualLink"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeVirtualLink"> | Date | string
    name?: StringWithAggregatesFilter<"CafeVirtualLink"> | string
    url?: StringWithAggregatesFilter<"CafeVirtualLink"> | string
    type?: StringWithAggregatesFilter<"CafeVirtualLink"> | string
    isDisable?: BoolWithAggregatesFilter<"CafeVirtualLink"> | boolean
    isAvaliable?: BoolWithAggregatesFilter<"CafeVirtualLink"> | boolean
    cafeInfoId?: IntWithAggregatesFilter<"CafeVirtualLink"> | number
  }

  export type CafeVirtualLinkThumbnailImageWhereInput = {
    AND?: CafeVirtualLinkThumbnailImageWhereInput | CafeVirtualLinkThumbnailImageWhereInput[]
    OR?: CafeVirtualLinkThumbnailImageWhereInput[]
    NOT?: CafeVirtualLinkThumbnailImageWhereInput | CafeVirtualLinkThumbnailImageWhereInput[]
    id?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    createdAt?: DateTimeFilter<"CafeVirtualLinkThumbnailImage"> | Date | string
    url?: StringFilter<"CafeVirtualLinkThumbnailImage"> | string
    width?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    height?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    size?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    cafeVirtualLinkId?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    CafeVirtualLink?: XOR<CafeVirtualLinkScalarRelationFilter, CafeVirtualLinkWhereInput>
  }

  export type CafeVirtualLinkThumbnailImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
    CafeVirtualLink?: CafeVirtualLinkOrderByWithRelationInput
  }

  export type CafeVirtualLinkThumbnailImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cafeVirtualLinkId?: number
    AND?: CafeVirtualLinkThumbnailImageWhereInput | CafeVirtualLinkThumbnailImageWhereInput[]
    OR?: CafeVirtualLinkThumbnailImageWhereInput[]
    NOT?: CafeVirtualLinkThumbnailImageWhereInput | CafeVirtualLinkThumbnailImageWhereInput[]
    createdAt?: DateTimeFilter<"CafeVirtualLinkThumbnailImage"> | Date | string
    url?: StringFilter<"CafeVirtualLinkThumbnailImage"> | string
    width?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    height?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    size?: IntFilter<"CafeVirtualLinkThumbnailImage"> | number
    CafeVirtualLink?: XOR<CafeVirtualLinkScalarRelationFilter, CafeVirtualLinkWhereInput>
  }, "id" | "cafeVirtualLinkId">

  export type CafeVirtualLinkThumbnailImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
    _count?: CafeVirtualLinkThumbnailImageCountOrderByAggregateInput
    _avg?: CafeVirtualLinkThumbnailImageAvgOrderByAggregateInput
    _max?: CafeVirtualLinkThumbnailImageMaxOrderByAggregateInput
    _min?: CafeVirtualLinkThumbnailImageMinOrderByAggregateInput
    _sum?: CafeVirtualLinkThumbnailImageSumOrderByAggregateInput
  }

  export type CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput = {
    AND?: CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput | CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput[]
    OR?: CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput[]
    NOT?: CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput | CafeVirtualLinkThumbnailImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | Date | string
    url?: StringWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | string
    width?: IntWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | number
    height?: IntWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | number
    size?: IntWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | number
    cafeVirtualLinkId?: IntWithAggregatesFilter<"CafeVirtualLinkThumbnailImage"> | number
  }

  export type CafeCouponGroupWhereInput = {
    AND?: CafeCouponGroupWhereInput | CafeCouponGroupWhereInput[]
    OR?: CafeCouponGroupWhereInput[]
    NOT?: CafeCouponGroupWhereInput | CafeCouponGroupWhereInput[]
    id?: IntFilter<"CafeCouponGroup"> | number
    createdAt?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    code?: StringFilter<"CafeCouponGroup"> | string
    name?: StringFilter<"CafeCouponGroup"> | string
    tag?: StringFilter<"CafeCouponGroup"> | string
    description?: StringFilter<"CafeCouponGroup"> | string
    isDisable?: BoolFilter<"CafeCouponGroup"> | boolean
    startDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    endDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    issuanceStartDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    issuanceEndDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    CafeCoupons?: CafeCouponListRelationFilter
    CafeCouponGoupPartners?: CafeCouponGoupPartnerListRelationFilter
  }

  export type CafeCouponGroupOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
    CafeCoupons?: CafeCouponOrderByRelationAggregateInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerOrderByRelationAggregateInput
  }

  export type CafeCouponGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CafeCouponGroupWhereInput | CafeCouponGroupWhereInput[]
    OR?: CafeCouponGroupWhereInput[]
    NOT?: CafeCouponGroupWhereInput | CafeCouponGroupWhereInput[]
    createdAt?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    name?: StringFilter<"CafeCouponGroup"> | string
    tag?: StringFilter<"CafeCouponGroup"> | string
    description?: StringFilter<"CafeCouponGroup"> | string
    isDisable?: BoolFilter<"CafeCouponGroup"> | boolean
    startDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    endDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    issuanceStartDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    issuanceEndDay?: DateTimeFilter<"CafeCouponGroup"> | Date | string
    CafeCoupons?: CafeCouponListRelationFilter
    CafeCouponGoupPartners?: CafeCouponGoupPartnerListRelationFilter
  }, "id" | "code">

  export type CafeCouponGroupOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
    _count?: CafeCouponGroupCountOrderByAggregateInput
    _avg?: CafeCouponGroupAvgOrderByAggregateInput
    _max?: CafeCouponGroupMaxOrderByAggregateInput
    _min?: CafeCouponGroupMinOrderByAggregateInput
    _sum?: CafeCouponGroupSumOrderByAggregateInput
  }

  export type CafeCouponGroupScalarWhereWithAggregatesInput = {
    AND?: CafeCouponGroupScalarWhereWithAggregatesInput | CafeCouponGroupScalarWhereWithAggregatesInput[]
    OR?: CafeCouponGroupScalarWhereWithAggregatesInput[]
    NOT?: CafeCouponGroupScalarWhereWithAggregatesInput | CafeCouponGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeCouponGroup"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeCouponGroup"> | Date | string
    code?: StringWithAggregatesFilter<"CafeCouponGroup"> | string
    name?: StringWithAggregatesFilter<"CafeCouponGroup"> | string
    tag?: StringWithAggregatesFilter<"CafeCouponGroup"> | string
    description?: StringWithAggregatesFilter<"CafeCouponGroup"> | string
    isDisable?: BoolWithAggregatesFilter<"CafeCouponGroup"> | boolean
    startDay?: DateTimeWithAggregatesFilter<"CafeCouponGroup"> | Date | string
    endDay?: DateTimeWithAggregatesFilter<"CafeCouponGroup"> | Date | string
    issuanceStartDay?: DateTimeWithAggregatesFilter<"CafeCouponGroup"> | Date | string
    issuanceEndDay?: DateTimeWithAggregatesFilter<"CafeCouponGroup"> | Date | string
  }

  export type CafeCouponGoupPartnerWhereInput = {
    AND?: CafeCouponGoupPartnerWhereInput | CafeCouponGoupPartnerWhereInput[]
    OR?: CafeCouponGoupPartnerWhereInput[]
    NOT?: CafeCouponGoupPartnerWhereInput | CafeCouponGoupPartnerWhereInput[]
    cafeCouponGroupId?: IntFilter<"CafeCouponGoupPartner"> | number
    cafeInfoId?: IntFilter<"CafeCouponGoupPartner"> | number
    CafeCouponGroup?: XOR<CafeCouponGroupScalarRelationFilter, CafeCouponGroupWhereInput>
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }

  export type CafeCouponGoupPartnerOrderByWithRelationInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
    CafeCouponGroup?: CafeCouponGroupOrderByWithRelationInput
    CafeInfo?: CafeInfoOrderByWithRelationInput
  }

  export type CafeCouponGoupPartnerWhereUniqueInput = Prisma.AtLeast<{
    cafeCouponGroupPartnerUnique?: CafeCouponGoupPartnerCafeCouponGroupPartnerUniqueCompoundUniqueInput
    AND?: CafeCouponGoupPartnerWhereInput | CafeCouponGoupPartnerWhereInput[]
    OR?: CafeCouponGoupPartnerWhereInput[]
    NOT?: CafeCouponGoupPartnerWhereInput | CafeCouponGoupPartnerWhereInput[]
    cafeCouponGroupId?: IntFilter<"CafeCouponGoupPartner"> | number
    cafeInfoId?: IntFilter<"CafeCouponGoupPartner"> | number
    CafeCouponGroup?: XOR<CafeCouponGroupScalarRelationFilter, CafeCouponGroupWhereInput>
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
  }, "cafeCouponGroupPartnerUnique">

  export type CafeCouponGoupPartnerOrderByWithAggregationInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
    _count?: CafeCouponGoupPartnerCountOrderByAggregateInput
    _avg?: CafeCouponGoupPartnerAvgOrderByAggregateInput
    _max?: CafeCouponGoupPartnerMaxOrderByAggregateInput
    _min?: CafeCouponGoupPartnerMinOrderByAggregateInput
    _sum?: CafeCouponGoupPartnerSumOrderByAggregateInput
  }

  export type CafeCouponGoupPartnerScalarWhereWithAggregatesInput = {
    AND?: CafeCouponGoupPartnerScalarWhereWithAggregatesInput | CafeCouponGoupPartnerScalarWhereWithAggregatesInput[]
    OR?: CafeCouponGoupPartnerScalarWhereWithAggregatesInput[]
    NOT?: CafeCouponGoupPartnerScalarWhereWithAggregatesInput | CafeCouponGoupPartnerScalarWhereWithAggregatesInput[]
    cafeCouponGroupId?: IntWithAggregatesFilter<"CafeCouponGoupPartner"> | number
    cafeInfoId?: IntWithAggregatesFilter<"CafeCouponGoupPartner"> | number
  }

  export type ProxyUserWhereInput = {
    AND?: ProxyUserWhereInput | ProxyUserWhereInput[]
    OR?: ProxyUserWhereInput[]
    NOT?: ProxyUserWhereInput | ProxyUserWhereInput[]
    id?: IntFilter<"ProxyUser"> | number
    memberId?: StringFilter<"ProxyUser"> | string
    createdAt?: DateTimeFilter<"ProxyUser"> | Date | string
    proxyUserType?: EnumProxyUserTypeFilter<"ProxyUser"> | $Enums.ProxyUserType
    name?: StringFilter<"ProxyUser"> | string
    token?: StringFilter<"ProxyUser"> | string
    userId?: IntNullableFilter<"ProxyUser"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    CafeCoupons?: CafeCouponListRelationFilter
    WishlistProducts?: WishlistProductListRelationFilter
  }

  export type ProxyUserOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    CafeCoupons?: CafeCouponOrderByRelationAggregateInput
    WishlistProducts?: WishlistProductOrderByRelationAggregateInput
  }

  export type ProxyUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    proxyUserUnique?: ProxyUserProxyUserUniqueCompoundUniqueInput
    AND?: ProxyUserWhereInput | ProxyUserWhereInput[]
    OR?: ProxyUserWhereInput[]
    NOT?: ProxyUserWhereInput | ProxyUserWhereInput[]
    memberId?: StringFilter<"ProxyUser"> | string
    createdAt?: DateTimeFilter<"ProxyUser"> | Date | string
    proxyUserType?: EnumProxyUserTypeFilter<"ProxyUser"> | $Enums.ProxyUserType
    name?: StringFilter<"ProxyUser"> | string
    token?: StringFilter<"ProxyUser"> | string
    userId?: IntNullableFilter<"ProxyUser"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    CafeCoupons?: CafeCouponListRelationFilter
    WishlistProducts?: WishlistProductListRelationFilter
  }, "id" | "proxyUserUnique">

  export type ProxyUserOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ProxyUserCountOrderByAggregateInput
    _avg?: ProxyUserAvgOrderByAggregateInput
    _max?: ProxyUserMaxOrderByAggregateInput
    _min?: ProxyUserMinOrderByAggregateInput
    _sum?: ProxyUserSumOrderByAggregateInput
  }

  export type ProxyUserScalarWhereWithAggregatesInput = {
    AND?: ProxyUserScalarWhereWithAggregatesInput | ProxyUserScalarWhereWithAggregatesInput[]
    OR?: ProxyUserScalarWhereWithAggregatesInput[]
    NOT?: ProxyUserScalarWhereWithAggregatesInput | ProxyUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProxyUser"> | number
    memberId?: StringWithAggregatesFilter<"ProxyUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProxyUser"> | Date | string
    proxyUserType?: EnumProxyUserTypeWithAggregatesFilter<"ProxyUser"> | $Enums.ProxyUserType
    name?: StringWithAggregatesFilter<"ProxyUser"> | string
    token?: StringWithAggregatesFilter<"ProxyUser"> | string
    userId?: IntNullableWithAggregatesFilter<"ProxyUser"> | number | null
  }

  export type CafeCouponWhereInput = {
    AND?: CafeCouponWhereInput | CafeCouponWhereInput[]
    OR?: CafeCouponWhereInput[]
    NOT?: CafeCouponWhereInput | CafeCouponWhereInput[]
    id?: IntFilter<"CafeCoupon"> | number
    createdAt?: DateTimeFilter<"CafeCoupon"> | Date | string
    name?: StringFilter<"CafeCoupon"> | string
    content?: StringFilter<"CafeCoupon"> | string
    serialNumber?: StringFilter<"CafeCoupon"> | string
    startDay?: DateTimeFilter<"CafeCoupon"> | Date | string
    endDay?: DateTimeNullableFilter<"CafeCoupon"> | Date | string | null
    isDisable?: BoolFilter<"CafeCoupon"> | boolean
    proxyUserId?: IntFilter<"CafeCoupon"> | number
    cafeCouponGroupId?: IntFilter<"CafeCoupon"> | number
    ProxyUser?: XOR<ProxyUserScalarRelationFilter, ProxyUserWhereInput>
    CafeCouponGroup?: XOR<CafeCouponGroupScalarRelationFilter, CafeCouponGroupWhereInput>
    CafeCouponQRCodes?: CafeCouponQRCodeListRelationFilter
    CafeCouponHistories?: CafeCouponHistoryListRelationFilter
  }

  export type CafeCouponOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrderInput | SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
    ProxyUser?: ProxyUserOrderByWithRelationInput
    CafeCouponGroup?: CafeCouponGroupOrderByWithRelationInput
    CafeCouponQRCodes?: CafeCouponQRCodeOrderByRelationAggregateInput
    CafeCouponHistories?: CafeCouponHistoryOrderByRelationAggregateInput
  }

  export type CafeCouponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serialNumber?: string
    AND?: CafeCouponWhereInput | CafeCouponWhereInput[]
    OR?: CafeCouponWhereInput[]
    NOT?: CafeCouponWhereInput | CafeCouponWhereInput[]
    createdAt?: DateTimeFilter<"CafeCoupon"> | Date | string
    name?: StringFilter<"CafeCoupon"> | string
    content?: StringFilter<"CafeCoupon"> | string
    startDay?: DateTimeFilter<"CafeCoupon"> | Date | string
    endDay?: DateTimeNullableFilter<"CafeCoupon"> | Date | string | null
    isDisable?: BoolFilter<"CafeCoupon"> | boolean
    proxyUserId?: IntFilter<"CafeCoupon"> | number
    cafeCouponGroupId?: IntFilter<"CafeCoupon"> | number
    ProxyUser?: XOR<ProxyUserScalarRelationFilter, ProxyUserWhereInput>
    CafeCouponGroup?: XOR<CafeCouponGroupScalarRelationFilter, CafeCouponGroupWhereInput>
    CafeCouponQRCodes?: CafeCouponQRCodeListRelationFilter
    CafeCouponHistories?: CafeCouponHistoryListRelationFilter
  }, "id" | "serialNumber">

  export type CafeCouponOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrderInput | SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
    _count?: CafeCouponCountOrderByAggregateInput
    _avg?: CafeCouponAvgOrderByAggregateInput
    _max?: CafeCouponMaxOrderByAggregateInput
    _min?: CafeCouponMinOrderByAggregateInput
    _sum?: CafeCouponSumOrderByAggregateInput
  }

  export type CafeCouponScalarWhereWithAggregatesInput = {
    AND?: CafeCouponScalarWhereWithAggregatesInput | CafeCouponScalarWhereWithAggregatesInput[]
    OR?: CafeCouponScalarWhereWithAggregatesInput[]
    NOT?: CafeCouponScalarWhereWithAggregatesInput | CafeCouponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeCoupon"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeCoupon"> | Date | string
    name?: StringWithAggregatesFilter<"CafeCoupon"> | string
    content?: StringWithAggregatesFilter<"CafeCoupon"> | string
    serialNumber?: StringWithAggregatesFilter<"CafeCoupon"> | string
    startDay?: DateTimeWithAggregatesFilter<"CafeCoupon"> | Date | string
    endDay?: DateTimeNullableWithAggregatesFilter<"CafeCoupon"> | Date | string | null
    isDisable?: BoolWithAggregatesFilter<"CafeCoupon"> | boolean
    proxyUserId?: IntWithAggregatesFilter<"CafeCoupon"> | number
    cafeCouponGroupId?: IntWithAggregatesFilter<"CafeCoupon"> | number
  }

  export type CafeCouponHistoryWhereInput = {
    AND?: CafeCouponHistoryWhereInput | CafeCouponHistoryWhereInput[]
    OR?: CafeCouponHistoryWhereInput[]
    NOT?: CafeCouponHistoryWhereInput | CafeCouponHistoryWhereInput[]
    id?: IntFilter<"CafeCouponHistory"> | number
    createdAt?: DateTimeFilter<"CafeCouponHistory"> | Date | string
    cafeCouponId?: IntFilter<"CafeCouponHistory"> | number
    eventType?: EnumCafeCouponEventTypeFilter<"CafeCouponHistory"> | $Enums.CafeCouponEventType
    description?: StringFilter<"CafeCouponHistory"> | string
    actorId?: IntFilter<"CafeCouponHistory"> | number
    statusBefore?: EnumCafeCouponStatusNullableFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
    CafeCoupon?: XOR<CafeCouponScalarRelationFilter, CafeCouponWhereInput>
    Actor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CafeCouponHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrderInput | SortOrder
    statusAfter?: SortOrderInput | SortOrder
    CafeCoupon?: CafeCouponOrderByWithRelationInput
    Actor?: UserOrderByWithRelationInput
  }

  export type CafeCouponHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CafeCouponHistoryWhereInput | CafeCouponHistoryWhereInput[]
    OR?: CafeCouponHistoryWhereInput[]
    NOT?: CafeCouponHistoryWhereInput | CafeCouponHistoryWhereInput[]
    createdAt?: DateTimeFilter<"CafeCouponHistory"> | Date | string
    cafeCouponId?: IntFilter<"CafeCouponHistory"> | number
    eventType?: EnumCafeCouponEventTypeFilter<"CafeCouponHistory"> | $Enums.CafeCouponEventType
    description?: StringFilter<"CafeCouponHistory"> | string
    actorId?: IntFilter<"CafeCouponHistory"> | number
    statusBefore?: EnumCafeCouponStatusNullableFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
    CafeCoupon?: XOR<CafeCouponScalarRelationFilter, CafeCouponWhereInput>
    Actor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CafeCouponHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrderInput | SortOrder
    statusAfter?: SortOrderInput | SortOrder
    _count?: CafeCouponHistoryCountOrderByAggregateInput
    _avg?: CafeCouponHistoryAvgOrderByAggregateInput
    _max?: CafeCouponHistoryMaxOrderByAggregateInput
    _min?: CafeCouponHistoryMinOrderByAggregateInput
    _sum?: CafeCouponHistorySumOrderByAggregateInput
  }

  export type CafeCouponHistoryScalarWhereWithAggregatesInput = {
    AND?: CafeCouponHistoryScalarWhereWithAggregatesInput | CafeCouponHistoryScalarWhereWithAggregatesInput[]
    OR?: CafeCouponHistoryScalarWhereWithAggregatesInput[]
    NOT?: CafeCouponHistoryScalarWhereWithAggregatesInput | CafeCouponHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CafeCouponHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CafeCouponHistory"> | Date | string
    cafeCouponId?: IntWithAggregatesFilter<"CafeCouponHistory"> | number
    eventType?: EnumCafeCouponEventTypeWithAggregatesFilter<"CafeCouponHistory"> | $Enums.CafeCouponEventType
    description?: StringWithAggregatesFilter<"CafeCouponHistory"> | string
    actorId?: IntWithAggregatesFilter<"CafeCouponHistory"> | number
    statusBefore?: EnumCafeCouponStatusNullableWithAggregatesFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableWithAggregatesFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponQRCodeWhereInput = {
    AND?: CafeCouponQRCodeWhereInput | CafeCouponQRCodeWhereInput[]
    OR?: CafeCouponQRCodeWhereInput[]
    NOT?: CafeCouponQRCodeWhereInput | CafeCouponQRCodeWhereInput[]
    serialNumber?: StringFilter<"CafeCouponQRCode"> | string
    createdAt?: DateTimeFilter<"CafeCouponQRCode"> | Date | string
    isDisable?: BoolFilter<"CafeCouponQRCode"> | boolean
    cafeCouponId?: IntNullableFilter<"CafeCouponQRCode"> | number | null
    size?: IntFilter<"CafeCouponQRCode"> | number
    base64Data?: StringFilter<"CafeCouponQRCode"> | string
    CafeCoupon?: XOR<CafeCouponNullableScalarRelationFilter, CafeCouponWhereInput> | null
  }

  export type CafeCouponQRCodeOrderByWithRelationInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrderInput | SortOrder
    size?: SortOrder
    base64Data?: SortOrder
    CafeCoupon?: CafeCouponOrderByWithRelationInput
  }

  export type CafeCouponQRCodeWhereUniqueInput = Prisma.AtLeast<{
    serialNumber?: string
    AND?: CafeCouponQRCodeWhereInput | CafeCouponQRCodeWhereInput[]
    OR?: CafeCouponQRCodeWhereInput[]
    NOT?: CafeCouponQRCodeWhereInput | CafeCouponQRCodeWhereInput[]
    createdAt?: DateTimeFilter<"CafeCouponQRCode"> | Date | string
    isDisable?: BoolFilter<"CafeCouponQRCode"> | boolean
    cafeCouponId?: IntNullableFilter<"CafeCouponQRCode"> | number | null
    size?: IntFilter<"CafeCouponQRCode"> | number
    base64Data?: StringFilter<"CafeCouponQRCode"> | string
    CafeCoupon?: XOR<CafeCouponNullableScalarRelationFilter, CafeCouponWhereInput> | null
  }, "serialNumber">

  export type CafeCouponQRCodeOrderByWithAggregationInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrderInput | SortOrder
    size?: SortOrder
    base64Data?: SortOrder
    _count?: CafeCouponQRCodeCountOrderByAggregateInput
    _avg?: CafeCouponQRCodeAvgOrderByAggregateInput
    _max?: CafeCouponQRCodeMaxOrderByAggregateInput
    _min?: CafeCouponQRCodeMinOrderByAggregateInput
    _sum?: CafeCouponQRCodeSumOrderByAggregateInput
  }

  export type CafeCouponQRCodeScalarWhereWithAggregatesInput = {
    AND?: CafeCouponQRCodeScalarWhereWithAggregatesInput | CafeCouponQRCodeScalarWhereWithAggregatesInput[]
    OR?: CafeCouponQRCodeScalarWhereWithAggregatesInput[]
    NOT?: CafeCouponQRCodeScalarWhereWithAggregatesInput | CafeCouponQRCodeScalarWhereWithAggregatesInput[]
    serialNumber?: StringWithAggregatesFilter<"CafeCouponQRCode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CafeCouponQRCode"> | Date | string
    isDisable?: BoolWithAggregatesFilter<"CafeCouponQRCode"> | boolean
    cafeCouponId?: IntNullableWithAggregatesFilter<"CafeCouponQRCode"> | number | null
    size?: IntWithAggregatesFilter<"CafeCouponQRCode"> | number
    base64Data?: StringWithAggregatesFilter<"CafeCouponQRCode"> | string
  }

  export type MetaViewerInfoWhereInput = {
    AND?: MetaViewerInfoWhereInput | MetaViewerInfoWhereInput[]
    OR?: MetaViewerInfoWhereInput[]
    NOT?: MetaViewerInfoWhereInput | MetaViewerInfoWhereInput[]
    id?: IntFilter<"MetaViewerInfo"> | number
    createdAt?: DateTimeFilter<"MetaViewerInfo"> | Date | string
    code?: StringFilter<"MetaViewerInfo"> | string
    isDisable?: BoolFilter<"MetaViewerInfo"> | boolean
    worldData?: JsonFilter<"MetaViewerInfo">
    cafeInfoId?: IntFilter<"MetaViewerInfo"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
    MetaViewerMaps?: MetaViewerMapListRelationFilter
    ActiveMaps?: XOR<MetaViewerActiveMapNullableScalarRelationFilter, MetaViewerActiveMapWhereInput> | null
  }

  export type MetaViewerInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    worldData?: SortOrder
    cafeInfoId?: SortOrder
    CafeInfo?: CafeInfoOrderByWithRelationInput
    MetaViewerMaps?: MetaViewerMapOrderByRelationAggregateInput
    ActiveMaps?: MetaViewerActiveMapOrderByWithRelationInput
  }

  export type MetaViewerInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: MetaViewerInfoWhereInput | MetaViewerInfoWhereInput[]
    OR?: MetaViewerInfoWhereInput[]
    NOT?: MetaViewerInfoWhereInput | MetaViewerInfoWhereInput[]
    createdAt?: DateTimeFilter<"MetaViewerInfo"> | Date | string
    isDisable?: BoolFilter<"MetaViewerInfo"> | boolean
    worldData?: JsonFilter<"MetaViewerInfo">
    cafeInfoId?: IntFilter<"MetaViewerInfo"> | number
    CafeInfo?: XOR<CafeInfoScalarRelationFilter, CafeInfoWhereInput>
    MetaViewerMaps?: MetaViewerMapListRelationFilter
    ActiveMaps?: XOR<MetaViewerActiveMapNullableScalarRelationFilter, MetaViewerActiveMapWhereInput> | null
  }, "id" | "code">

  export type MetaViewerInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    worldData?: SortOrder
    cafeInfoId?: SortOrder
    _count?: MetaViewerInfoCountOrderByAggregateInput
    _avg?: MetaViewerInfoAvgOrderByAggregateInput
    _max?: MetaViewerInfoMaxOrderByAggregateInput
    _min?: MetaViewerInfoMinOrderByAggregateInput
    _sum?: MetaViewerInfoSumOrderByAggregateInput
  }

  export type MetaViewerInfoScalarWhereWithAggregatesInput = {
    AND?: MetaViewerInfoScalarWhereWithAggregatesInput | MetaViewerInfoScalarWhereWithAggregatesInput[]
    OR?: MetaViewerInfoScalarWhereWithAggregatesInput[]
    NOT?: MetaViewerInfoScalarWhereWithAggregatesInput | MetaViewerInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MetaViewerInfo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MetaViewerInfo"> | Date | string
    code?: StringWithAggregatesFilter<"MetaViewerInfo"> | string
    isDisable?: BoolWithAggregatesFilter<"MetaViewerInfo"> | boolean
    worldData?: JsonWithAggregatesFilter<"MetaViewerInfo">
    cafeInfoId?: IntWithAggregatesFilter<"MetaViewerInfo"> | number
  }

  export type MetaViewerMapWhereInput = {
    AND?: MetaViewerMapWhereInput | MetaViewerMapWhereInput[]
    OR?: MetaViewerMapWhereInput[]
    NOT?: MetaViewerMapWhereInput | MetaViewerMapWhereInput[]
    id?: IntFilter<"MetaViewerMap"> | number
    createdAt?: DateTimeFilter<"MetaViewerMap"> | Date | string
    type?: EnumMetaMapTypeFilter<"MetaViewerMap"> | $Enums.MetaMapType
    version?: FloatFilter<"MetaViewerMap"> | number
    url?: StringFilter<"MetaViewerMap"> | string
    size?: IntFilter<"MetaViewerMap"> | number
    contentKey?: StringNullableFilter<"MetaViewerMap"> | string | null
    isDraco?: BoolFilter<"MetaViewerMap"> | boolean
    metaViewerInfoId?: IntFilter<"MetaViewerMap"> | number
    MetaViewerInfo?: XOR<MetaViewerInfoScalarRelationFilter, MetaViewerInfoWhereInput>
    ActiveRenderFor?: MetaViewerActiveMapListRelationFilter
    ActiveColliderFor?: MetaViewerActiveMapListRelationFilter
  }

  export type MetaViewerMapOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrderInput | SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
    MetaViewerInfo?: MetaViewerInfoOrderByWithRelationInput
    ActiveRenderFor?: MetaViewerActiveMapOrderByRelationAggregateInput
    ActiveColliderFor?: MetaViewerActiveMapOrderByRelationAggregateInput
  }

  export type MetaViewerMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MetaViewerMapWhereInput | MetaViewerMapWhereInput[]
    OR?: MetaViewerMapWhereInput[]
    NOT?: MetaViewerMapWhereInput | MetaViewerMapWhereInput[]
    createdAt?: DateTimeFilter<"MetaViewerMap"> | Date | string
    type?: EnumMetaMapTypeFilter<"MetaViewerMap"> | $Enums.MetaMapType
    version?: FloatFilter<"MetaViewerMap"> | number
    url?: StringFilter<"MetaViewerMap"> | string
    size?: IntFilter<"MetaViewerMap"> | number
    contentKey?: StringNullableFilter<"MetaViewerMap"> | string | null
    isDraco?: BoolFilter<"MetaViewerMap"> | boolean
    metaViewerInfoId?: IntFilter<"MetaViewerMap"> | number
    MetaViewerInfo?: XOR<MetaViewerInfoScalarRelationFilter, MetaViewerInfoWhereInput>
    ActiveRenderFor?: MetaViewerActiveMapListRelationFilter
    ActiveColliderFor?: MetaViewerActiveMapListRelationFilter
  }, "id">

  export type MetaViewerMapOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrderInput | SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
    _count?: MetaViewerMapCountOrderByAggregateInput
    _avg?: MetaViewerMapAvgOrderByAggregateInput
    _max?: MetaViewerMapMaxOrderByAggregateInput
    _min?: MetaViewerMapMinOrderByAggregateInput
    _sum?: MetaViewerMapSumOrderByAggregateInput
  }

  export type MetaViewerMapScalarWhereWithAggregatesInput = {
    AND?: MetaViewerMapScalarWhereWithAggregatesInput | MetaViewerMapScalarWhereWithAggregatesInput[]
    OR?: MetaViewerMapScalarWhereWithAggregatesInput[]
    NOT?: MetaViewerMapScalarWhereWithAggregatesInput | MetaViewerMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MetaViewerMap"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MetaViewerMap"> | Date | string
    type?: EnumMetaMapTypeWithAggregatesFilter<"MetaViewerMap"> | $Enums.MetaMapType
    version?: FloatWithAggregatesFilter<"MetaViewerMap"> | number
    url?: StringWithAggregatesFilter<"MetaViewerMap"> | string
    size?: IntWithAggregatesFilter<"MetaViewerMap"> | number
    contentKey?: StringNullableWithAggregatesFilter<"MetaViewerMap"> | string | null
    isDraco?: BoolWithAggregatesFilter<"MetaViewerMap"> | boolean
    metaViewerInfoId?: IntWithAggregatesFilter<"MetaViewerMap"> | number
  }

  export type MetaViewerActiveMapWhereInput = {
    AND?: MetaViewerActiveMapWhereInput | MetaViewerActiveMapWhereInput[]
    OR?: MetaViewerActiveMapWhereInput[]
    NOT?: MetaViewerActiveMapWhereInput | MetaViewerActiveMapWhereInput[]
    id?: IntFilter<"MetaViewerActiveMap"> | number
    updatedAt?: DateTimeFilter<"MetaViewerActiveMap"> | Date | string
    metaViewerInfoId?: IntFilter<"MetaViewerActiveMap"> | number
    activeRenderMapId?: IntFilter<"MetaViewerActiveMap"> | number
    activeColliderMapId?: IntFilter<"MetaViewerActiveMap"> | number
    MetaViewerInfo?: XOR<MetaViewerInfoScalarRelationFilter, MetaViewerInfoWhereInput>
    ActiveRenderMap?: XOR<MetaViewerMapScalarRelationFilter, MetaViewerMapWhereInput>
    ActiveColliderMap?: XOR<MetaViewerMapScalarRelationFilter, MetaViewerMapWhereInput>
  }

  export type MetaViewerActiveMapOrderByWithRelationInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
    MetaViewerInfo?: MetaViewerInfoOrderByWithRelationInput
    ActiveRenderMap?: MetaViewerMapOrderByWithRelationInput
    ActiveColliderMap?: MetaViewerMapOrderByWithRelationInput
  }

  export type MetaViewerActiveMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    metaViewerInfoId?: number
    AND?: MetaViewerActiveMapWhereInput | MetaViewerActiveMapWhereInput[]
    OR?: MetaViewerActiveMapWhereInput[]
    NOT?: MetaViewerActiveMapWhereInput | MetaViewerActiveMapWhereInput[]
    updatedAt?: DateTimeFilter<"MetaViewerActiveMap"> | Date | string
    activeRenderMapId?: IntFilter<"MetaViewerActiveMap"> | number
    activeColliderMapId?: IntFilter<"MetaViewerActiveMap"> | number
    MetaViewerInfo?: XOR<MetaViewerInfoScalarRelationFilter, MetaViewerInfoWhereInput>
    ActiveRenderMap?: XOR<MetaViewerMapScalarRelationFilter, MetaViewerMapWhereInput>
    ActiveColliderMap?: XOR<MetaViewerMapScalarRelationFilter, MetaViewerMapWhereInput>
  }, "id" | "metaViewerInfoId">

  export type MetaViewerActiveMapOrderByWithAggregationInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
    _count?: MetaViewerActiveMapCountOrderByAggregateInput
    _avg?: MetaViewerActiveMapAvgOrderByAggregateInput
    _max?: MetaViewerActiveMapMaxOrderByAggregateInput
    _min?: MetaViewerActiveMapMinOrderByAggregateInput
    _sum?: MetaViewerActiveMapSumOrderByAggregateInput
  }

  export type MetaViewerActiveMapScalarWhereWithAggregatesInput = {
    AND?: MetaViewerActiveMapScalarWhereWithAggregatesInput | MetaViewerActiveMapScalarWhereWithAggregatesInput[]
    OR?: MetaViewerActiveMapScalarWhereWithAggregatesInput[]
    NOT?: MetaViewerActiveMapScalarWhereWithAggregatesInput | MetaViewerActiveMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MetaViewerActiveMap"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"MetaViewerActiveMap"> | Date | string
    metaViewerInfoId?: IntWithAggregatesFilter<"MetaViewerActiveMap"> | number
    activeRenderMapId?: IntWithAggregatesFilter<"MetaViewerActiveMap"> | number
    activeColliderMapId?: IntWithAggregatesFilter<"MetaViewerActiveMap"> | number
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    isDisable?: BoolFilter<"ProductCategory"> | boolean
    code?: StringFilter<"ProductCategory"> | string
    AncestorCategories?: ClosureProductCategoryListRelationFilter
    DescendantCategories?: ClosureProductCategoryListRelationFilter
    Products?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDisable?: SortOrder
    code?: SortOrder
    AncestorCategories?: ClosureProductCategoryOrderByRelationAggregateInput
    DescendantCategories?: ClosureProductCategoryOrderByRelationAggregateInput
    Products?: ProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    isDisable?: BoolFilter<"ProductCategory"> | boolean
    AncestorCategories?: ClosureProductCategoryListRelationFilter
    DescendantCategories?: ClosureProductCategoryListRelationFilter
    Products?: ProductListRelationFilter
  }, "id" | "code">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDisable?: SortOrder
    code?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    isDisable?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    code?: StringWithAggregatesFilter<"ProductCategory"> | string
  }

  export type ClosureProductCategoryWhereInput = {
    AND?: ClosureProductCategoryWhereInput | ClosureProductCategoryWhereInput[]
    OR?: ClosureProductCategoryWhereInput[]
    NOT?: ClosureProductCategoryWhereInput | ClosureProductCategoryWhereInput[]
    ancestor?: IntFilter<"ClosureProductCategory"> | number
    descendant?: IntFilter<"ClosureProductCategory"> | number
    depth?: IntFilter<"ClosureProductCategory"> | number
    AncestorCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    DescendantCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }

  export type ClosureProductCategoryOrderByWithRelationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    AncestorCategory?: ProductCategoryOrderByWithRelationInput
    DescendantCategory?: ProductCategoryOrderByWithRelationInput
  }

  export type ClosureProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    productCategoryTreeUnique?: ClosureProductCategoryProductCategoryTreeUniqueCompoundUniqueInput
    AND?: ClosureProductCategoryWhereInput | ClosureProductCategoryWhereInput[]
    OR?: ClosureProductCategoryWhereInput[]
    NOT?: ClosureProductCategoryWhereInput | ClosureProductCategoryWhereInput[]
    ancestor?: IntFilter<"ClosureProductCategory"> | number
    descendant?: IntFilter<"ClosureProductCategory"> | number
    depth?: IntFilter<"ClosureProductCategory"> | number
    AncestorCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    DescendantCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }, "productCategoryTreeUnique">

  export type ClosureProductCategoryOrderByWithAggregationInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
    _count?: ClosureProductCategoryCountOrderByAggregateInput
    _avg?: ClosureProductCategoryAvgOrderByAggregateInput
    _max?: ClosureProductCategoryMaxOrderByAggregateInput
    _min?: ClosureProductCategoryMinOrderByAggregateInput
    _sum?: ClosureProductCategorySumOrderByAggregateInput
  }

  export type ClosureProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ClosureProductCategoryScalarWhereWithAggregatesInput | ClosureProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ClosureProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ClosureProductCategoryScalarWhereWithAggregatesInput | ClosureProductCategoryScalarWhereWithAggregatesInput[]
    ancestor?: IntWithAggregatesFilter<"ClosureProductCategory"> | number
    descendant?: IntWithAggregatesFilter<"ClosureProductCategory"> | number
    depth?: IntWithAggregatesFilter<"ClosureProductCategory"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: IntFilter<"Product"> | number
    originalPrice?: IntNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    minOrderQuantity?: IntFilter<"Product"> | number
    isDisable?: BoolFilter<"Product"> | boolean
    isAvailable?: BoolFilter<"Product"> | boolean
    categoryId?: IntFilter<"Product"> | number
    cafeInfoId?: IntNullableFilter<"Product"> | number | null
    productRedirectUrl?: StringNullableFilter<"Product"> | string | null
    isSignature?: BoolFilter<"Product"> | boolean
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    CafeInfo?: XOR<CafeInfoNullableScalarRelationFilter, CafeInfoWhereInput> | null
    WishlistProducts?: WishlistProductListRelationFilter
    ProductImages?: ProductImageListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrderInput | SortOrder
    productRedirectUrl?: SortOrderInput | SortOrder
    isSignature?: SortOrder
    ProductCategory?: ProductCategoryOrderByWithRelationInput
    CafeInfo?: CafeInfoOrderByWithRelationInput
    WishlistProducts?: WishlistProductOrderByRelationAggregateInput
    ProductImages?: ProductImageOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: IntFilter<"Product"> | number
    originalPrice?: IntNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    minOrderQuantity?: IntFilter<"Product"> | number
    isDisable?: BoolFilter<"Product"> | boolean
    isAvailable?: BoolFilter<"Product"> | boolean
    categoryId?: IntFilter<"Product"> | number
    cafeInfoId?: IntNullableFilter<"Product"> | number | null
    productRedirectUrl?: StringNullableFilter<"Product"> | string | null
    isSignature?: BoolFilter<"Product"> | boolean
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    CafeInfo?: XOR<CafeInfoNullableScalarRelationFilter, CafeInfoWhereInput> | null
    WishlistProducts?: WishlistProductListRelationFilter
    ProductImages?: ProductImageListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrderInput | SortOrder
    productRedirectUrl?: SortOrderInput | SortOrder
    isSignature?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: IntWithAggregatesFilter<"Product"> | number
    originalPrice?: IntNullableWithAggregatesFilter<"Product"> | number | null
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number
    minOrderQuantity?: IntWithAggregatesFilter<"Product"> | number
    isDisable?: BoolWithAggregatesFilter<"Product"> | boolean
    isAvailable?: BoolWithAggregatesFilter<"Product"> | boolean
    categoryId?: IntWithAggregatesFilter<"Product"> | number
    cafeInfoId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    productRedirectUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isSignature?: BoolWithAggregatesFilter<"Product"> | boolean
  }

  export type WishlistProductWhereInput = {
    AND?: WishlistProductWhereInput | WishlistProductWhereInput[]
    OR?: WishlistProductWhereInput[]
    NOT?: WishlistProductWhereInput | WishlistProductWhereInput[]
    id?: IntFilter<"WishlistProduct"> | number
    createdAt?: DateTimeFilter<"WishlistProduct"> | Date | string
    productId?: IntFilter<"WishlistProduct"> | number
    proxyUserId?: IntFilter<"WishlistProduct"> | number
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ProxyUser?: XOR<ProxyUserScalarRelationFilter, ProxyUserWhereInput>
  }

  export type WishlistProductOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
    Product?: ProductOrderByWithRelationInput
    ProxyUser?: ProxyUserOrderByWithRelationInput
  }

  export type WishlistProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    wishlistProductUnique?: WishlistProductWishlistProductUniqueCompoundUniqueInput
    AND?: WishlistProductWhereInput | WishlistProductWhereInput[]
    OR?: WishlistProductWhereInput[]
    NOT?: WishlistProductWhereInput | WishlistProductWhereInput[]
    createdAt?: DateTimeFilter<"WishlistProduct"> | Date | string
    productId?: IntFilter<"WishlistProduct"> | number
    proxyUserId?: IntFilter<"WishlistProduct"> | number
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ProxyUser?: XOR<ProxyUserScalarRelationFilter, ProxyUserWhereInput>
  }, "id" | "wishlistProductUnique">

  export type WishlistProductOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
    _count?: WishlistProductCountOrderByAggregateInput
    _avg?: WishlistProductAvgOrderByAggregateInput
    _max?: WishlistProductMaxOrderByAggregateInput
    _min?: WishlistProductMinOrderByAggregateInput
    _sum?: WishlistProductSumOrderByAggregateInput
  }

  export type WishlistProductScalarWhereWithAggregatesInput = {
    AND?: WishlistProductScalarWhereWithAggregatesInput | WishlistProductScalarWhereWithAggregatesInput[]
    OR?: WishlistProductScalarWhereWithAggregatesInput[]
    NOT?: WishlistProductScalarWhereWithAggregatesInput | WishlistProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WishlistProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WishlistProduct"> | Date | string
    productId?: IntWithAggregatesFilter<"WishlistProduct"> | number
    proxyUserId?: IntWithAggregatesFilter<"WishlistProduct"> | number
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    url?: StringFilter<"ProductImage"> | string
    thumbnailUrl?: StringFilter<"ProductImage"> | string
    width?: IntFilter<"ProductImage"> | number
    height?: IntFilter<"ProductImage"> | number
    size?: IntFilter<"ProductImage"> | number
    isDisable?: BoolFilter<"ProductImage"> | boolean
    isThumb?: BoolFilter<"ProductImage"> | boolean
    productId?: IntFilter<"ProductImage"> | number
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
    Product?: ProductOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    url?: StringFilter<"ProductImage"> | string
    thumbnailUrl?: StringFilter<"ProductImage"> | string
    width?: IntFilter<"ProductImage"> | number
    height?: IntFilter<"ProductImage"> | number
    size?: IntFilter<"ProductImage"> | number
    isDisable?: BoolFilter<"ProductImage"> | boolean
    isThumb?: BoolFilter<"ProductImage"> | boolean
    productId?: IntFilter<"ProductImage"> | number
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
    url?: StringWithAggregatesFilter<"ProductImage"> | string
    thumbnailUrl?: StringWithAggregatesFilter<"ProductImage"> | string
    width?: IntWithAggregatesFilter<"ProductImage"> | number
    height?: IntWithAggregatesFilter<"ProductImage"> | number
    size?: IntWithAggregatesFilter<"ProductImage"> | number
    isDisable?: BoolWithAggregatesFilter<"ProductImage"> | boolean
    isThumb?: BoolWithAggregatesFilter<"ProductImage"> | boolean
    productId?: IntWithAggregatesFilter<"ProductImage"> | number
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoticeCreateInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    User: UserCreateNestedOneWithoutNoticesInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    userId: number
  }

  export type NoticeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutNoticesNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NoticeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    userId: number
  }

  export type NoticeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardCreateInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId: number
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId: number
    boardType?: $Enums.BoardType
  }

  export type BoardUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
  }

  export type BoardImageCreateInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
    Board: BoardCreateNestedOneWithoutBoardImagesInput
  }

  export type BoardImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
    boardId: number
  }

  export type BoardImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Board?: BoardUpdateOneRequiredWithoutBoardImagesNestedInput
  }

  export type BoardImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
    boardId: number
  }

  export type BoardImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardReplyCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    boardReplyId?: number | null
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    boardReplyId?: number | null
  }

  export type BoardReplyUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardReplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CafeBoardCreateInput = {
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutCafeBoardsInput
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeBoardsInput
  }

  export type CafeBoardUncheckedCreateInput = {
    boardId: number
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type CafeBoardUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutCafeBoardsNestedInput
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeBoardsNestedInput
  }

  export type CafeBoardUncheckedUpdateInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardCreateManyInput = {
    boardId: number
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type CafeBoardUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateManyInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCategoryCreateInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    CafeInfos?: CafeInfoCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    CafeInfos?: CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    CafeInfos?: CafeInfoUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    CafeInfos?: CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
  }

  export type RegionCategoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
  }

  export type RegionCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
  }

  export type ClosureRegionCategoryCreateInput = {
    depth?: number
    AncestorCategory: RegionCategoryCreateNestedOneWithoutAncestorCategoriesInput
    DescendantCategory: RegionCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureRegionCategoryUncheckedCreateInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryUpdateInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: RegionCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
    DescendantCategory?: RegionCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureRegionCategoryUncheckedUpdateInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryCreateManyInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryUpdateManyMutationInput = {
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUncheckedUpdateManyInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type CafeInfoCreateInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
  }

  export type CafeInfoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
  }

  export type CafeInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
  }

  export type CafeThumbnailImageCreateInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeThumbnailImagesInput
  }

  export type CafeThumbnailImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeThumbnailImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeThumbnailImagesNestedInput
  }

  export type CafeThumbnailImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeThumbnailImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeThumbnailImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualImageCreateInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeVirtualImagesInput
  }

  export type CafeVirtualImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeVirtualImagesNestedInput
  }

  export type CafeVirtualImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeRealImageCreateInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeRealImagesInput
  }

  export type CafeRealImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeRealImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeRealImagesNestedInput
  }

  export type CafeRealImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeRealImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
    cafeInfoId: number
  }

  export type CafeRealImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkCreateInput = {
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeVirtualLinksInput
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId: number
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeVirtualLinksNestedInput
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualLinkUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageCreateInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    CafeVirtualLink: CafeVirtualLinkCreateNestedOneWithoutCafeVirtualLinkThumbnailImageInput
  }

  export type CafeVirtualLinkThumbnailImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
  }

  export type CafeVirtualLinkThumbnailImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    CafeVirtualLink?: CafeVirtualLinkUpdateOneRequiredWithoutCafeVirtualLinkThumbnailImageNestedInput
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    cafeVirtualLinkId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    cafeVirtualLinkId: number
  }

  export type CafeVirtualLinkThumbnailImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    cafeVirtualLinkId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGroupCreateInput = {
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponCreateNestedManyWithoutCafeCouponGroupInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutCafeCouponGroupInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUpdateManyWithoutCafeCouponGroupNestedInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupCreateManyInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
  }

  export type CafeCouponGroupUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeCouponGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeCouponGoupPartnerCreateInput = {
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponGoupPartnersInput
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeCouponGroupPartnersInput
  }

  export type CafeCouponGoupPartnerUncheckedCreateInput = {
    cafeCouponGroupId: number
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerUpdateInput = {
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponGoupPartnersNestedInput
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeCouponGroupPartnersNestedInput
  }

  export type CafeCouponGoupPartnerUncheckedUpdateInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerCreateManyInput = {
    cafeCouponGroupId: number
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerUpdateManyMutationInput = {

  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type ProxyUserCreateInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    User?: UserCreateNestedOneWithoutProxyUsersInput
    CafeCoupons?: CafeCouponCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    userId?: number | null
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUpdateInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutProxyUsersNestedInput
    CafeCoupons?: CafeCouponUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserCreateManyInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    userId?: number | null
  }

  export type ProxyUserUpdateManyMutationInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CafeCouponCreateInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
  }

  export type CafeCouponUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeCouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponHistoryCreateInput = {
    createdAt?: Date | string
    eventType: $Enums.CafeCouponEventType
    description: string
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
    CafeCoupon: CafeCouponCreateNestedOneWithoutCafeCouponHistoriesInput
    Actor: UserCreateNestedOneWithoutCafeCouponHistoriesInput
  }

  export type CafeCouponHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: $Enums.CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    CafeCoupon?: CafeCouponUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
    Actor?: UserUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
  }

  export type CafeCouponHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: $Enums.CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponQRCodeCreateInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
    CafeCoupon?: CafeCouponCreateNestedOneWithoutCafeCouponQRCodesInput
  }

  export type CafeCouponQRCodeUncheckedCreateInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    cafeCouponId?: number | null
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
    CafeCoupon?: CafeCouponUpdateOneWithoutCafeCouponQRCodesNestedInput
  }

  export type CafeCouponQRCodeUncheckedUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeCreateManyInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    cafeCouponId?: number | null
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUpdateManyMutationInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateManyInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type MetaViewerInfoCreateInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    CafeInfo: CafeInfoCreateNestedOneWithoutMetaViewerInfosInput
    MetaViewerMaps?: MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
    MetaViewerMaps?: MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput
    MetaViewerMaps?: MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    MetaViewerMaps?: MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
  }

  export type MetaViewerInfoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
  }

  export type MetaViewerInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerMapCreateInput = {
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput
    ActiveRenderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput
    ActiveRenderFor?: MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapCreateManyInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
  }

  export type MetaViewerMapUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MetaViewerMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapCreateInput = {
    updatedAt?: Date | string
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutActiveMapsInput
    ActiveRenderMap: MetaViewerMapCreateNestedOneWithoutActiveRenderForInput
    ActiveColliderMap: MetaViewerMapCreateNestedOneWithoutActiveColliderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapUpdateInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput
    ActiveRenderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput
    ActiveColliderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapCreateManyInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapUpdateManyMutationInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaViewerActiveMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCategoryCreateInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
  }

  export type ClosureProductCategoryCreateInput = {
    depth?: number
    AncestorCategory: ProductCategoryCreateNestedOneWithoutAncestorCategoriesInput
    DescendantCategory: ProductCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureProductCategoryUncheckedCreateInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryUpdateInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: ProductCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
    DescendantCategory?: ProductCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureProductCategoryUncheckedUpdateInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryCreateManyInput = {
    ancestor: number
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryUpdateManyMutationInput = {
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUncheckedUpdateManyInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    productRedirectUrl?: string | null
    isSignature?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WishlistProductCreateInput = {
    createdAt?: Date | string
    Product: ProductCreateNestedOneWithoutWishlistProductsInput
    ProxyUser: ProxyUserCreateNestedOneWithoutWishlistProductsInput
  }

  export type WishlistProductUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    productId: number
    proxyUserId: number
  }

  export type WishlistProductUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutWishlistProductsNestedInput
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutWishlistProductsNestedInput
  }

  export type WishlistProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistProductCreateManyInput = {
    id?: number
    createdAt?: Date | string
    productId: number
    proxyUserId: number
  }

  export type WishlistProductUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
    Product: ProductCreateNestedOneWithoutProductImagesInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
    productId: number
  }

  export type ProductImageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    Product?: ProductUpdateOneRequiredWithoutProductImagesNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
    productId: number
  }

  export type ProductImageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumLoginTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginType | EnumLoginTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginTypeFilter<$PrismaModel> | $Enums.LoginType
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoardListRelationFilter = {
    every?: BoardWhereInput
    some?: BoardWhereInput
    none?: BoardWhereInput
  }

  export type BoardReplyListRelationFilter = {
    every?: BoardReplyWhereInput
    some?: BoardReplyWhereInput
    none?: BoardReplyWhereInput
  }

  export type NoticeListRelationFilter = {
    every?: NoticeWhereInput
    some?: NoticeWhereInput
    none?: NoticeWhereInput
  }

  export type ProxyUserListRelationFilter = {
    every?: ProxyUserWhereInput
    some?: ProxyUserWhereInput
    none?: ProxyUserWhereInput
  }

  export type CafeCouponHistoryListRelationFilter = {
    every?: CafeCouponHistoryWhereInput
    some?: CafeCouponHistoryWhereInput
    none?: CafeCouponHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginUniqueCompoundUniqueInput = {
    loginType: $Enums.LoginType
    loginId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    loginId?: SortOrder
    loginPw?: SortOrder
    username?: SortOrder
    loginType?: SortOrder
    userType?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    isDisable?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumLoginTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginType | EnumLoginTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoginType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoginTypeFilter<$PrismaModel>
    _max?: NestedEnumLoginTypeFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    userId?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumBoardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardType | EnumBoardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardTypeFilter<$PrismaModel> | $Enums.BoardType
  }

  export type BoardImageListRelationFilter = {
    every?: BoardImageWhereInput
    some?: BoardImageWhereInput
    none?: BoardImageWhereInput
  }

  export type CafeBoardListRelationFilter = {
    every?: CafeBoardWhereInput
    some?: CafeBoardWhereInput
    none?: CafeBoardWhereInput
  }

  export type BoardImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeBoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
  }

  export type BoardAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    isReplyAvaliable?: SortOrder
    userId?: SortOrder
    boardType?: SortOrder
  }

  export type BoardSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumBoardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardType | EnumBoardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardTypeWithAggregatesFilter<$PrismaModel> | $Enums.BoardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBoardTypeFilter<$PrismaModel>
    _max?: NestedEnumBoardTypeFilter<$PrismaModel>
  }

  export type BoardScalarRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type BoardImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isThumb?: SortOrder
    isDisable?: SortOrder
    boardId?: SortOrder
  }

  export type BoardImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    boardId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoardReplyNullableScalarRelationFilter = {
    is?: BoardReplyWhereInput | null
    isNot?: BoardReplyWhereInput | null
  }

  export type BoardReplyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    isDisable?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type BoardReplySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    boardId?: SortOrder
    boardReplyId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CafeInfoScalarRelationFilter = {
    is?: CafeInfoWhereInput
    isNot?: CafeInfoWhereInput
  }

  export type CafeBoardCafeBoardUniqueCompoundUniqueInput = {
    boardId: number
    cafeInfoId: number
  }

  export type CafeBoardCountOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
  }

  export type CafeBoardAvgOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeBoardMaxOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
  }

  export type CafeBoardMinOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
    createdAt?: SortOrder
  }

  export type CafeBoardSumOrderByAggregateInput = {
    boardId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type EnumGovermentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GovermentType | EnumGovermentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGovermentTypeFilter<$PrismaModel> | $Enums.GovermentType
  }

  export type CafeInfoListRelationFilter = {
    every?: CafeInfoWhereInput
    some?: CafeInfoWhereInput
    none?: CafeInfoWhereInput
  }

  export type ClosureRegionCategoryListRelationFilter = {
    every?: ClosureRegionCategoryWhereInput
    some?: ClosureRegionCategoryWhereInput
    none?: ClosureRegionCategoryWhereInput
  }

  export type CafeInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClosureRegionCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
  }

  export type RegionCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
  }

  export type RegionCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    isDisable?: SortOrder
    govermentType?: SortOrder
  }

  export type RegionCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGovermentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GovermentType | EnumGovermentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGovermentTypeWithAggregatesFilter<$PrismaModel> | $Enums.GovermentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGovermentTypeFilter<$PrismaModel>
    _max?: NestedEnumGovermentTypeFilter<$PrismaModel>
  }

  export type RegionCategoryScalarRelationFilter = {
    is?: RegionCategoryWhereInput
    isNot?: RegionCategoryWhereInput
  }

  export type ClosureRegionCategoryRegionCategoryTreeUniqueCompoundUniqueInput = {
    ancestor: number
    descendant: number
    depth: number
  }

  export type ClosureRegionCategoryCountOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategoryAvgOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategoryMaxOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategoryMinOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureRegionCategorySumOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type CafeVirtualLinkListRelationFilter = {
    every?: CafeVirtualLinkWhereInput
    some?: CafeVirtualLinkWhereInput
    none?: CafeVirtualLinkWhereInput
  }

  export type CafeThumbnailImageListRelationFilter = {
    every?: CafeThumbnailImageWhereInput
    some?: CafeThumbnailImageWhereInput
    none?: CafeThumbnailImageWhereInput
  }

  export type CafeVirtualImageListRelationFilter = {
    every?: CafeVirtualImageWhereInput
    some?: CafeVirtualImageWhereInput
    none?: CafeVirtualImageWhereInput
  }

  export type CafeRealImageListRelationFilter = {
    every?: CafeRealImageWhereInput
    some?: CafeRealImageWhereInput
    none?: CafeRealImageWhereInput
  }

  export type CafeCouponGoupPartnerListRelationFilter = {
    every?: CafeCouponGoupPartnerWhereInput
    some?: CafeCouponGoupPartnerWhereInput
    none?: CafeCouponGoupPartnerWhereInput
  }

  export type MetaViewerInfoListRelationFilter = {
    every?: MetaViewerInfoWhereInput
    some?: MetaViewerInfoWhereInput
    none?: MetaViewerInfoWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CafeVirtualLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeThumbnailImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeVirtualImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeRealImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponGoupPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaViewerInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
  }

  export type CafeInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    regionCategoryId?: SortOrder
  }

  export type CafeInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
  }

  export type CafeInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    name?: SortOrder
    code?: SortOrder
    regionCategoryId?: SortOrder
    address?: SortOrder
    directions?: SortOrder
    businessNumber?: SortOrder
    ceoName?: SortOrder
  }

  export type CafeInfoSumOrderByAggregateInput = {
    id?: SortOrder
    regionCategoryId?: SortOrder
  }

  export type CafeThumbnailImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeThumbnailImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeRealImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    priority?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageNullableScalarRelationFilter = {
    is?: CafeVirtualLinkThumbnailImageWhereInput | null
    isNot?: CafeVirtualLinkThumbnailImageWhereInput | null
  }

  export type CafeVirtualLinkCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    isDisable?: SortOrder
    isAvaliable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkSumOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeVirtualLinkScalarRelationFilter = {
    is?: CafeVirtualLinkWhereInput
    isNot?: CafeVirtualLinkWhereInput
  }

  export type CafeVirtualLinkThumbnailImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeVirtualLinkThumbnailImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    cafeVirtualLinkId?: SortOrder
  }

  export type CafeCouponListRelationFilter = {
    every?: CafeCouponWhereInput
    some?: CafeCouponWhereInput
    none?: CafeCouponWhereInput
  }

  export type CafeCouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponGroupCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
  }

  export type CafeCouponGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CafeCouponGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
  }

  export type CafeCouponGroupMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    issuanceStartDay?: SortOrder
    issuanceEndDay?: SortOrder
  }

  export type CafeCouponGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CafeCouponGroupScalarRelationFilter = {
    is?: CafeCouponGroupWhereInput
    isNot?: CafeCouponGroupWhereInput
  }

  export type CafeCouponGoupPartnerCafeCouponGroupPartnerUniqueCompoundUniqueInput = {
    cafeCouponGroupId: number
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerCountOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerAvgOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerMaxOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerMinOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type CafeCouponGoupPartnerSumOrderByAggregateInput = {
    cafeCouponGroupId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type EnumProxyUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyUserType | EnumProxyUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyUserTypeFilter<$PrismaModel> | $Enums.ProxyUserType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WishlistProductListRelationFilter = {
    every?: WishlistProductWhereInput
    some?: WishlistProductWhereInput
    none?: WishlistProductWhereInput
  }

  export type WishlistProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxyUserProxyUserUniqueCompoundUniqueInput = {
    memberId: string
    proxyUserType: $Enums.ProxyUserType
  }

  export type ProxyUserCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    proxyUserType?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
  }

  export type ProxyUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumProxyUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyUserType | EnumProxyUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProxyUserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProxyUserTypeFilter<$PrismaModel>
    _max?: NestedEnumProxyUserTypeFilter<$PrismaModel>
  }

  export type ProxyUserScalarRelationFilter = {
    is?: ProxyUserWhereInput
    isNot?: ProxyUserWhereInput
  }

  export type CafeCouponQRCodeListRelationFilter = {
    every?: CafeCouponQRCodeWhereInput
    some?: CafeCouponQRCodeWhereInput
    none?: CafeCouponQRCodeWhereInput
  }

  export type CafeCouponQRCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCouponCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponAvgOrderByAggregateInput = {
    id?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    content?: SortOrder
    serialNumber?: SortOrder
    startDay?: SortOrder
    endDay?: SortOrder
    isDisable?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type CafeCouponSumOrderByAggregateInput = {
    id?: SortOrder
    proxyUserId?: SortOrder
    cafeCouponGroupId?: SortOrder
  }

  export type EnumCafeCouponEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponEventType | EnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeCouponEventTypeFilter<$PrismaModel> | $Enums.CafeCouponEventType
  }

  export type EnumCafeCouponStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponStatus | EnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCafeCouponStatusNullableFilter<$PrismaModel> | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponScalarRelationFilter = {
    is?: CafeCouponWhereInput
    isNot?: CafeCouponWhereInput
  }

  export type CafeCouponHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    cafeCouponId?: SortOrder
    actorId?: SortOrder
  }

  export type CafeCouponHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    cafeCouponId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    actorId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
  }

  export type CafeCouponHistorySumOrderByAggregateInput = {
    id?: SortOrder
    cafeCouponId?: SortOrder
    actorId?: SortOrder
  }

  export type EnumCafeCouponEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponEventType | EnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeCouponEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CafeCouponEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCafeCouponEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCafeCouponEventTypeFilter<$PrismaModel>
  }

  export type EnumCafeCouponStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponStatus | EnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCafeCouponStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CafeCouponStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCafeCouponStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCafeCouponStatusNullableFilter<$PrismaModel>
  }

  export type CafeCouponNullableScalarRelationFilter = {
    is?: CafeCouponWhereInput | null
    isNot?: CafeCouponWhereInput | null
  }

  export type CafeCouponQRCodeCountOrderByAggregateInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeAvgOrderByAggregateInput = {
    cafeCouponId?: SortOrder
    size?: SortOrder
  }

  export type CafeCouponQRCodeMaxOrderByAggregateInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeMinOrderByAggregateInput = {
    serialNumber?: SortOrder
    createdAt?: SortOrder
    isDisable?: SortOrder
    cafeCouponId?: SortOrder
    size?: SortOrder
    base64Data?: SortOrder
  }

  export type CafeCouponQRCodeSumOrderByAggregateInput = {
    cafeCouponId?: SortOrder
    size?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MetaViewerMapListRelationFilter = {
    every?: MetaViewerMapWhereInput
    some?: MetaViewerMapWhereInput
    none?: MetaViewerMapWhereInput
  }

  export type MetaViewerActiveMapNullableScalarRelationFilter = {
    is?: MetaViewerActiveMapWhereInput | null
    isNot?: MetaViewerActiveMapWhereInput | null
  }

  export type MetaViewerMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaViewerInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    worldData?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    code?: SortOrder
    isDisable?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type MetaViewerInfoSumOrderByAggregateInput = {
    id?: SortOrder
    cafeInfoId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumMetaMapTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MetaMapType | EnumMetaMapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetaMapTypeFilter<$PrismaModel> | $Enums.MetaMapType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MetaViewerInfoScalarRelationFilter = {
    is?: MetaViewerInfoWhereInput
    isNot?: MetaViewerInfoWhereInput
  }

  export type MetaViewerActiveMapListRelationFilter = {
    every?: MetaViewerActiveMapWhereInput
    some?: MetaViewerActiveMapWhereInput
    none?: MetaViewerActiveMapWhereInput
  }

  export type MetaViewerActiveMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaViewerMapCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapAvgOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    size?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    version?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentKey?: SortOrder
    isDraco?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type MetaViewerMapSumOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    size?: SortOrder
    metaViewerInfoId?: SortOrder
  }

  export type EnumMetaMapTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetaMapType | EnumMetaMapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetaMapTypeWithAggregatesFilter<$PrismaModel> | $Enums.MetaMapType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetaMapTypeFilter<$PrismaModel>
    _max?: NestedEnumMetaMapTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MetaViewerMapScalarRelationFilter = {
    is?: MetaViewerMapWhereInput
    isNot?: MetaViewerMapWhereInput
  }

  export type MetaViewerActiveMapCountOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapAvgOrderByAggregateInput = {
    id?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapMaxOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapMinOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type MetaViewerActiveMapSumOrderByAggregateInput = {
    id?: SortOrder
    metaViewerInfoId?: SortOrder
    activeRenderMapId?: SortOrder
    activeColliderMapId?: SortOrder
  }

  export type ClosureProductCategoryListRelationFilter = {
    every?: ClosureProductCategoryWhereInput
    some?: ClosureProductCategoryWhereInput
    none?: ClosureProductCategoryWhereInput
  }

  export type ClosureProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDisable?: SortOrder
    code?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type ClosureProductCategoryProductCategoryTreeUniqueCompoundUniqueInput = {
    ancestor: number
    descendant: number
    depth: number
  }

  export type ClosureProductCategoryCountOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategoryAvgOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategoryMaxOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategoryMinOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type ClosureProductCategorySumOrderByAggregateInput = {
    ancestor?: SortOrder
    descendant?: SortOrder
    depth?: SortOrder
  }

  export type CafeInfoNullableScalarRelationFilter = {
    is?: CafeInfoWhereInput | null
    isNot?: CafeInfoWhereInput | null
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    isDisable?: SortOrder
    isAvailable?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
    productRedirectUrl?: SortOrder
    isSignature?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    categoryId?: SortOrder
    cafeInfoId?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type WishlistProductWishlistProductUniqueCompoundUniqueInput = {
    productId: number
    proxyUserId: number
  }

  export type WishlistProductCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type WishlistProductSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    proxyUserId?: SortOrder
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    isDisable?: SortOrder
    isThumb?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    size?: SortOrder
    productId?: SortOrder
  }

  export type BoardCreateNestedManyWithoutUserInput = {
    create?: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput> | BoardCreateWithoutUserInput[] | BoardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutUserInput | BoardCreateOrConnectWithoutUserInput[]
    createMany?: BoardCreateManyUserInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type BoardReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput> | BoardReplyCreateWithoutUserInput[] | BoardReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutUserInput | BoardReplyCreateOrConnectWithoutUserInput[]
    createMany?: BoardReplyCreateManyUserInputEnvelope
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
  }

  export type NoticeCreateNestedManyWithoutUserInput = {
    create?: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput> | NoticeCreateWithoutUserInput[] | NoticeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutUserInput | NoticeCreateOrConnectWithoutUserInput[]
    createMany?: NoticeCreateManyUserInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type ProxyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput> | ProxyUserCreateWithoutUserInput[] | ProxyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProxyUserCreateOrConnectWithoutUserInput | ProxyUserCreateOrConnectWithoutUserInput[]
    createMany?: ProxyUserCreateManyUserInputEnvelope
    connect?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
  }

  export type CafeCouponHistoryCreateNestedManyWithoutActorInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput> | CafeCouponHistoryCreateWithoutActorInput[] | CafeCouponHistoryUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutActorInput | CafeCouponHistoryCreateOrConnectWithoutActorInput[]
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
  }

  export type BoardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput> | BoardCreateWithoutUserInput[] | BoardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutUserInput | BoardCreateOrConnectWithoutUserInput[]
    createMany?: BoardCreateManyUserInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type BoardReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput> | BoardReplyCreateWithoutUserInput[] | BoardReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutUserInput | BoardReplyCreateOrConnectWithoutUserInput[]
    createMany?: BoardReplyCreateManyUserInputEnvelope
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
  }

  export type NoticeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput> | NoticeCreateWithoutUserInput[] | NoticeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutUserInput | NoticeCreateOrConnectWithoutUserInput[]
    createMany?: NoticeCreateManyUserInputEnvelope
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
  }

  export type ProxyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput> | ProxyUserCreateWithoutUserInput[] | ProxyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProxyUserCreateOrConnectWithoutUserInput | ProxyUserCreateOrConnectWithoutUserInput[]
    createMany?: ProxyUserCreateManyUserInputEnvelope
    connect?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
  }

  export type CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput> | CafeCouponHistoryCreateWithoutActorInput[] | CafeCouponHistoryUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutActorInput | CafeCouponHistoryCreateOrConnectWithoutActorInput[]
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumLoginTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoginType
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BoardUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput> | BoardCreateWithoutUserInput[] | BoardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutUserInput | BoardCreateOrConnectWithoutUserInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutUserInput | BoardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoardCreateManyUserInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutUserInput | BoardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutUserInput | BoardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type BoardReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput> | BoardReplyCreateWithoutUserInput[] | BoardReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutUserInput | BoardReplyCreateOrConnectWithoutUserInput[]
    upsert?: BoardReplyUpsertWithWhereUniqueWithoutUserInput | BoardReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoardReplyCreateManyUserInputEnvelope
    set?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    disconnect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    delete?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    update?: BoardReplyUpdateWithWhereUniqueWithoutUserInput | BoardReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoardReplyUpdateManyWithWhereWithoutUserInput | BoardReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
  }

  export type NoticeUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput> | NoticeCreateWithoutUserInput[] | NoticeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutUserInput | NoticeCreateOrConnectWithoutUserInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutUserInput | NoticeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoticeCreateManyUserInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutUserInput | NoticeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutUserInput | NoticeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type ProxyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput> | ProxyUserCreateWithoutUserInput[] | ProxyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProxyUserCreateOrConnectWithoutUserInput | ProxyUserCreateOrConnectWithoutUserInput[]
    upsert?: ProxyUserUpsertWithWhereUniqueWithoutUserInput | ProxyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProxyUserCreateManyUserInputEnvelope
    set?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    disconnect?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    delete?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    connect?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    update?: ProxyUserUpdateWithWhereUniqueWithoutUserInput | ProxyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProxyUserUpdateManyWithWhereWithoutUserInput | ProxyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProxyUserScalarWhereInput | ProxyUserScalarWhereInput[]
  }

  export type CafeCouponHistoryUpdateManyWithoutActorNestedInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput> | CafeCouponHistoryCreateWithoutActorInput[] | CafeCouponHistoryUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutActorInput | CafeCouponHistoryCreateOrConnectWithoutActorInput[]
    upsert?: CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput | CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    set?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    disconnect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    delete?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    update?: CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput | CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CafeCouponHistoryUpdateManyWithWhereWithoutActorInput | CafeCouponHistoryUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CafeCouponHistoryScalarWhereInput | CafeCouponHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput> | BoardCreateWithoutUserInput[] | BoardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutUserInput | BoardCreateOrConnectWithoutUserInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutUserInput | BoardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoardCreateManyUserInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutUserInput | BoardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutUserInput | BoardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type BoardReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput> | BoardReplyCreateWithoutUserInput[] | BoardReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutUserInput | BoardReplyCreateOrConnectWithoutUserInput[]
    upsert?: BoardReplyUpsertWithWhereUniqueWithoutUserInput | BoardReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BoardReplyCreateManyUserInputEnvelope
    set?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    disconnect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    delete?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    update?: BoardReplyUpdateWithWhereUniqueWithoutUserInput | BoardReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BoardReplyUpdateManyWithWhereWithoutUserInput | BoardReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
  }

  export type NoticeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput> | NoticeCreateWithoutUserInput[] | NoticeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoticeCreateOrConnectWithoutUserInput | NoticeCreateOrConnectWithoutUserInput[]
    upsert?: NoticeUpsertWithWhereUniqueWithoutUserInput | NoticeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoticeCreateManyUserInputEnvelope
    set?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    disconnect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    delete?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    connect?: NoticeWhereUniqueInput | NoticeWhereUniqueInput[]
    update?: NoticeUpdateWithWhereUniqueWithoutUserInput | NoticeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoticeUpdateManyWithWhereWithoutUserInput | NoticeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
  }

  export type ProxyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput> | ProxyUserCreateWithoutUserInput[] | ProxyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProxyUserCreateOrConnectWithoutUserInput | ProxyUserCreateOrConnectWithoutUserInput[]
    upsert?: ProxyUserUpsertWithWhereUniqueWithoutUserInput | ProxyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProxyUserCreateManyUserInputEnvelope
    set?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    disconnect?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    delete?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    connect?: ProxyUserWhereUniqueInput | ProxyUserWhereUniqueInput[]
    update?: ProxyUserUpdateWithWhereUniqueWithoutUserInput | ProxyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProxyUserUpdateManyWithWhereWithoutUserInput | ProxyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProxyUserScalarWhereInput | ProxyUserScalarWhereInput[]
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput> | CafeCouponHistoryCreateWithoutActorInput[] | CafeCouponHistoryUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutActorInput | CafeCouponHistoryCreateOrConnectWithoutActorInput[]
    upsert?: CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput | CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CafeCouponHistoryCreateManyActorInputEnvelope
    set?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    disconnect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    delete?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    update?: CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput | CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CafeCouponHistoryUpdateManyWithWhereWithoutActorInput | CafeCouponHistoryUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CafeCouponHistoryScalarWhereInput | CafeCouponHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNoticesInput = {
    create?: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoticesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoticesNestedInput = {
    create?: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoticesInput
    upsert?: UserUpsertWithoutNoticesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoticesInput, UserUpdateWithoutNoticesInput>, UserUncheckedUpdateWithoutNoticesInput>
  }

  export type BoardImageCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput> | BoardImageCreateWithoutBoardInput[] | BoardImageUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardImageCreateOrConnectWithoutBoardInput | BoardImageCreateOrConnectWithoutBoardInput[]
    createMany?: BoardImageCreateManyBoardInputEnvelope
    connect?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
  }

  export type BoardReplyCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput> | BoardReplyCreateWithoutBoardInput[] | BoardReplyUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardInput | BoardReplyCreateOrConnectWithoutBoardInput[]
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBoardsInput = {
    create?: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardsInput
    connect?: UserWhereUniqueInput
  }

  export type CafeBoardCreateNestedManyWithoutBoardInput = {
    create?: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput> | CafeBoardCreateWithoutBoardInput[] | CafeBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutBoardInput | CafeBoardCreateOrConnectWithoutBoardInput[]
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
  }

  export type BoardImageUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput> | BoardImageCreateWithoutBoardInput[] | BoardImageUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardImageCreateOrConnectWithoutBoardInput | BoardImageCreateOrConnectWithoutBoardInput[]
    createMany?: BoardImageCreateManyBoardInputEnvelope
    connect?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
  }

  export type BoardReplyUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput> | BoardReplyCreateWithoutBoardInput[] | BoardReplyUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardInput | BoardReplyCreateOrConnectWithoutBoardInput[]
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
  }

  export type CafeBoardUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput> | CafeBoardCreateWithoutBoardInput[] | CafeBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutBoardInput | CafeBoardCreateOrConnectWithoutBoardInput[]
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumBoardTypeFieldUpdateOperationsInput = {
    set?: $Enums.BoardType
  }

  export type BoardImageUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput> | BoardImageCreateWithoutBoardInput[] | BoardImageUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardImageCreateOrConnectWithoutBoardInput | BoardImageCreateOrConnectWithoutBoardInput[]
    upsert?: BoardImageUpsertWithWhereUniqueWithoutBoardInput | BoardImageUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardImageCreateManyBoardInputEnvelope
    set?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    disconnect?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    delete?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    connect?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    update?: BoardImageUpdateWithWhereUniqueWithoutBoardInput | BoardImageUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardImageUpdateManyWithWhereWithoutBoardInput | BoardImageUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardImageScalarWhereInput | BoardImageScalarWhereInput[]
  }

  export type BoardReplyUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput> | BoardReplyCreateWithoutBoardInput[] | BoardReplyUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardInput | BoardReplyCreateOrConnectWithoutBoardInput[]
    upsert?: BoardReplyUpsertWithWhereUniqueWithoutBoardInput | BoardReplyUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    set?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    disconnect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    delete?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    update?: BoardReplyUpdateWithWhereUniqueWithoutBoardInput | BoardReplyUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardReplyUpdateManyWithWhereWithoutBoardInput | BoardReplyUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardsInput
    upsert?: UserUpsertWithoutBoardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBoardsInput, UserUpdateWithoutBoardsInput>, UserUncheckedUpdateWithoutBoardsInput>
  }

  export type CafeBoardUpdateManyWithoutBoardNestedInput = {
    create?: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput> | CafeBoardCreateWithoutBoardInput[] | CafeBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutBoardInput | CafeBoardCreateOrConnectWithoutBoardInput[]
    upsert?: CafeBoardUpsertWithWhereUniqueWithoutBoardInput | CafeBoardUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    set?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    disconnect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    delete?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    update?: CafeBoardUpdateWithWhereUniqueWithoutBoardInput | CafeBoardUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: CafeBoardUpdateManyWithWhereWithoutBoardInput | CafeBoardUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: CafeBoardScalarWhereInput | CafeBoardScalarWhereInput[]
  }

  export type BoardImageUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput> | BoardImageCreateWithoutBoardInput[] | BoardImageUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardImageCreateOrConnectWithoutBoardInput | BoardImageCreateOrConnectWithoutBoardInput[]
    upsert?: BoardImageUpsertWithWhereUniqueWithoutBoardInput | BoardImageUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardImageCreateManyBoardInputEnvelope
    set?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    disconnect?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    delete?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    connect?: BoardImageWhereUniqueInput | BoardImageWhereUniqueInput[]
    update?: BoardImageUpdateWithWhereUniqueWithoutBoardInput | BoardImageUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardImageUpdateManyWithWhereWithoutBoardInput | BoardImageUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardImageScalarWhereInput | BoardImageScalarWhereInput[]
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput> | BoardReplyCreateWithoutBoardInput[] | BoardReplyUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardInput | BoardReplyCreateOrConnectWithoutBoardInput[]
    upsert?: BoardReplyUpsertWithWhereUniqueWithoutBoardInput | BoardReplyUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardReplyCreateManyBoardInputEnvelope
    set?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    disconnect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    delete?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    update?: BoardReplyUpdateWithWhereUniqueWithoutBoardInput | BoardReplyUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardReplyUpdateManyWithWhereWithoutBoardInput | BoardReplyUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
  }

  export type CafeBoardUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput> | CafeBoardCreateWithoutBoardInput[] | CafeBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutBoardInput | CafeBoardCreateOrConnectWithoutBoardInput[]
    upsert?: CafeBoardUpsertWithWhereUniqueWithoutBoardInput | CafeBoardUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: CafeBoardCreateManyBoardInputEnvelope
    set?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    disconnect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    delete?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    update?: CafeBoardUpdateWithWhereUniqueWithoutBoardInput | CafeBoardUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: CafeBoardUpdateManyWithWhereWithoutBoardInput | CafeBoardUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: CafeBoardScalarWhereInput | CafeBoardScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutBoardImagesInput = {
    create?: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardImagesInput
    connect?: BoardWhereUniqueInput
  }

  export type BoardUpdateOneRequiredWithoutBoardImagesNestedInput = {
    create?: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardImagesInput
    upsert?: BoardUpsertWithoutBoardImagesInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutBoardImagesInput, BoardUpdateWithoutBoardImagesInput>, BoardUncheckedUpdateWithoutBoardImagesInput>
  }

  export type UserCreateNestedOneWithoutBoardRepliesInput = {
    create?: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type BoardCreateNestedOneWithoutBoardRepliesInput = {
    create?: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardRepliesInput
    connect?: BoardWhereUniqueInput
  }

  export type BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput = {
    create?: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardNestedRepliesInput
    connect?: BoardReplyWhereUniqueInput
  }

  export type BoardReplyCreateNestedManyWithoutBoardReplyInput = {
    create?: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput> | BoardReplyCreateWithoutBoardReplyInput[] | BoardReplyUncheckedCreateWithoutBoardReplyInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardReplyInput | BoardReplyCreateOrConnectWithoutBoardReplyInput[]
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
  }

  export type BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput = {
    create?: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput> | BoardReplyCreateWithoutBoardReplyInput[] | BoardReplyUncheckedCreateWithoutBoardReplyInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardReplyInput | BoardReplyCreateOrConnectWithoutBoardReplyInput[]
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBoardRepliesNestedInput = {
    create?: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardRepliesInput
    upsert?: UserUpsertWithoutBoardRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBoardRepliesInput, UserUpdateWithoutBoardRepliesInput>, UserUncheckedUpdateWithoutBoardRepliesInput>
  }

  export type BoardUpdateOneRequiredWithoutBoardRepliesNestedInput = {
    create?: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutBoardRepliesInput
    upsert?: BoardUpsertWithoutBoardRepliesInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutBoardRepliesInput, BoardUpdateWithoutBoardRepliesInput>, BoardUncheckedUpdateWithoutBoardRepliesInput>
  }

  export type BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput = {
    create?: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardNestedRepliesInput
    upsert?: BoardReplyUpsertWithoutBoardNestedRepliesInput
    disconnect?: BoardReplyWhereInput | boolean
    delete?: BoardReplyWhereInput | boolean
    connect?: BoardReplyWhereUniqueInput
    update?: XOR<XOR<BoardReplyUpdateToOneWithWhereWithoutBoardNestedRepliesInput, BoardReplyUpdateWithoutBoardNestedRepliesInput>, BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput>
  }

  export type BoardReplyUpdateManyWithoutBoardReplyNestedInput = {
    create?: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput> | BoardReplyCreateWithoutBoardReplyInput[] | BoardReplyUncheckedCreateWithoutBoardReplyInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardReplyInput | BoardReplyCreateOrConnectWithoutBoardReplyInput[]
    upsert?: BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput | BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput[]
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    set?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    disconnect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    delete?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    update?: BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput | BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput[]
    updateMany?: BoardReplyUpdateManyWithWhereWithoutBoardReplyInput | BoardReplyUpdateManyWithWhereWithoutBoardReplyInput[]
    deleteMany?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput = {
    create?: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput> | BoardReplyCreateWithoutBoardReplyInput[] | BoardReplyUncheckedCreateWithoutBoardReplyInput[]
    connectOrCreate?: BoardReplyCreateOrConnectWithoutBoardReplyInput | BoardReplyCreateOrConnectWithoutBoardReplyInput[]
    upsert?: BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput | BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput[]
    createMany?: BoardReplyCreateManyBoardReplyInputEnvelope
    set?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    disconnect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    delete?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    connect?: BoardReplyWhereUniqueInput | BoardReplyWhereUniqueInput[]
    update?: BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput | BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput[]
    updateMany?: BoardReplyUpdateManyWithWhereWithoutBoardReplyInput | BoardReplyUpdateManyWithWhereWithoutBoardReplyInput[]
    deleteMany?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutCafeBoardsInput = {
    create?: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutCafeBoardsInput
    connect?: BoardWhereUniqueInput
  }

  export type CafeInfoCreateNestedOneWithoutCafeBoardsInput = {
    create?: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeBoardsInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type BoardUpdateOneRequiredWithoutCafeBoardsNestedInput = {
    create?: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutCafeBoardsInput
    upsert?: BoardUpsertWithoutCafeBoardsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutCafeBoardsInput, BoardUpdateWithoutCafeBoardsInput>, BoardUncheckedUpdateWithoutCafeBoardsInput>
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeBoardsNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeBoardsInput
    upsert?: CafeInfoUpsertWithoutCafeBoardsInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutCafeBoardsInput, CafeInfoUpdateWithoutCafeBoardsInput>, CafeInfoUncheckedUpdateWithoutCafeBoardsInput>
  }

  export type CafeInfoCreateNestedManyWithoutRegionCategoryInput = {
    create?: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput> | CafeInfoCreateWithoutRegionCategoryInput[] | CafeInfoUncheckedCreateWithoutRegionCategoryInput[]
    connectOrCreate?: CafeInfoCreateOrConnectWithoutRegionCategoryInput | CafeInfoCreateOrConnectWithoutRegionCategoryInput[]
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    connect?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
  }

  export type ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureRegionCategoryCreateWithoutAncestorCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
  }

  export type ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureRegionCategoryCreateWithoutDescendantCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
  }

  export type CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput = {
    create?: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput> | CafeInfoCreateWithoutRegionCategoryInput[] | CafeInfoUncheckedCreateWithoutRegionCategoryInput[]
    connectOrCreate?: CafeInfoCreateOrConnectWithoutRegionCategoryInput | CafeInfoCreateOrConnectWithoutRegionCategoryInput[]
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    connect?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
  }

  export type ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureRegionCategoryCreateWithoutAncestorCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
  }

  export type ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureRegionCategoryCreateWithoutDescendantCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
  }

  export type EnumGovermentTypeFieldUpdateOperationsInput = {
    set?: $Enums.GovermentType
  }

  export type CafeInfoUpdateManyWithoutRegionCategoryNestedInput = {
    create?: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput> | CafeInfoCreateWithoutRegionCategoryInput[] | CafeInfoUncheckedCreateWithoutRegionCategoryInput[]
    connectOrCreate?: CafeInfoCreateOrConnectWithoutRegionCategoryInput | CafeInfoCreateOrConnectWithoutRegionCategoryInput[]
    upsert?: CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput | CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput[]
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    set?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    disconnect?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    delete?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    connect?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    update?: CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput | CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput[]
    updateMany?: CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput | CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput[]
    deleteMany?: CafeInfoScalarWhereInput | CafeInfoScalarWhereInput[]
  }

  export type ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureRegionCategoryCreateWithoutAncestorCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    upsert?: ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput | ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    set?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    disconnect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    delete?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    update?: ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput | ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput[]
    updateMany?: ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput | ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput[]
    deleteMany?: ClosureRegionCategoryScalarWhereInput | ClosureRegionCategoryScalarWhereInput[]
  }

  export type ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureRegionCategoryCreateWithoutDescendantCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    upsert?: ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput | ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    set?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    disconnect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    delete?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    update?: ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput | ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput[]
    updateMany?: ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput | ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput[]
    deleteMany?: ClosureRegionCategoryScalarWhereInput | ClosureRegionCategoryScalarWhereInput[]
  }

  export type CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput = {
    create?: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput> | CafeInfoCreateWithoutRegionCategoryInput[] | CafeInfoUncheckedCreateWithoutRegionCategoryInput[]
    connectOrCreate?: CafeInfoCreateOrConnectWithoutRegionCategoryInput | CafeInfoCreateOrConnectWithoutRegionCategoryInput[]
    upsert?: CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput | CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput[]
    createMany?: CafeInfoCreateManyRegionCategoryInputEnvelope
    set?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    disconnect?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    delete?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    connect?: CafeInfoWhereUniqueInput | CafeInfoWhereUniqueInput[]
    update?: CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput | CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput[]
    updateMany?: CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput | CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput[]
    deleteMany?: CafeInfoScalarWhereInput | CafeInfoScalarWhereInput[]
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureRegionCategoryCreateWithoutAncestorCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    upsert?: ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput | ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope
    set?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    disconnect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    delete?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    update?: ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput | ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput[]
    updateMany?: ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput | ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput[]
    deleteMany?: ClosureRegionCategoryScalarWhereInput | ClosureRegionCategoryScalarWhereInput[]
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureRegionCategoryCreateWithoutDescendantCategoryInput[] | ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    upsert?: ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput | ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput[]
    createMany?: ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope
    set?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    disconnect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    delete?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    connect?: ClosureRegionCategoryWhereUniqueInput | ClosureRegionCategoryWhereUniqueInput[]
    update?: ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput | ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput[]
    updateMany?: ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput | ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput[]
    deleteMany?: ClosureRegionCategoryScalarWhereInput | ClosureRegionCategoryScalarWhereInput[]
  }

  export type RegionCategoryCreateNestedOneWithoutAncestorCategoriesInput = {
    create?: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutAncestorCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
  }

  export type RegionCategoryCreateNestedOneWithoutDescendantCategoriesInput = {
    create?: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutDescendantCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
  }

  export type RegionCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput = {
    create?: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutAncestorCategoriesInput
    upsert?: RegionCategoryUpsertWithoutAncestorCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
    update?: XOR<XOR<RegionCategoryUpdateToOneWithWhereWithoutAncestorCategoriesInput, RegionCategoryUpdateWithoutAncestorCategoriesInput>, RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
  }

  export type RegionCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput = {
    create?: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutDescendantCategoriesInput
    upsert?: RegionCategoryUpsertWithoutDescendantCategoriesInput
    connect?: RegionCategoryWhereUniqueInput
    update?: XOR<XOR<RegionCategoryUpdateToOneWithWhereWithoutDescendantCategoriesInput, RegionCategoryUpdateWithoutDescendantCategoriesInput>, RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryCreateNestedOneWithoutCafeInfosInput = {
    create?: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutCafeInfosInput
    connect?: RegionCategoryWhereUniqueInput
  }

  export type CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput> | CafeVirtualLinkCreateWithoutCafeInfoInput[] | CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput | CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    connect?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
  }

  export type CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput> | CafeThumbnailImageCreateWithoutCafeInfoInput[] | CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput | CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    connect?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
  }

  export type CafeVirtualImageCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput> | CafeVirtualImageCreateWithoutCafeInfoInput[] | CafeVirtualImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualImageCreateOrConnectWithoutCafeInfoInput | CafeVirtualImageCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    connect?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
  }

  export type CafeRealImageCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput> | CafeRealImageCreateWithoutCafeInfoInput[] | CafeRealImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeRealImageCreateOrConnectWithoutCafeInfoInput | CafeRealImageCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    connect?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
  }

  export type CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput> | CafeCouponGoupPartnerCreateWithoutCafeInfoInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
  }

  export type CafeBoardCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput> | CafeBoardCreateWithoutCafeInfoInput[] | CafeBoardUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutCafeInfoInput | CafeBoardCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
  }

  export type MetaViewerInfoCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput> | MetaViewerInfoCreateWithoutCafeInfoInput[] | MetaViewerInfoUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutCafeInfoInput | MetaViewerInfoCreateOrConnectWithoutCafeInfoInput[]
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    connect?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput> | ProductCreateWithoutCafeInfoInput[] | ProductUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCafeInfoInput | ProductCreateOrConnectWithoutCafeInfoInput[]
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput> | CafeVirtualLinkCreateWithoutCafeInfoInput[] | CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput | CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    connect?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
  }

  export type CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput> | CafeThumbnailImageCreateWithoutCafeInfoInput[] | CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput | CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    connect?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
  }

  export type CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput> | CafeVirtualImageCreateWithoutCafeInfoInput[] | CafeVirtualImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualImageCreateOrConnectWithoutCafeInfoInput | CafeVirtualImageCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    connect?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
  }

  export type CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput> | CafeRealImageCreateWithoutCafeInfoInput[] | CafeRealImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeRealImageCreateOrConnectWithoutCafeInfoInput | CafeRealImageCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    connect?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
  }

  export type CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput> | CafeCouponGoupPartnerCreateWithoutCafeInfoInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
  }

  export type CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput> | CafeBoardCreateWithoutCafeInfoInput[] | CafeBoardUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutCafeInfoInput | CafeBoardCreateOrConnectWithoutCafeInfoInput[]
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
  }

  export type MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput> | MetaViewerInfoCreateWithoutCafeInfoInput[] | MetaViewerInfoUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutCafeInfoInput | MetaViewerInfoCreateOrConnectWithoutCafeInfoInput[]
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    connect?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCafeInfoInput = {
    create?: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput> | ProductCreateWithoutCafeInfoInput[] | ProductUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCafeInfoInput | ProductCreateOrConnectWithoutCafeInfoInput[]
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput = {
    create?: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
    connectOrCreate?: RegionCategoryCreateOrConnectWithoutCafeInfosInput
    upsert?: RegionCategoryUpsertWithoutCafeInfosInput
    connect?: RegionCategoryWhereUniqueInput
    update?: XOR<XOR<RegionCategoryUpdateToOneWithWhereWithoutCafeInfosInput, RegionCategoryUpdateWithoutCafeInfosInput>, RegionCategoryUncheckedUpdateWithoutCafeInfosInput>
  }

  export type CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput> | CafeVirtualLinkCreateWithoutCafeInfoInput[] | CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput | CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput | CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    set?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    disconnect?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    delete?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    connect?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    update?: CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput | CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput | CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeVirtualLinkScalarWhereInput | CafeVirtualLinkScalarWhereInput[]
  }

  export type CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput> | CafeThumbnailImageCreateWithoutCafeInfoInput[] | CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput | CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput | CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    set?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    disconnect?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    delete?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    connect?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    update?: CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput | CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput | CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeThumbnailImageScalarWhereInput | CafeThumbnailImageScalarWhereInput[]
  }

  export type CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput> | CafeVirtualImageCreateWithoutCafeInfoInput[] | CafeVirtualImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualImageCreateOrConnectWithoutCafeInfoInput | CafeVirtualImageCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput | CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    set?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    disconnect?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    delete?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    connect?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    update?: CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput | CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput | CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeVirtualImageScalarWhereInput | CafeVirtualImageScalarWhereInput[]
  }

  export type CafeRealImageUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput> | CafeRealImageCreateWithoutCafeInfoInput[] | CafeRealImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeRealImageCreateOrConnectWithoutCafeInfoInput | CafeRealImageCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput | CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    set?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    disconnect?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    delete?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    connect?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    update?: CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput | CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput | CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeRealImageScalarWhereInput | CafeRealImageScalarWhereInput[]
  }

  export type CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput> | CafeCouponGoupPartnerCreateWithoutCafeInfoInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput | CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    set?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    disconnect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    delete?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    update?: CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput | CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput | CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeCouponGoupPartnerScalarWhereInput | CafeCouponGoupPartnerScalarWhereInput[]
  }

  export type CafeBoardUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput> | CafeBoardCreateWithoutCafeInfoInput[] | CafeBoardUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutCafeInfoInput | CafeBoardCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput | CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    set?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    disconnect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    delete?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    update?: CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput | CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeBoardUpdateManyWithWhereWithoutCafeInfoInput | CafeBoardUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeBoardScalarWhereInput | CafeBoardScalarWhereInput[]
  }

  export type MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput> | MetaViewerInfoCreateWithoutCafeInfoInput[] | MetaViewerInfoUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutCafeInfoInput | MetaViewerInfoCreateOrConnectWithoutCafeInfoInput[]
    upsert?: MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput | MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    set?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    disconnect?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    delete?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    connect?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    update?: MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput | MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput | MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: MetaViewerInfoScalarWhereInput | MetaViewerInfoScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput> | ProductCreateWithoutCafeInfoInput[] | ProductUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCafeInfoInput | ProductCreateOrConnectWithoutCafeInfoInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCafeInfoInput | ProductUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCafeInfoInput | ProductUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCafeInfoInput | ProductUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput> | CafeVirtualLinkCreateWithoutCafeInfoInput[] | CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput | CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput | CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeVirtualLinkCreateManyCafeInfoInputEnvelope
    set?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    disconnect?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    delete?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    connect?: CafeVirtualLinkWhereUniqueInput | CafeVirtualLinkWhereUniqueInput[]
    update?: CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput | CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput | CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeVirtualLinkScalarWhereInput | CafeVirtualLinkScalarWhereInput[]
  }

  export type CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput> | CafeThumbnailImageCreateWithoutCafeInfoInput[] | CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput | CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput | CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeThumbnailImageCreateManyCafeInfoInputEnvelope
    set?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    disconnect?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    delete?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    connect?: CafeThumbnailImageWhereUniqueInput | CafeThumbnailImageWhereUniqueInput[]
    update?: CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput | CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput | CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeThumbnailImageScalarWhereInput | CafeThumbnailImageScalarWhereInput[]
  }

  export type CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput> | CafeVirtualImageCreateWithoutCafeInfoInput[] | CafeVirtualImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeVirtualImageCreateOrConnectWithoutCafeInfoInput | CafeVirtualImageCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput | CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeVirtualImageCreateManyCafeInfoInputEnvelope
    set?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    disconnect?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    delete?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    connect?: CafeVirtualImageWhereUniqueInput | CafeVirtualImageWhereUniqueInput[]
    update?: CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput | CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput | CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeVirtualImageScalarWhereInput | CafeVirtualImageScalarWhereInput[]
  }

  export type CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput> | CafeRealImageCreateWithoutCafeInfoInput[] | CafeRealImageUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeRealImageCreateOrConnectWithoutCafeInfoInput | CafeRealImageCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput | CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeRealImageCreateManyCafeInfoInputEnvelope
    set?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    disconnect?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    delete?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    connect?: CafeRealImageWhereUniqueInput | CafeRealImageWhereUniqueInput[]
    update?: CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput | CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput | CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeRealImageScalarWhereInput | CafeRealImageScalarWhereInput[]
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput> | CafeCouponGoupPartnerCreateWithoutCafeInfoInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput | CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope
    set?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    disconnect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    delete?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    update?: CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput | CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput | CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeCouponGoupPartnerScalarWhereInput | CafeCouponGoupPartnerScalarWhereInput[]
  }

  export type CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput> | CafeBoardCreateWithoutCafeInfoInput[] | CafeBoardUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: CafeBoardCreateOrConnectWithoutCafeInfoInput | CafeBoardCreateOrConnectWithoutCafeInfoInput[]
    upsert?: CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput | CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: CafeBoardCreateManyCafeInfoInputEnvelope
    set?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    disconnect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    delete?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    connect?: CafeBoardWhereUniqueInput | CafeBoardWhereUniqueInput[]
    update?: CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput | CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: CafeBoardUpdateManyWithWhereWithoutCafeInfoInput | CafeBoardUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: CafeBoardScalarWhereInput | CafeBoardScalarWhereInput[]
  }

  export type MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput> | MetaViewerInfoCreateWithoutCafeInfoInput[] | MetaViewerInfoUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutCafeInfoInput | MetaViewerInfoCreateOrConnectWithoutCafeInfoInput[]
    upsert?: MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput | MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: MetaViewerInfoCreateManyCafeInfoInputEnvelope
    set?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    disconnect?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    delete?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    connect?: MetaViewerInfoWhereUniqueInput | MetaViewerInfoWhereUniqueInput[]
    update?: MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput | MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput | MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: MetaViewerInfoScalarWhereInput | MetaViewerInfoScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCafeInfoNestedInput = {
    create?: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput> | ProductCreateWithoutCafeInfoInput[] | ProductUncheckedCreateWithoutCafeInfoInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCafeInfoInput | ProductCreateOrConnectWithoutCafeInfoInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCafeInfoInput | ProductUpsertWithWhereUniqueWithoutCafeInfoInput[]
    createMany?: ProductCreateManyCafeInfoInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCafeInfoInput | ProductUpdateWithWhereUniqueWithoutCafeInfoInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCafeInfoInput | ProductUpdateManyWithWhereWithoutCafeInfoInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CafeInfoCreateNestedOneWithoutCafeThumbnailImagesInput = {
    create?: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeThumbnailImagesInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeThumbnailImagesNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeThumbnailImagesInput
    upsert?: CafeInfoUpsertWithoutCafeThumbnailImagesInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutCafeThumbnailImagesInput, CafeInfoUpdateWithoutCafeThumbnailImagesInput>, CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeVirtualImagesInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualImagesInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeVirtualImagesNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualImagesInput
    upsert?: CafeInfoUpsertWithoutCafeVirtualImagesInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutCafeVirtualImagesInput, CafeInfoUpdateWithoutCafeVirtualImagesInput>, CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeRealImagesInput = {
    create?: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeRealImagesInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeRealImagesNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeRealImagesInput
    upsert?: CafeInfoUpsertWithoutCafeRealImagesInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutCafeRealImagesInput, CafeInfoUpdateWithoutCafeRealImagesInput>, CafeInfoUncheckedUpdateWithoutCafeRealImagesInput>
  }

  export type CafeInfoCreateNestedOneWithoutCafeVirtualLinksInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualLinksInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeVirtualLinkThumbnailImageCreateNestedOneWithoutCafeVirtualLinkInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  export type CafeVirtualLinkThumbnailImageUncheckedCreateNestedOneWithoutCafeVirtualLinkInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeVirtualLinksNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeVirtualLinksInput
    upsert?: CafeInfoUpsertWithoutCafeVirtualLinksInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutCafeVirtualLinksInput, CafeInfoUpdateWithoutCafeVirtualLinksInput>, CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput>
  }

  export type CafeVirtualLinkThumbnailImageUpdateOneWithoutCafeVirtualLinkNestedInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    upsert?: CafeVirtualLinkThumbnailImageUpsertWithoutCafeVirtualLinkInput
    disconnect?: CafeVirtualLinkThumbnailImageWhereInput | boolean
    delete?: CafeVirtualLinkThumbnailImageWhereInput | boolean
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    update?: XOR<XOR<CafeVirtualLinkThumbnailImageUpdateToOneWithWhereWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput>, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateOneWithoutCafeVirtualLinkNestedInput = {
    create?: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    connectOrCreate?: CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput
    upsert?: CafeVirtualLinkThumbnailImageUpsertWithoutCafeVirtualLinkInput
    disconnect?: CafeVirtualLinkThumbnailImageWhereInput | boolean
    delete?: CafeVirtualLinkThumbnailImageWhereInput | boolean
    connect?: CafeVirtualLinkThumbnailImageWhereUniqueInput
    update?: XOR<XOR<CafeVirtualLinkThumbnailImageUpdateToOneWithWhereWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput>, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
  }

  export type CafeVirtualLinkCreateNestedOneWithoutCafeVirtualLinkThumbnailImageInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeVirtualLinkThumbnailImageInput
    connect?: CafeVirtualLinkWhereUniqueInput
  }

  export type CafeVirtualLinkUpdateOneRequiredWithoutCafeVirtualLinkThumbnailImageNestedInput = {
    create?: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
    connectOrCreate?: CafeVirtualLinkCreateOrConnectWithoutCafeVirtualLinkThumbnailImageInput
    upsert?: CafeVirtualLinkUpsertWithoutCafeVirtualLinkThumbnailImageInput
    connect?: CafeVirtualLinkWhereUniqueInput
    update?: XOR<XOR<CafeVirtualLinkUpdateToOneWithWhereWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput>, CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput>
  }

  export type CafeCouponCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponCreateWithoutCafeCouponGroupInput[] | CafeCouponUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponCreateOrConnectWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
  }

  export type CafeCouponGoupPartnerCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
  }

  export type CafeCouponUncheckedCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponCreateWithoutCafeCouponGroupInput[] | CafeCouponUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponCreateOrConnectWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
  }

  export type CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeCouponGroupInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
  }

  export type CafeCouponUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponCreateWithoutCafeCouponGroupInput[] | CafeCouponUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponCreateOrConnectWithoutCafeCouponGroupInput[]
    upsert?: CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    set?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    disconnect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    delete?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    update?: CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput[]
    updateMany?: CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput | CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput[]
    deleteMany?: CafeCouponScalarWhereInput | CafeCouponScalarWhereInput[]
  }

  export type CafeCouponGoupPartnerUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput[]
    upsert?: CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    set?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    disconnect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    delete?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    update?: CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput[]
    updateMany?: CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput | CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput[]
    deleteMany?: CafeCouponGoupPartnerScalarWhereInput | CafeCouponGoupPartnerScalarWhereInput[]
  }

  export type CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponCreateWithoutCafeCouponGroupInput[] | CafeCouponUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponCreateOrConnectWithoutCafeCouponGroupInput[]
    upsert?: CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponCreateManyCafeCouponGroupInputEnvelope
    set?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    disconnect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    delete?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    update?: CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput[]
    updateMany?: CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput | CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput[]
    deleteMany?: CafeCouponScalarWhereInput | CafeCouponScalarWhereInput[]
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupNestedInput = {
    create?: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput> | CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput[] | CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput[]
    connectOrCreate?: CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput | CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput[]
    upsert?: CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput[]
    createMany?: CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope
    set?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    disconnect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    delete?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    connect?: CafeCouponGoupPartnerWhereUniqueInput | CafeCouponGoupPartnerWhereUniqueInput[]
    update?: CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput | CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput[]
    updateMany?: CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput | CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput[]
    deleteMany?: CafeCouponGoupPartnerScalarWhereInput | CafeCouponGoupPartnerScalarWhereInput[]
  }

  export type CafeCouponGroupCreateNestedOneWithoutCafeCouponGoupPartnersInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponGoupPartnersInput
    connect?: CafeCouponGroupWhereUniqueInput
  }

  export type CafeInfoCreateNestedOneWithoutCafeCouponGroupPartnersInput = {
    create?: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeCouponGroupPartnersInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type CafeCouponGroupUpdateOneRequiredWithoutCafeCouponGoupPartnersNestedInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponGoupPartnersInput
    upsert?: CafeCouponGroupUpsertWithoutCafeCouponGoupPartnersInput
    connect?: CafeCouponGroupWhereUniqueInput
    update?: XOR<XOR<CafeCouponGroupUpdateToOneWithWhereWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput>, CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeInfoUpdateOneRequiredWithoutCafeCouponGroupPartnersNestedInput = {
    create?: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutCafeCouponGroupPartnersInput
    upsert?: CafeInfoUpsertWithoutCafeCouponGroupPartnersInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutCafeCouponGroupPartnersInput, CafeInfoUpdateWithoutCafeCouponGroupPartnersInput>, CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput>
  }

  export type UserCreateNestedOneWithoutProxyUsersInput = {
    create?: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyUsersInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCouponCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput> | CafeCouponCreateWithoutProxyUserInput[] | CafeCouponUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutProxyUserInput | CafeCouponCreateOrConnectWithoutProxyUserInput[]
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
  }

  export type WishlistProductCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput> | WishlistProductCreateWithoutProxyUserInput[] | WishlistProductUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProxyUserInput | WishlistProductCreateOrConnectWithoutProxyUserInput[]
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
  }

  export type CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput> | CafeCouponCreateWithoutProxyUserInput[] | CafeCouponUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutProxyUserInput | CafeCouponCreateOrConnectWithoutProxyUserInput[]
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
  }

  export type WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput = {
    create?: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput> | WishlistProductCreateWithoutProxyUserInput[] | WishlistProductUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProxyUserInput | WishlistProductCreateOrConnectWithoutProxyUserInput[]
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
  }

  export type EnumProxyUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProxyUserType
  }

  export type UserUpdateOneWithoutProxyUsersNestedInput = {
    create?: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyUsersInput
    upsert?: UserUpsertWithoutProxyUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProxyUsersInput, UserUpdateWithoutProxyUsersInput>, UserUncheckedUpdateWithoutProxyUsersInput>
  }

  export type CafeCouponUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput> | CafeCouponCreateWithoutProxyUserInput[] | CafeCouponUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutProxyUserInput | CafeCouponCreateOrConnectWithoutProxyUserInput[]
    upsert?: CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput | CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput[]
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    set?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    disconnect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    delete?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    update?: CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput | CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput[]
    updateMany?: CafeCouponUpdateManyWithWhereWithoutProxyUserInput | CafeCouponUpdateManyWithWhereWithoutProxyUserInput[]
    deleteMany?: CafeCouponScalarWhereInput | CafeCouponScalarWhereInput[]
  }

  export type WishlistProductUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput> | WishlistProductCreateWithoutProxyUserInput[] | WishlistProductUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProxyUserInput | WishlistProductCreateOrConnectWithoutProxyUserInput[]
    upsert?: WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput | WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput[]
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    set?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    disconnect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    delete?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    update?: WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput | WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput[]
    updateMany?: WishlistProductUpdateManyWithWhereWithoutProxyUserInput | WishlistProductUpdateManyWithWhereWithoutProxyUserInput[]
    deleteMany?: WishlistProductScalarWhereInput | WishlistProductScalarWhereInput[]
  }

  export type CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput> | CafeCouponCreateWithoutProxyUserInput[] | CafeCouponUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: CafeCouponCreateOrConnectWithoutProxyUserInput | CafeCouponCreateOrConnectWithoutProxyUserInput[]
    upsert?: CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput | CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput[]
    createMany?: CafeCouponCreateManyProxyUserInputEnvelope
    set?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    disconnect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    delete?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    connect?: CafeCouponWhereUniqueInput | CafeCouponWhereUniqueInput[]
    update?: CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput | CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput[]
    updateMany?: CafeCouponUpdateManyWithWhereWithoutProxyUserInput | CafeCouponUpdateManyWithWhereWithoutProxyUserInput[]
    deleteMany?: CafeCouponScalarWhereInput | CafeCouponScalarWhereInput[]
  }

  export type WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput = {
    create?: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput> | WishlistProductCreateWithoutProxyUserInput[] | WishlistProductUncheckedCreateWithoutProxyUserInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProxyUserInput | WishlistProductCreateOrConnectWithoutProxyUserInput[]
    upsert?: WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput | WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput[]
    createMany?: WishlistProductCreateManyProxyUserInputEnvelope
    set?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    disconnect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    delete?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    update?: WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput | WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput[]
    updateMany?: WishlistProductUpdateManyWithWhereWithoutProxyUserInput | WishlistProductUpdateManyWithWhereWithoutProxyUserInput[]
    deleteMany?: WishlistProductScalarWhereInput | WishlistProductScalarWhereInput[]
  }

  export type ProxyUserCreateNestedOneWithoutCafeCouponsInput = {
    create?: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutCafeCouponsInput
    connect?: ProxyUserWhereUniqueInput
  }

  export type CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponsInput
    connect?: CafeCouponGroupWhereUniqueInput
  }

  export type CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput> | CafeCouponQRCodeCreateWithoutCafeCouponInput[] | CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput | CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput[]
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    connect?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
  }

  export type CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput> | CafeCouponHistoryCreateWithoutCafeCouponInput[] | CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput | CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput[]
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
  }

  export type CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput> | CafeCouponQRCodeCreateWithoutCafeCouponInput[] | CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput | CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput[]
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    connect?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
  }

  export type CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput> | CafeCouponHistoryCreateWithoutCafeCouponInput[] | CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput | CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput[]
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
  }

  export type ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput = {
    create?: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutCafeCouponsInput
    upsert?: ProxyUserUpsertWithoutCafeCouponsInput
    connect?: ProxyUserWhereUniqueInput
    update?: XOR<XOR<ProxyUserUpdateToOneWithWhereWithoutCafeCouponsInput, ProxyUserUpdateWithoutCafeCouponsInput>, ProxyUserUncheckedUpdateWithoutCafeCouponsInput>
  }

  export type CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput = {
    create?: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
    connectOrCreate?: CafeCouponGroupCreateOrConnectWithoutCafeCouponsInput
    upsert?: CafeCouponGroupUpsertWithoutCafeCouponsInput
    connect?: CafeCouponGroupWhereUniqueInput
    update?: XOR<XOR<CafeCouponGroupUpdateToOneWithWhereWithoutCafeCouponsInput, CafeCouponGroupUpdateWithoutCafeCouponsInput>, CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput>
  }

  export type CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput> | CafeCouponQRCodeCreateWithoutCafeCouponInput[] | CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput | CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput[]
    upsert?: CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput | CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput[]
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    set?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    disconnect?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    delete?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    connect?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    update?: CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput | CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput[]
    updateMany?: CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput | CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput[]
    deleteMany?: CafeCouponQRCodeScalarWhereInput | CafeCouponQRCodeScalarWhereInput[]
  }

  export type CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput> | CafeCouponHistoryCreateWithoutCafeCouponInput[] | CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput | CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput[]
    upsert?: CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput | CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput[]
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    set?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    disconnect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    delete?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    update?: CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput | CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput[]
    updateMany?: CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput | CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput[]
    deleteMany?: CafeCouponHistoryScalarWhereInput | CafeCouponHistoryScalarWhereInput[]
  }

  export type CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput> | CafeCouponQRCodeCreateWithoutCafeCouponInput[] | CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput | CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput[]
    upsert?: CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput | CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput[]
    createMany?: CafeCouponQRCodeCreateManyCafeCouponInputEnvelope
    set?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    disconnect?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    delete?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    connect?: CafeCouponQRCodeWhereUniqueInput | CafeCouponQRCodeWhereUniqueInput[]
    update?: CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput | CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput[]
    updateMany?: CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput | CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput[]
    deleteMany?: CafeCouponQRCodeScalarWhereInput | CafeCouponQRCodeScalarWhereInput[]
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput = {
    create?: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput> | CafeCouponHistoryCreateWithoutCafeCouponInput[] | CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput[]
    connectOrCreate?: CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput | CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput[]
    upsert?: CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput | CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput[]
    createMany?: CafeCouponHistoryCreateManyCafeCouponInputEnvelope
    set?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    disconnect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    delete?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    connect?: CafeCouponHistoryWhereUniqueInput | CafeCouponHistoryWhereUniqueInput[]
    update?: CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput | CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput[]
    updateMany?: CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput | CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput[]
    deleteMany?: CafeCouponHistoryScalarWhereInput | CafeCouponHistoryScalarWhereInput[]
  }

  export type CafeCouponCreateNestedOneWithoutCafeCouponHistoriesInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponHistoriesInput
    connect?: CafeCouponWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCafeCouponHistoriesInput = {
    create?: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCafeCouponHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCafeCouponEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.CafeCouponEventType
  }

  export type NullableEnumCafeCouponStatusFieldUpdateOperationsInput = {
    set?: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponHistoriesInput
    upsert?: CafeCouponUpsertWithoutCafeCouponHistoriesInput
    connect?: CafeCouponWhereUniqueInput
    update?: XOR<XOR<CafeCouponUpdateToOneWithWhereWithoutCafeCouponHistoriesInput, CafeCouponUpdateWithoutCafeCouponHistoriesInput>, CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput>
  }

  export type UserUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCafeCouponHistoriesInput
    upsert?: UserUpsertWithoutCafeCouponHistoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCafeCouponHistoriesInput, UserUpdateWithoutCafeCouponHistoriesInput>, UserUncheckedUpdateWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponCreateNestedOneWithoutCafeCouponQRCodesInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponQRCodesInput
    connect?: CafeCouponWhereUniqueInput
  }

  export type CafeCouponUpdateOneWithoutCafeCouponQRCodesNestedInput = {
    create?: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
    connectOrCreate?: CafeCouponCreateOrConnectWithoutCafeCouponQRCodesInput
    upsert?: CafeCouponUpsertWithoutCafeCouponQRCodesInput
    disconnect?: CafeCouponWhereInput | boolean
    delete?: CafeCouponWhereInput | boolean
    connect?: CafeCouponWhereUniqueInput
    update?: XOR<XOR<CafeCouponUpdateToOneWithWhereWithoutCafeCouponQRCodesInput, CafeCouponUpdateWithoutCafeCouponQRCodesInput>, CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput>
  }

  export type CafeInfoCreateNestedOneWithoutMetaViewerInfosInput = {
    create?: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutMetaViewerInfosInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput = {
    create?: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput> | MetaViewerMapCreateWithoutMetaViewerInfoInput[] | MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput[]
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput | MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput[]
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    connect?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
  }

  export type MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    connect?: MetaViewerActiveMapWhereUniqueInput
  }

  export type MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput = {
    create?: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput> | MetaViewerMapCreateWithoutMetaViewerInfoInput[] | MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput[]
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput | MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput[]
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    connect?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
  }

  export type MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    connect?: MetaViewerActiveMapWhereUniqueInput
  }

  export type CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput = {
    create?: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutMetaViewerInfosInput
    upsert?: CafeInfoUpsertWithoutMetaViewerInfosInput
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutMetaViewerInfosInput, CafeInfoUpdateWithoutMetaViewerInfosInput>, CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput>
  }

  export type MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput = {
    create?: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput> | MetaViewerMapCreateWithoutMetaViewerInfoInput[] | MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput[]
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput | MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput[]
    upsert?: MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput | MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput[]
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    set?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    disconnect?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    delete?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    connect?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    update?: MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput | MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput[]
    updateMany?: MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput | MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput[]
    deleteMany?: MetaViewerMapScalarWhereInput | MetaViewerMapScalarWhereInput[]
  }

  export type MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    upsert?: MetaViewerActiveMapUpsertWithoutMetaViewerInfoInput
    disconnect?: MetaViewerActiveMapWhereInput | boolean
    delete?: MetaViewerActiveMapWhereInput | boolean
    connect?: MetaViewerActiveMapWhereUniqueInput
    update?: XOR<XOR<MetaViewerActiveMapUpdateToOneWithWhereWithoutMetaViewerInfoInput, MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput>, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput = {
    create?: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput> | MetaViewerMapCreateWithoutMetaViewerInfoInput[] | MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput[]
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput | MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput[]
    upsert?: MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput | MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput[]
    createMany?: MetaViewerMapCreateManyMetaViewerInfoInputEnvelope
    set?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    disconnect?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    delete?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    connect?: MetaViewerMapWhereUniqueInput | MetaViewerMapWhereUniqueInput[]
    update?: MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput | MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput[]
    updateMany?: MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput | MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput[]
    deleteMany?: MetaViewerMapScalarWhereInput | MetaViewerMapScalarWhereInput[]
  }

  export type MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput
    upsert?: MetaViewerActiveMapUpsertWithoutMetaViewerInfoInput
    disconnect?: MetaViewerActiveMapWhereInput | boolean
    delete?: MetaViewerActiveMapWhereInput | boolean
    connect?: MetaViewerActiveMapWhereUniqueInput
    update?: XOR<XOR<MetaViewerActiveMapUpdateToOneWithWhereWithoutMetaViewerInfoInput, MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput>, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput = {
    create?: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutMetaViewerMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
  }

  export type MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput> | MetaViewerActiveMapCreateWithoutActiveRenderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
  }

  export type MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput> | MetaViewerActiveMapCreateWithoutActiveColliderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
  }

  export type MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput> | MetaViewerActiveMapCreateWithoutActiveRenderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
  }

  export type MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput> | MetaViewerActiveMapCreateWithoutActiveColliderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
  }

  export type EnumMetaMapTypeFieldUpdateOperationsInput = {
    set?: $Enums.MetaMapType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput = {
    create?: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutMetaViewerMapsInput
    upsert?: MetaViewerInfoUpsertWithoutMetaViewerMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
    update?: XOR<XOR<MetaViewerInfoUpdateToOneWithWhereWithoutMetaViewerMapsInput, MetaViewerInfoUpdateWithoutMetaViewerMapsInput>, MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput>
  }

  export type MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput> | MetaViewerActiveMapCreateWithoutActiveRenderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput[]
    upsert?: MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput | MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    set?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    disconnect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    delete?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    update?: MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput | MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput[]
    updateMany?: MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput | MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput[]
    deleteMany?: MetaViewerActiveMapScalarWhereInput | MetaViewerActiveMapScalarWhereInput[]
  }

  export type MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput> | MetaViewerActiveMapCreateWithoutActiveColliderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput[]
    upsert?: MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput | MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    set?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    disconnect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    delete?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    update?: MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput | MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput[]
    updateMany?: MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput | MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput[]
    deleteMany?: MetaViewerActiveMapScalarWhereInput | MetaViewerActiveMapScalarWhereInput[]
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput> | MetaViewerActiveMapCreateWithoutActiveRenderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput[]
    upsert?: MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput | MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope
    set?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    disconnect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    delete?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    update?: MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput | MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput[]
    updateMany?: MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput | MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput[]
    deleteMany?: MetaViewerActiveMapScalarWhereInput | MetaViewerActiveMapScalarWhereInput[]
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput = {
    create?: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput> | MetaViewerActiveMapCreateWithoutActiveColliderMapInput[] | MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput[]
    connectOrCreate?: MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput | MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput[]
    upsert?: MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput | MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput[]
    createMany?: MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope
    set?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    disconnect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    delete?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    connect?: MetaViewerActiveMapWhereUniqueInput | MetaViewerActiveMapWhereUniqueInput[]
    update?: MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput | MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput[]
    updateMany?: MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput | MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput[]
    deleteMany?: MetaViewerActiveMapScalarWhereInput | MetaViewerActiveMapScalarWhereInput[]
  }

  export type MetaViewerInfoCreateNestedOneWithoutActiveMapsInput = {
    create?: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutActiveMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
  }

  export type MetaViewerMapCreateNestedOneWithoutActiveRenderForInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveRenderForInput
    connect?: MetaViewerMapWhereUniqueInput
  }

  export type MetaViewerMapCreateNestedOneWithoutActiveColliderForInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveColliderForInput
    connect?: MetaViewerMapWhereUniqueInput
  }

  export type MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput = {
    create?: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
    connectOrCreate?: MetaViewerInfoCreateOrConnectWithoutActiveMapsInput
    upsert?: MetaViewerInfoUpsertWithoutActiveMapsInput
    connect?: MetaViewerInfoWhereUniqueInput
    update?: XOR<XOR<MetaViewerInfoUpdateToOneWithWhereWithoutActiveMapsInput, MetaViewerInfoUpdateWithoutActiveMapsInput>, MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput>
  }

  export type MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveRenderForInput
    upsert?: MetaViewerMapUpsertWithoutActiveRenderForInput
    connect?: MetaViewerMapWhereUniqueInput
    update?: XOR<XOR<MetaViewerMapUpdateToOneWithWhereWithoutActiveRenderForInput, MetaViewerMapUpdateWithoutActiveRenderForInput>, MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput>
  }

  export type MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput = {
    create?: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
    connectOrCreate?: MetaViewerMapCreateOrConnectWithoutActiveColliderForInput
    upsert?: MetaViewerMapUpsertWithoutActiveColliderForInput
    connect?: MetaViewerMapWhereUniqueInput
    update?: XOR<XOR<MetaViewerMapUpdateToOneWithWhereWithoutActiveColliderForInput, MetaViewerMapUpdateWithoutActiveColliderForInput>, MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput>
  }

  export type ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureProductCategoryCreateWithoutAncestorCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
  }

  export type ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureProductCategoryCreateWithoutDescendantCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureProductCategoryCreateWithoutAncestorCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
  }

  export type ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureProductCategoryCreateWithoutDescendantCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureProductCategoryCreateWithoutAncestorCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    upsert?: ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput | ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    set?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    disconnect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    delete?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    update?: ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput | ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput[]
    updateMany?: ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput | ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput[]
    deleteMany?: ClosureProductCategoryScalarWhereInput | ClosureProductCategoryScalarWhereInput[]
  }

  export type ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureProductCategoryCreateWithoutDescendantCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    upsert?: ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput | ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    set?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    disconnect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    delete?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    update?: ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput | ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput[]
    updateMany?: ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput | ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput[]
    deleteMany?: ClosureProductCategoryScalarWhereInput | ClosureProductCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput> | ClosureProductCategoryCreateWithoutAncestorCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput | ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput[]
    upsert?: ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput | ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope
    set?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    disconnect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    delete?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    update?: ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput | ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput[]
    updateMany?: ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput | ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput[]
    deleteMany?: ClosureProductCategoryScalarWhereInput | ClosureProductCategoryScalarWhereInput[]
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput = {
    create?: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput> | ClosureProductCategoryCreateWithoutDescendantCategoryInput[] | ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput[]
    connectOrCreate?: ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput | ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput[]
    upsert?: ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput | ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput[]
    createMany?: ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope
    set?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    disconnect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    delete?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    connect?: ClosureProductCategoryWhereUniqueInput | ClosureProductCategoryWhereUniqueInput[]
    update?: ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput | ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput[]
    updateMany?: ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput | ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput[]
    deleteMany?: ClosureProductCategoryScalarWhereInput | ClosureProductCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryCreateNestedOneWithoutAncestorCategoriesInput = {
    create?: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAncestorCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutDescendantCategoriesInput = {
    create?: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDescendantCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAncestorCategoriesInput
    upsert?: ProductCategoryUpsertWithoutAncestorCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutAncestorCategoriesInput, ProductCategoryUpdateWithoutAncestorCategoriesInput>, ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutDescendantCategoriesInput
    upsert?: ProductCategoryUpsertWithoutDescendantCategoriesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutDescendantCategoriesInput, ProductCategoryUpdateWithoutDescendantCategoriesInput>, ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type CafeInfoCreateNestedOneWithoutProductsInput = {
    create?: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutProductsInput
    connect?: CafeInfoWhereUniqueInput
  }

  export type WishlistProductCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput> | WishlistProductCreateWithoutProductInput[] | WishlistProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProductInput | WishlistProductCreateOrConnectWithoutProductInput[]
    createMany?: WishlistProductCreateManyProductInputEnvelope
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type WishlistProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput> | WishlistProductCreateWithoutProductInput[] | WishlistProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProductInput | WishlistProductCreateOrConnectWithoutProductInput[]
    createMany?: WishlistProductCreateManyProductInputEnvelope
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CafeInfoUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CafeInfoCreateOrConnectWithoutProductsInput
    upsert?: CafeInfoUpsertWithoutProductsInput
    disconnect?: CafeInfoWhereInput | boolean
    delete?: CafeInfoWhereInput | boolean
    connect?: CafeInfoWhereUniqueInput
    update?: XOR<XOR<CafeInfoUpdateToOneWithWhereWithoutProductsInput, CafeInfoUpdateWithoutProductsInput>, CafeInfoUncheckedUpdateWithoutProductsInput>
  }

  export type WishlistProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput> | WishlistProductCreateWithoutProductInput[] | WishlistProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProductInput | WishlistProductCreateOrConnectWithoutProductInput[]
    upsert?: WishlistProductUpsertWithWhereUniqueWithoutProductInput | WishlistProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistProductCreateManyProductInputEnvelope
    set?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    disconnect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    delete?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    update?: WishlistProductUpdateWithWhereUniqueWithoutProductInput | WishlistProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistProductUpdateManyWithWhereWithoutProductInput | WishlistProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistProductScalarWhereInput | WishlistProductScalarWhereInput[]
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type WishlistProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput> | WishlistProductCreateWithoutProductInput[] | WishlistProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistProductCreateOrConnectWithoutProductInput | WishlistProductCreateOrConnectWithoutProductInput[]
    upsert?: WishlistProductUpsertWithWhereUniqueWithoutProductInput | WishlistProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistProductCreateManyProductInputEnvelope
    set?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    disconnect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    delete?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    connect?: WishlistProductWhereUniqueInput | WishlistProductWhereUniqueInput[]
    update?: WishlistProductUpdateWithWhereUniqueWithoutProductInput | WishlistProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistProductUpdateManyWithWhereWithoutProductInput | WishlistProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistProductScalarWhereInput | WishlistProductScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutWishlistProductsInput = {
    create?: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProxyUserCreateNestedOneWithoutWishlistProductsInput = {
    create?: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutWishlistProductsInput
    connect?: ProxyUserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutWishlistProductsNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistProductsInput
    upsert?: ProductUpsertWithoutWishlistProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWishlistProductsInput, ProductUpdateWithoutWishlistProductsInput>, ProductUncheckedUpdateWithoutWishlistProductsInput>
  }

  export type ProxyUserUpdateOneRequiredWithoutWishlistProductsNestedInput = {
    create?: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
    connectOrCreate?: ProxyUserCreateOrConnectWithoutWishlistProductsInput
    upsert?: ProxyUserUpsertWithoutWishlistProductsInput
    connect?: ProxyUserWhereUniqueInput
    update?: XOR<XOR<ProxyUserUpdateToOneWithWhereWithoutWishlistProductsInput, ProxyUserUpdateWithoutWishlistProductsInput>, ProxyUserUncheckedUpdateWithoutWishlistProductsInput>
  }

  export type ProductCreateNestedOneWithoutProductImagesInput = {
    create?: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductImagesNestedInput = {
    create?: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImagesInput
    upsert?: ProductUpsertWithoutProductImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductImagesInput, ProductUpdateWithoutProductImagesInput>, ProductUncheckedUpdateWithoutProductImagesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumLoginTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginType | EnumLoginTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginTypeFilter<$PrismaModel> | $Enums.LoginType
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLoginTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginType | EnumLoginTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoginType[] | ListEnumLoginTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoginTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoginType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoginTypeFilter<$PrismaModel>
    _max?: NestedEnumLoginTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumBoardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardType | EnumBoardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardTypeFilter<$PrismaModel> | $Enums.BoardType
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBoardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BoardType | EnumBoardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BoardType[] | ListEnumBoardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBoardTypeWithAggregatesFilter<$PrismaModel> | $Enums.BoardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBoardTypeFilter<$PrismaModel>
    _max?: NestedEnumBoardTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGovermentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GovermentType | EnumGovermentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGovermentTypeFilter<$PrismaModel> | $Enums.GovermentType
  }

  export type NestedEnumGovermentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GovermentType | EnumGovermentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GovermentType[] | ListEnumGovermentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGovermentTypeWithAggregatesFilter<$PrismaModel> | $Enums.GovermentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGovermentTypeFilter<$PrismaModel>
    _max?: NestedEnumGovermentTypeFilter<$PrismaModel>
  }

  export type NestedEnumProxyUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyUserType | EnumProxyUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyUserTypeFilter<$PrismaModel> | $Enums.ProxyUserType
  }

  export type NestedEnumProxyUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyUserType | EnumProxyUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyUserType[] | ListEnumProxyUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProxyUserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProxyUserTypeFilter<$PrismaModel>
    _max?: NestedEnumProxyUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumCafeCouponEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponEventType | EnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeCouponEventTypeFilter<$PrismaModel> | $Enums.CafeCouponEventType
  }

  export type NestedEnumCafeCouponStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponStatus | EnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCafeCouponStatusNullableFilter<$PrismaModel> | $Enums.CafeCouponStatus | null
  }

  export type NestedEnumCafeCouponEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponEventType | EnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeCouponEventType[] | ListEnumCafeCouponEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeCouponEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CafeCouponEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCafeCouponEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCafeCouponEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumCafeCouponStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeCouponStatus | EnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CafeCouponStatus[] | ListEnumCafeCouponStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCafeCouponStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CafeCouponStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCafeCouponStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCafeCouponStatusNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMetaMapTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MetaMapType | EnumMetaMapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetaMapTypeFilter<$PrismaModel> | $Enums.MetaMapType
  }

  export type NestedEnumMetaMapTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetaMapType | EnumMetaMapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetaMapType[] | ListEnumMetaMapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetaMapTypeWithAggregatesFilter<$PrismaModel> | $Enums.MetaMapType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetaMapTypeFilter<$PrismaModel>
    _max?: NestedEnumMetaMapTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoardCreateWithoutUserInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutUserInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput>
  }

  export type BoardCreateManyUserInputEnvelope = {
    data: BoardCreateManyUserInput | BoardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BoardReplyCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    boardId: number
    boardReplyId?: number | null
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyCreateOrConnectWithoutUserInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput>
  }

  export type BoardReplyCreateManyUserInputEnvelope = {
    data: BoardReplyCreateManyUserInput | BoardReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoticeCreateWithoutUserInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
  }

  export type NoticeUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
  }

  export type NoticeCreateOrConnectWithoutUserInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput>
  }

  export type NoticeCreateManyUserInputEnvelope = {
    data: NoticeCreateManyUserInput | NoticeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProxyUserCreateWithoutUserInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    CafeCoupons?: CafeCouponCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateWithoutUserInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserCreateOrConnectWithoutUserInput = {
    where: ProxyUserWhereUniqueInput
    create: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput>
  }

  export type ProxyUserCreateManyUserInputEnvelope = {
    data: ProxyUserCreateManyUserInput | ProxyUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CafeCouponHistoryCreateWithoutActorInput = {
    createdAt?: Date | string
    eventType: $Enums.CafeCouponEventType
    description: string
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
    CafeCoupon: CafeCouponCreateNestedOneWithoutCafeCouponHistoriesInput
  }

  export type CafeCouponHistoryUncheckedCreateWithoutActorInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: $Enums.CafeCouponEventType
    description: string
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryCreateOrConnectWithoutActorInput = {
    where: CafeCouponHistoryWhereUniqueInput
    create: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput>
  }

  export type CafeCouponHistoryCreateManyActorInputEnvelope = {
    data: CafeCouponHistoryCreateManyActorInput | CafeCouponHistoryCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithWhereUniqueWithoutUserInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutUserInput, BoardUncheckedUpdateWithoutUserInput>
    create: XOR<BoardCreateWithoutUserInput, BoardUncheckedCreateWithoutUserInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutUserInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutUserInput, BoardUncheckedUpdateWithoutUserInput>
  }

  export type BoardUpdateManyWithWhereWithoutUserInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutUserInput>
  }

  export type BoardScalarWhereInput = {
    AND?: BoardScalarWhereInput | BoardScalarWhereInput[]
    OR?: BoardScalarWhereInput[]
    NOT?: BoardScalarWhereInput | BoardScalarWhereInput[]
    id?: IntFilter<"Board"> | number
    createdAt?: DateTimeFilter<"Board"> | Date | string
    title?: StringFilter<"Board"> | string
    content?: StringNullableFilter<"Board"> | string | null
    link?: StringNullableFilter<"Board"> | string | null
    startDay?: DateTimeFilter<"Board"> | Date | string
    endDay?: DateTimeNullableFilter<"Board"> | Date | string | null
    isDisable?: BoolFilter<"Board"> | boolean
    isReplyAvaliable?: BoolFilter<"Board"> | boolean
    userId?: IntFilter<"Board"> | number
    boardType?: EnumBoardTypeFilter<"Board"> | $Enums.BoardType
  }

  export type BoardReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: BoardReplyWhereUniqueInput
    update: XOR<BoardReplyUpdateWithoutUserInput, BoardReplyUncheckedUpdateWithoutUserInput>
    create: XOR<BoardReplyCreateWithoutUserInput, BoardReplyUncheckedCreateWithoutUserInput>
  }

  export type BoardReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: BoardReplyWhereUniqueInput
    data: XOR<BoardReplyUpdateWithoutUserInput, BoardReplyUncheckedUpdateWithoutUserInput>
  }

  export type BoardReplyUpdateManyWithWhereWithoutUserInput = {
    where: BoardReplyScalarWhereInput
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type BoardReplyScalarWhereInput = {
    AND?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
    OR?: BoardReplyScalarWhereInput[]
    NOT?: BoardReplyScalarWhereInput | BoardReplyScalarWhereInput[]
    id?: IntFilter<"BoardReply"> | number
    createdAt?: DateTimeFilter<"BoardReply"> | Date | string
    updatedAt?: DateTimeNullableFilter<"BoardReply"> | Date | string | null
    content?: StringFilter<"BoardReply"> | string
    isDisable?: BoolFilter<"BoardReply"> | boolean
    userId?: IntFilter<"BoardReply"> | number
    boardId?: IntFilter<"BoardReply"> | number
    boardReplyId?: IntNullableFilter<"BoardReply"> | number | null
  }

  export type NoticeUpsertWithWhereUniqueWithoutUserInput = {
    where: NoticeWhereUniqueInput
    update: XOR<NoticeUpdateWithoutUserInput, NoticeUncheckedUpdateWithoutUserInput>
    create: XOR<NoticeCreateWithoutUserInput, NoticeUncheckedCreateWithoutUserInput>
  }

  export type NoticeUpdateWithWhereUniqueWithoutUserInput = {
    where: NoticeWhereUniqueInput
    data: XOR<NoticeUpdateWithoutUserInput, NoticeUncheckedUpdateWithoutUserInput>
  }

  export type NoticeUpdateManyWithWhereWithoutUserInput = {
    where: NoticeScalarWhereInput
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyWithoutUserInput>
  }

  export type NoticeScalarWhereInput = {
    AND?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    OR?: NoticeScalarWhereInput[]
    NOT?: NoticeScalarWhereInput | NoticeScalarWhereInput[]
    id?: IntFilter<"Notice"> | number
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    title?: StringFilter<"Notice"> | string
    content?: StringNullableFilter<"Notice"> | string | null
    link?: StringNullableFilter<"Notice"> | string | null
    userId?: IntFilter<"Notice"> | number
  }

  export type ProxyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ProxyUserWhereUniqueInput
    update: XOR<ProxyUserUpdateWithoutUserInput, ProxyUserUncheckedUpdateWithoutUserInput>
    create: XOR<ProxyUserCreateWithoutUserInput, ProxyUserUncheckedCreateWithoutUserInput>
  }

  export type ProxyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ProxyUserWhereUniqueInput
    data: XOR<ProxyUserUpdateWithoutUserInput, ProxyUserUncheckedUpdateWithoutUserInput>
  }

  export type ProxyUserUpdateManyWithWhereWithoutUserInput = {
    where: ProxyUserScalarWhereInput
    data: XOR<ProxyUserUpdateManyMutationInput, ProxyUserUncheckedUpdateManyWithoutUserInput>
  }

  export type ProxyUserScalarWhereInput = {
    AND?: ProxyUserScalarWhereInput | ProxyUserScalarWhereInput[]
    OR?: ProxyUserScalarWhereInput[]
    NOT?: ProxyUserScalarWhereInput | ProxyUserScalarWhereInput[]
    id?: IntFilter<"ProxyUser"> | number
    memberId?: StringFilter<"ProxyUser"> | string
    createdAt?: DateTimeFilter<"ProxyUser"> | Date | string
    proxyUserType?: EnumProxyUserTypeFilter<"ProxyUser"> | $Enums.ProxyUserType
    name?: StringFilter<"ProxyUser"> | string
    token?: StringFilter<"ProxyUser"> | string
    userId?: IntNullableFilter<"ProxyUser"> | number | null
  }

  export type CafeCouponHistoryUpsertWithWhereUniqueWithoutActorInput = {
    where: CafeCouponHistoryWhereUniqueInput
    update: XOR<CafeCouponHistoryUpdateWithoutActorInput, CafeCouponHistoryUncheckedUpdateWithoutActorInput>
    create: XOR<CafeCouponHistoryCreateWithoutActorInput, CafeCouponHistoryUncheckedCreateWithoutActorInput>
  }

  export type CafeCouponHistoryUpdateWithWhereUniqueWithoutActorInput = {
    where: CafeCouponHistoryWhereUniqueInput
    data: XOR<CafeCouponHistoryUpdateWithoutActorInput, CafeCouponHistoryUncheckedUpdateWithoutActorInput>
  }

  export type CafeCouponHistoryUpdateManyWithWhereWithoutActorInput = {
    where: CafeCouponHistoryScalarWhereInput
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyWithoutActorInput>
  }

  export type CafeCouponHistoryScalarWhereInput = {
    AND?: CafeCouponHistoryScalarWhereInput | CafeCouponHistoryScalarWhereInput[]
    OR?: CafeCouponHistoryScalarWhereInput[]
    NOT?: CafeCouponHistoryScalarWhereInput | CafeCouponHistoryScalarWhereInput[]
    id?: IntFilter<"CafeCouponHistory"> | number
    createdAt?: DateTimeFilter<"CafeCouponHistory"> | Date | string
    cafeCouponId?: IntFilter<"CafeCouponHistory"> | number
    eventType?: EnumCafeCouponEventTypeFilter<"CafeCouponHistory"> | $Enums.CafeCouponEventType
    description?: StringFilter<"CafeCouponHistory"> | string
    actorId?: IntFilter<"CafeCouponHistory"> | number
    statusBefore?: EnumCafeCouponStatusNullableFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
    statusAfter?: EnumCafeCouponStatusNullableFilter<"CafeCouponHistory"> | $Enums.CafeCouponStatus | null
  }

  export type UserCreateWithoutNoticesInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutNoticesInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutNoticesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
  }

  export type UserUpsertWithoutNoticesInput = {
    update: XOR<UserUpdateWithoutNoticesInput, UserUncheckedUpdateWithoutNoticesInput>
    create: XOR<UserCreateWithoutNoticesInput, UserUncheckedCreateWithoutNoticesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoticesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoticesInput, UserUncheckedUpdateWithoutNoticesInput>
  }

  export type UserUpdateWithoutNoticesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type BoardImageCreateWithoutBoardInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
  }

  export type BoardImageUncheckedCreateWithoutBoardInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
  }

  export type BoardImageCreateOrConnectWithoutBoardInput = {
    where: BoardImageWhereUniqueInput
    create: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput>
  }

  export type BoardImageCreateManyBoardInputEnvelope = {
    data: BoardImageCreateManyBoardInput | BoardImageCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type BoardReplyCreateWithoutBoardInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateWithoutBoardInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardReplyId?: number | null
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyCreateOrConnectWithoutBoardInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput>
  }

  export type BoardReplyCreateManyBoardInputEnvelope = {
    data: BoardReplyCreateManyBoardInput | BoardReplyCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBoardsInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutBoardsInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutBoardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
  }

  export type CafeBoardCreateWithoutBoardInput = {
    createdAt?: Date | string
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeBoardsInput
  }

  export type CafeBoardUncheckedCreateWithoutBoardInput = {
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type CafeBoardCreateOrConnectWithoutBoardInput = {
    where: CafeBoardWhereUniqueInput
    create: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput>
  }

  export type CafeBoardCreateManyBoardInputEnvelope = {
    data: CafeBoardCreateManyBoardInput | CafeBoardCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type BoardImageUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardImageWhereUniqueInput
    update: XOR<BoardImageUpdateWithoutBoardInput, BoardImageUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardImageCreateWithoutBoardInput, BoardImageUncheckedCreateWithoutBoardInput>
  }

  export type BoardImageUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardImageWhereUniqueInput
    data: XOR<BoardImageUpdateWithoutBoardInput, BoardImageUncheckedUpdateWithoutBoardInput>
  }

  export type BoardImageUpdateManyWithWhereWithoutBoardInput = {
    where: BoardImageScalarWhereInput
    data: XOR<BoardImageUpdateManyMutationInput, BoardImageUncheckedUpdateManyWithoutBoardInput>
  }

  export type BoardImageScalarWhereInput = {
    AND?: BoardImageScalarWhereInput | BoardImageScalarWhereInput[]
    OR?: BoardImageScalarWhereInput[]
    NOT?: BoardImageScalarWhereInput | BoardImageScalarWhereInput[]
    id?: IntFilter<"BoardImage"> | number
    createdAt?: DateTimeFilter<"BoardImage"> | Date | string
    url?: StringFilter<"BoardImage"> | string
    thumbnailUrl?: StringFilter<"BoardImage"> | string
    width?: IntFilter<"BoardImage"> | number
    height?: IntFilter<"BoardImage"> | number
    size?: IntFilter<"BoardImage"> | number
    isThumb?: BoolFilter<"BoardImage"> | boolean
    isDisable?: BoolFilter<"BoardImage"> | boolean
    boardId?: IntFilter<"BoardImage"> | number
  }

  export type BoardReplyUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardReplyWhereUniqueInput
    update: XOR<BoardReplyUpdateWithoutBoardInput, BoardReplyUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardReplyCreateWithoutBoardInput, BoardReplyUncheckedCreateWithoutBoardInput>
  }

  export type BoardReplyUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardReplyWhereUniqueInput
    data: XOR<BoardReplyUpdateWithoutBoardInput, BoardReplyUncheckedUpdateWithoutBoardInput>
  }

  export type BoardReplyUpdateManyWithWhereWithoutBoardInput = {
    where: BoardReplyScalarWhereInput
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyWithoutBoardInput>
  }

  export type UserUpsertWithoutBoardsInput = {
    update: XOR<UserUpdateWithoutBoardsInput, UserUncheckedUpdateWithoutBoardsInput>
    create: XOR<UserCreateWithoutBoardsInput, UserUncheckedCreateWithoutBoardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBoardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBoardsInput, UserUncheckedUpdateWithoutBoardsInput>
  }

  export type UserUpdateWithoutBoardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CafeBoardUpsertWithWhereUniqueWithoutBoardInput = {
    where: CafeBoardWhereUniqueInput
    update: XOR<CafeBoardUpdateWithoutBoardInput, CafeBoardUncheckedUpdateWithoutBoardInput>
    create: XOR<CafeBoardCreateWithoutBoardInput, CafeBoardUncheckedCreateWithoutBoardInput>
  }

  export type CafeBoardUpdateWithWhereUniqueWithoutBoardInput = {
    where: CafeBoardWhereUniqueInput
    data: XOR<CafeBoardUpdateWithoutBoardInput, CafeBoardUncheckedUpdateWithoutBoardInput>
  }

  export type CafeBoardUpdateManyWithWhereWithoutBoardInput = {
    where: CafeBoardScalarWhereInput
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyWithoutBoardInput>
  }

  export type CafeBoardScalarWhereInput = {
    AND?: CafeBoardScalarWhereInput | CafeBoardScalarWhereInput[]
    OR?: CafeBoardScalarWhereInput[]
    NOT?: CafeBoardScalarWhereInput | CafeBoardScalarWhereInput[]
    boardId?: IntFilter<"CafeBoard"> | number
    cafeInfoId?: IntFilter<"CafeBoard"> | number
    createdAt?: DateTimeFilter<"CafeBoard"> | Date | string
  }

  export type BoardCreateWithoutBoardImagesInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutBoardImagesInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId: number
    boardType?: $Enums.BoardType
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutBoardImagesInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
  }

  export type BoardUpsertWithoutBoardImagesInput = {
    update: XOR<BoardUpdateWithoutBoardImagesInput, BoardUncheckedUpdateWithoutBoardImagesInput>
    create: XOR<BoardCreateWithoutBoardImagesInput, BoardUncheckedCreateWithoutBoardImagesInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutBoardImagesInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutBoardImagesInput, BoardUncheckedUpdateWithoutBoardImagesInput>
  }

  export type BoardUpdateWithoutBoardImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutBoardImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type UserCreateWithoutBoardRepliesInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutBoardRepliesInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutBoardRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
  }

  export type BoardCreateWithoutBoardRepliesInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutBoardRepliesInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId: number
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutBoardRepliesInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
  }

  export type BoardReplyCreateWithoutBoardNestedRepliesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardReply?: BoardReplyCreateNestedOneWithoutBoardNestedRepliesInput
  }

  export type BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    boardReplyId?: number | null
  }

  export type BoardReplyCreateOrConnectWithoutBoardNestedRepliesInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
  }

  export type BoardReplyCreateWithoutBoardReplyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    User: UserCreateNestedOneWithoutBoardRepliesInput
    Board: BoardCreateNestedOneWithoutBoardRepliesInput
    BoardNestedReplies?: BoardReplyCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyUncheckedCreateWithoutBoardReplyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
    BoardNestedReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardReplyInput
  }

  export type BoardReplyCreateOrConnectWithoutBoardReplyInput = {
    where: BoardReplyWhereUniqueInput
    create: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput>
  }

  export type BoardReplyCreateManyBoardReplyInputEnvelope = {
    data: BoardReplyCreateManyBoardReplyInput | BoardReplyCreateManyBoardReplyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBoardRepliesInput = {
    update: XOR<UserUpdateWithoutBoardRepliesInput, UserUncheckedUpdateWithoutBoardRepliesInput>
    create: XOR<UserCreateWithoutBoardRepliesInput, UserUncheckedCreateWithoutBoardRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBoardRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBoardRepliesInput, UserUncheckedUpdateWithoutBoardRepliesInput>
  }

  export type UserUpdateWithoutBoardRepliesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutBoardRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type BoardUpsertWithoutBoardRepliesInput = {
    update: XOR<BoardUpdateWithoutBoardRepliesInput, BoardUncheckedUpdateWithoutBoardRepliesInput>
    create: XOR<BoardCreateWithoutBoardRepliesInput, BoardUncheckedCreateWithoutBoardRepliesInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutBoardRepliesInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutBoardRepliesInput, BoardUncheckedUpdateWithoutBoardRepliesInput>
  }

  export type BoardUpdateWithoutBoardRepliesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutBoardRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardReplyUpsertWithoutBoardNestedRepliesInput = {
    update: XOR<BoardReplyUpdateWithoutBoardNestedRepliesInput, BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput>
    create: XOR<BoardReplyCreateWithoutBoardNestedRepliesInput, BoardReplyUncheckedCreateWithoutBoardNestedRepliesInput>
    where?: BoardReplyWhereInput
  }

  export type BoardReplyUpdateToOneWithWhereWithoutBoardNestedRepliesInput = {
    where?: BoardReplyWhereInput
    data: XOR<BoardReplyUpdateWithoutBoardNestedRepliesInput, BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput>
  }

  export type BoardReplyUpdateWithoutBoardNestedRepliesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutBoardNestedRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BoardReplyUpsertWithWhereUniqueWithoutBoardReplyInput = {
    where: BoardReplyWhereUniqueInput
    update: XOR<BoardReplyUpdateWithoutBoardReplyInput, BoardReplyUncheckedUpdateWithoutBoardReplyInput>
    create: XOR<BoardReplyCreateWithoutBoardReplyInput, BoardReplyUncheckedCreateWithoutBoardReplyInput>
  }

  export type BoardReplyUpdateWithWhereUniqueWithoutBoardReplyInput = {
    where: BoardReplyWhereUniqueInput
    data: XOR<BoardReplyUpdateWithoutBoardReplyInput, BoardReplyUncheckedUpdateWithoutBoardReplyInput>
  }

  export type BoardReplyUpdateManyWithWhereWithoutBoardReplyInput = {
    where: BoardReplyScalarWhereInput
    data: XOR<BoardReplyUpdateManyMutationInput, BoardReplyUncheckedUpdateManyWithoutBoardReplyInput>
  }

  export type BoardCreateWithoutCafeBoardsInput = {
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutBoardInput
    User: UserCreateNestedOneWithoutBoardsInput
  }

  export type BoardUncheckedCreateWithoutCafeBoardsInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    userId: number
    boardType?: $Enums.BoardType
    BoardImages?: BoardImageUncheckedCreateNestedManyWithoutBoardInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutCafeBoardsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
  }

  export type CafeInfoCreateWithoutCafeBoardsInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeBoardsInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeBoardsInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
  }

  export type BoardUpsertWithoutCafeBoardsInput = {
    update: XOR<BoardUpdateWithoutCafeBoardsInput, BoardUncheckedUpdateWithoutCafeBoardsInput>
    create: XOR<BoardCreateWithoutCafeBoardsInput, BoardUncheckedCreateWithoutCafeBoardsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutCafeBoardsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutCafeBoardsInput, BoardUncheckedUpdateWithoutCafeBoardsInput>
  }

  export type BoardUpdateWithoutCafeBoardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    User?: UserUpdateOneRequiredWithoutBoardsNestedInput
  }

  export type BoardUncheckedUpdateWithoutCafeBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type CafeInfoUpsertWithoutCafeBoardsInput = {
    update: XOR<CafeInfoUpdateWithoutCafeBoardsInput, CafeInfoUncheckedUpdateWithoutCafeBoardsInput>
    create: XOR<CafeInfoCreateWithoutCafeBoardsInput, CafeInfoUncheckedCreateWithoutCafeBoardsInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutCafeBoardsInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutCafeBoardsInput, CafeInfoUncheckedUpdateWithoutCafeBoardsInput>
  }

  export type CafeInfoUpdateWithoutCafeBoardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeBoardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutRegionCategoryInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutRegionCategoryInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutRegionCategoryInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput>
  }

  export type CafeInfoCreateManyRegionCategoryInputEnvelope = {
    data: CafeInfoCreateManyRegionCategoryInput | CafeInfoCreateManyRegionCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ClosureRegionCategoryCreateWithoutAncestorCategoryInput = {
    depth?: number
    DescendantCategory: RegionCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryCreateOrConnectWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    create: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryCreateManyAncestorCategoryInputEnvelope = {
    data: ClosureRegionCategoryCreateManyAncestorCategoryInput | ClosureRegionCategoryCreateManyAncestorCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ClosureRegionCategoryCreateWithoutDescendantCategoryInput = {
    depth?: number
    AncestorCategory: RegionCategoryCreateNestedOneWithoutAncestorCategoriesInput
  }

  export type ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type ClosureRegionCategoryCreateOrConnectWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    create: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureRegionCategoryCreateManyDescendantCategoryInputEnvelope = {
    data: ClosureRegionCategoryCreateManyDescendantCategoryInput | ClosureRegionCategoryCreateManyDescendantCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CafeInfoUpsertWithWhereUniqueWithoutRegionCategoryInput = {
    where: CafeInfoWhereUniqueInput
    update: XOR<CafeInfoUpdateWithoutRegionCategoryInput, CafeInfoUncheckedUpdateWithoutRegionCategoryInput>
    create: XOR<CafeInfoCreateWithoutRegionCategoryInput, CafeInfoUncheckedCreateWithoutRegionCategoryInput>
  }

  export type CafeInfoUpdateWithWhereUniqueWithoutRegionCategoryInput = {
    where: CafeInfoWhereUniqueInput
    data: XOR<CafeInfoUpdateWithoutRegionCategoryInput, CafeInfoUncheckedUpdateWithoutRegionCategoryInput>
  }

  export type CafeInfoUpdateManyWithWhereWithoutRegionCategoryInput = {
    where: CafeInfoScalarWhereInput
    data: XOR<CafeInfoUpdateManyMutationInput, CafeInfoUncheckedUpdateManyWithoutRegionCategoryInput>
  }

  export type CafeInfoScalarWhereInput = {
    AND?: CafeInfoScalarWhereInput | CafeInfoScalarWhereInput[]
    OR?: CafeInfoScalarWhereInput[]
    NOT?: CafeInfoScalarWhereInput | CafeInfoScalarWhereInput[]
    id?: IntFilter<"CafeInfo"> | number
    createdAt?: DateTimeFilter<"CafeInfo"> | Date | string
    isDisable?: BoolFilter<"CafeInfo"> | boolean
    name?: StringFilter<"CafeInfo"> | string
    code?: StringNullableFilter<"CafeInfo"> | string | null
    regionCategoryId?: IntFilter<"CafeInfo"> | number
    address?: StringFilter<"CafeInfo"> | string
    directions?: StringFilter<"CafeInfo"> | string
    businessNumber?: StringFilter<"CafeInfo"> | string
    ceoName?: StringFilter<"CafeInfo"> | string
  }

  export type ClosureRegionCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    update: XOR<ClosureRegionCategoryUpdateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutAncestorCategoryInput>
    create: XOR<ClosureRegionCategoryCreateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    data: XOR<ClosureRegionCategoryUpdateWithoutAncestorCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryUpdateManyWithWhereWithoutAncestorCategoryInput = {
    where: ClosureRegionCategoryScalarWhereInput
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryInput>
  }

  export type ClosureRegionCategoryScalarWhereInput = {
    AND?: ClosureRegionCategoryScalarWhereInput | ClosureRegionCategoryScalarWhereInput[]
    OR?: ClosureRegionCategoryScalarWhereInput[]
    NOT?: ClosureRegionCategoryScalarWhereInput | ClosureRegionCategoryScalarWhereInput[]
    ancestor?: IntFilter<"ClosureRegionCategory"> | number
    descendant?: IntFilter<"ClosureRegionCategory"> | number
    depth?: IntFilter<"ClosureRegionCategory"> | number
  }

  export type ClosureRegionCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    update: XOR<ClosureRegionCategoryUpdateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutDescendantCategoryInput>
    create: XOR<ClosureRegionCategoryCreateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureRegionCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryWhereUniqueInput
    data: XOR<ClosureRegionCategoryUpdateWithoutDescendantCategoryInput, ClosureRegionCategoryUncheckedUpdateWithoutDescendantCategoryInput>
  }

  export type ClosureRegionCategoryUpdateManyWithWhereWithoutDescendantCategoryInput = {
    where: ClosureRegionCategoryScalarWhereInput
    data: XOR<ClosureRegionCategoryUpdateManyMutationInput, ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryInput>
  }

  export type RegionCategoryCreateWithoutAncestorCategoriesInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    CafeInfos?: CafeInfoCreateNestedManyWithoutRegionCategoryInput
    DescendantCategories?: ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    CafeInfos?: CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput
    DescendantCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryCreateOrConnectWithoutAncestorCategoriesInput = {
    where: RegionCategoryWhereUniqueInput
    create: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
  }

  export type RegionCategoryCreateWithoutDescendantCategoriesInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    CafeInfos?: CafeInfoCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput
  }

  export type RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    CafeInfos?: CafeInfoUncheckedCreateNestedManyWithoutRegionCategoryInput
    AncestorCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
  }

  export type RegionCategoryCreateOrConnectWithoutDescendantCategoriesInput = {
    where: RegionCategoryWhereUniqueInput
    create: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryUpsertWithoutAncestorCategoriesInput = {
    update: XOR<RegionCategoryUpdateWithoutAncestorCategoriesInput, RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
    create: XOR<RegionCategoryCreateWithoutAncestorCategoriesInput, RegionCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    where?: RegionCategoryWhereInput
  }

  export type RegionCategoryUpdateToOneWithWhereWithoutAncestorCategoriesInput = {
    where?: RegionCategoryWhereInput
    data: XOR<RegionCategoryUpdateWithoutAncestorCategoriesInput, RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
  }

  export type RegionCategoryUpdateWithoutAncestorCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    CafeInfos?: CafeInfoUpdateManyWithoutRegionCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateWithoutAncestorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    CafeInfos?: CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUpsertWithoutDescendantCategoriesInput = {
    update: XOR<RegionCategoryUpdateWithoutDescendantCategoriesInput, RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
    create: XOR<RegionCategoryCreateWithoutDescendantCategoriesInput, RegionCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    where?: RegionCategoryWhereInput
  }

  export type RegionCategoryUpdateToOneWithWhereWithoutDescendantCategoriesInput = {
    where?: RegionCategoryWhereInput
    data: XOR<RegionCategoryUpdateWithoutDescendantCategoriesInput, RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
  }

  export type RegionCategoryUpdateWithoutDescendantCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    CafeInfos?: CafeInfoUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateWithoutDescendantCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    CafeInfos?: CafeInfoUncheckedUpdateManyWithoutRegionCategoryNestedInput
    AncestorCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
  }

  export type RegionCategoryCreateWithoutCafeInfosInput = {
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    AncestorCategories?: ClosureRegionCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryUncheckedCreateWithoutCafeInfosInput = {
    id?: number
    createdAt?: Date | string
    name: string
    isDisable?: boolean
    govermentType: $Enums.GovermentType
    AncestorCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureRegionCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type RegionCategoryCreateOrConnectWithoutCafeInfosInput = {
    where: RegionCategoryWhereUniqueInput
    create: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
  }

  export type CafeVirtualLinkCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedCreateNestedOneWithoutCafeVirtualLinkInput
  }

  export type CafeVirtualLinkCreateOrConnectWithoutCafeInfoInput = {
    where: CafeVirtualLinkWhereUniqueInput
    create: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkCreateManyCafeInfoInputEnvelope = {
    data: CafeVirtualLinkCreateManyCafeInfoInput | CafeVirtualLinkCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type CafeThumbnailImageCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeThumbnailImageCreateOrConnectWithoutCafeInfoInput = {
    where: CafeThumbnailImageWhereUniqueInput
    create: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageCreateManyCafeInfoInputEnvelope = {
    data: CafeThumbnailImageCreateManyCafeInfoInput | CafeThumbnailImageCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type CafeVirtualImageCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeVirtualImageUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeVirtualImageCreateOrConnectWithoutCafeInfoInput = {
    where: CafeVirtualImageWhereUniqueInput
    create: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualImageCreateManyCafeInfoInputEnvelope = {
    data: CafeVirtualImageCreateManyCafeInfoInput | CafeVirtualImageCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type CafeRealImageCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeRealImageUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeRealImageCreateOrConnectWithoutCafeInfoInput = {
    where: CafeRealImageWhereUniqueInput
    create: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeRealImageCreateManyCafeInfoInputEnvelope = {
    data: CafeRealImageCreateManyCafeInfoInput | CafeRealImageCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type CafeCouponGoupPartnerCreateWithoutCafeInfoInput = {
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponGoupPartnersInput
  }

  export type CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput = {
    cafeCouponGroupId: number
  }

  export type CafeCouponGoupPartnerCreateOrConnectWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerCreateManyCafeInfoInputEnvelope = {
    data: CafeCouponGoupPartnerCreateManyCafeInfoInput | CafeCouponGoupPartnerCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type CafeBoardCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutCafeBoardsInput
  }

  export type CafeBoardUncheckedCreateWithoutCafeInfoInput = {
    boardId: number
    createdAt?: Date | string
  }

  export type CafeBoardCreateOrConnectWithoutCafeInfoInput = {
    where: CafeBoardWhereUniqueInput
    create: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeBoardCreateManyCafeInfoInputEnvelope = {
    data: CafeBoardCreateManyCafeInfoInput | CafeBoardCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type MetaViewerInfoCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput
    ActiveMaps?: MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoCreateOrConnectWithoutCafeInfoInput = {
    where: MetaViewerInfoWhereUniqueInput
    create: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>
  }

  export type MetaViewerInfoCreateManyCafeInfoInputEnvelope = {
    data: MetaViewerInfoCreateManyCafeInfoInput | MetaViewerInfoCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCafeInfoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    productRedirectUrl?: string | null
    isSignature?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    productRedirectUrl?: string | null
    isSignature?: boolean
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCafeInfoInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput>
  }

  export type ProductCreateManyCafeInfoInputEnvelope = {
    data: ProductCreateManyCafeInfoInput | ProductCreateManyCafeInfoInput[]
    skipDuplicates?: boolean
  }

  export type RegionCategoryUpsertWithoutCafeInfosInput = {
    update: XOR<RegionCategoryUpdateWithoutCafeInfosInput, RegionCategoryUncheckedUpdateWithoutCafeInfosInput>
    create: XOR<RegionCategoryCreateWithoutCafeInfosInput, RegionCategoryUncheckedCreateWithoutCafeInfosInput>
    where?: RegionCategoryWhereInput
  }

  export type RegionCategoryUpdateToOneWithWhereWithoutCafeInfosInput = {
    where?: RegionCategoryWhereInput
    data: XOR<RegionCategoryUpdateWithoutCafeInfosInput, RegionCategoryUncheckedUpdateWithoutCafeInfosInput>
  }

  export type RegionCategoryUpdateWithoutCafeInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    AncestorCategories?: ClosureRegionCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type RegionCategoryUncheckedUpdateWithoutCafeInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    govermentType?: EnumGovermentTypeFieldUpdateOperationsInput | $Enums.GovermentType
    AncestorCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type CafeVirtualLinkUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualLinkWhereUniqueInput
    update: XOR<CafeVirtualLinkUpdateWithoutCafeInfoInput, CafeVirtualLinkUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeVirtualLinkCreateWithoutCafeInfoInput, CafeVirtualLinkUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualLinkWhereUniqueInput
    data: XOR<CafeVirtualLinkUpdateWithoutCafeInfoInput, CafeVirtualLinkUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeVirtualLinkScalarWhereInput
    data: XOR<CafeVirtualLinkUpdateManyMutationInput, CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type CafeVirtualLinkScalarWhereInput = {
    AND?: CafeVirtualLinkScalarWhereInput | CafeVirtualLinkScalarWhereInput[]
    OR?: CafeVirtualLinkScalarWhereInput[]
    NOT?: CafeVirtualLinkScalarWhereInput | CafeVirtualLinkScalarWhereInput[]
    id?: IntFilter<"CafeVirtualLink"> | number
    createdAt?: DateTimeFilter<"CafeVirtualLink"> | Date | string
    name?: StringFilter<"CafeVirtualLink"> | string
    url?: StringFilter<"CafeVirtualLink"> | string
    type?: StringFilter<"CafeVirtualLink"> | string
    isDisable?: BoolFilter<"CafeVirtualLink"> | boolean
    isAvaliable?: BoolFilter<"CafeVirtualLink"> | boolean
    cafeInfoId?: IntFilter<"CafeVirtualLink"> | number
  }

  export type CafeThumbnailImageUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeThumbnailImageWhereUniqueInput
    update: XOR<CafeThumbnailImageUpdateWithoutCafeInfoInput, CafeThumbnailImageUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeThumbnailImageCreateWithoutCafeInfoInput, CafeThumbnailImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeThumbnailImageWhereUniqueInput
    data: XOR<CafeThumbnailImageUpdateWithoutCafeInfoInput, CafeThumbnailImageUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeThumbnailImageScalarWhereInput
    data: XOR<CafeThumbnailImageUpdateManyMutationInput, CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type CafeThumbnailImageScalarWhereInput = {
    AND?: CafeThumbnailImageScalarWhereInput | CafeThumbnailImageScalarWhereInput[]
    OR?: CafeThumbnailImageScalarWhereInput[]
    NOT?: CafeThumbnailImageScalarWhereInput | CafeThumbnailImageScalarWhereInput[]
    id?: IntFilter<"CafeThumbnailImage"> | number
    createdAt?: DateTimeFilter<"CafeThumbnailImage"> | Date | string
    url?: StringFilter<"CafeThumbnailImage"> | string
    thumbnailUrl?: StringFilter<"CafeThumbnailImage"> | string
    width?: IntFilter<"CafeThumbnailImage"> | number
    height?: IntFilter<"CafeThumbnailImage"> | number
    size?: IntFilter<"CafeThumbnailImage"> | number
    priority?: IntFilter<"CafeThumbnailImage"> | number
    isDisable?: BoolFilter<"CafeThumbnailImage"> | boolean
    cafeInfoId?: IntFilter<"CafeThumbnailImage"> | number
  }

  export type CafeVirtualImageUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualImageWhereUniqueInput
    update: XOR<CafeVirtualImageUpdateWithoutCafeInfoInput, CafeVirtualImageUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeVirtualImageCreateWithoutCafeInfoInput, CafeVirtualImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeVirtualImageUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeVirtualImageWhereUniqueInput
    data: XOR<CafeVirtualImageUpdateWithoutCafeInfoInput, CafeVirtualImageUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeVirtualImageUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeVirtualImageScalarWhereInput
    data: XOR<CafeVirtualImageUpdateManyMutationInput, CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type CafeVirtualImageScalarWhereInput = {
    AND?: CafeVirtualImageScalarWhereInput | CafeVirtualImageScalarWhereInput[]
    OR?: CafeVirtualImageScalarWhereInput[]
    NOT?: CafeVirtualImageScalarWhereInput | CafeVirtualImageScalarWhereInput[]
    id?: IntFilter<"CafeVirtualImage"> | number
    createdAt?: DateTimeFilter<"CafeVirtualImage"> | Date | string
    url?: StringFilter<"CafeVirtualImage"> | string
    width?: IntFilter<"CafeVirtualImage"> | number
    height?: IntFilter<"CafeVirtualImage"> | number
    size?: IntFilter<"CafeVirtualImage"> | number
    priority?: IntFilter<"CafeVirtualImage"> | number
    isDisable?: BoolFilter<"CafeVirtualImage"> | boolean
    cafeInfoId?: IntFilter<"CafeVirtualImage"> | number
  }

  export type CafeRealImageUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeRealImageWhereUniqueInput
    update: XOR<CafeRealImageUpdateWithoutCafeInfoInput, CafeRealImageUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeRealImageCreateWithoutCafeInfoInput, CafeRealImageUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeRealImageUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeRealImageWhereUniqueInput
    data: XOR<CafeRealImageUpdateWithoutCafeInfoInput, CafeRealImageUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeRealImageUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeRealImageScalarWhereInput
    data: XOR<CafeRealImageUpdateManyMutationInput, CafeRealImageUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type CafeRealImageScalarWhereInput = {
    AND?: CafeRealImageScalarWhereInput | CafeRealImageScalarWhereInput[]
    OR?: CafeRealImageScalarWhereInput[]
    NOT?: CafeRealImageScalarWhereInput | CafeRealImageScalarWhereInput[]
    id?: IntFilter<"CafeRealImage"> | number
    createdAt?: DateTimeFilter<"CafeRealImage"> | Date | string
    url?: StringFilter<"CafeRealImage"> | string
    width?: IntFilter<"CafeRealImage"> | number
    height?: IntFilter<"CafeRealImage"> | number
    size?: IntFilter<"CafeRealImage"> | number
    priority?: IntFilter<"CafeRealImage"> | number
    isDisable?: BoolFilter<"CafeRealImage"> | boolean
    cafeInfoId?: IntFilter<"CafeRealImage"> | number
  }

  export type CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    update: XOR<CafeCouponGoupPartnerUpdateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    data: XOR<CafeCouponGoupPartnerUpdateWithoutCafeInfoInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeCouponGoupPartnerScalarWhereInput
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type CafeCouponGoupPartnerScalarWhereInput = {
    AND?: CafeCouponGoupPartnerScalarWhereInput | CafeCouponGoupPartnerScalarWhereInput[]
    OR?: CafeCouponGoupPartnerScalarWhereInput[]
    NOT?: CafeCouponGoupPartnerScalarWhereInput | CafeCouponGoupPartnerScalarWhereInput[]
    cafeCouponGroupId?: IntFilter<"CafeCouponGoupPartner"> | number
    cafeInfoId?: IntFilter<"CafeCouponGoupPartner"> | number
  }

  export type CafeBoardUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeBoardWhereUniqueInput
    update: XOR<CafeBoardUpdateWithoutCafeInfoInput, CafeBoardUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<CafeBoardCreateWithoutCafeInfoInput, CafeBoardUncheckedCreateWithoutCafeInfoInput>
  }

  export type CafeBoardUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: CafeBoardWhereUniqueInput
    data: XOR<CafeBoardUpdateWithoutCafeInfoInput, CafeBoardUncheckedUpdateWithoutCafeInfoInput>
  }

  export type CafeBoardUpdateManyWithWhereWithoutCafeInfoInput = {
    where: CafeBoardScalarWhereInput
    data: XOR<CafeBoardUpdateManyMutationInput, CafeBoardUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type MetaViewerInfoUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: MetaViewerInfoWhereUniqueInput
    update: XOR<MetaViewerInfoUpdateWithoutCafeInfoInput, MetaViewerInfoUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<MetaViewerInfoCreateWithoutCafeInfoInput, MetaViewerInfoUncheckedCreateWithoutCafeInfoInput>
  }

  export type MetaViewerInfoUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: MetaViewerInfoWhereUniqueInput
    data: XOR<MetaViewerInfoUpdateWithoutCafeInfoInput, MetaViewerInfoUncheckedUpdateWithoutCafeInfoInput>
  }

  export type MetaViewerInfoUpdateManyWithWhereWithoutCafeInfoInput = {
    where: MetaViewerInfoScalarWhereInput
    data: XOR<MetaViewerInfoUpdateManyMutationInput, MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type MetaViewerInfoScalarWhereInput = {
    AND?: MetaViewerInfoScalarWhereInput | MetaViewerInfoScalarWhereInput[]
    OR?: MetaViewerInfoScalarWhereInput[]
    NOT?: MetaViewerInfoScalarWhereInput | MetaViewerInfoScalarWhereInput[]
    id?: IntFilter<"MetaViewerInfo"> | number
    createdAt?: DateTimeFilter<"MetaViewerInfo"> | Date | string
    code?: StringFilter<"MetaViewerInfo"> | string
    isDisable?: BoolFilter<"MetaViewerInfo"> | boolean
    worldData?: JsonFilter<"MetaViewerInfo">
    cafeInfoId?: IntFilter<"MetaViewerInfo"> | number
  }

  export type ProductUpsertWithWhereUniqueWithoutCafeInfoInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCafeInfoInput, ProductUncheckedUpdateWithoutCafeInfoInput>
    create: XOR<ProductCreateWithoutCafeInfoInput, ProductUncheckedCreateWithoutCafeInfoInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCafeInfoInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCafeInfoInput, ProductUncheckedUpdateWithoutCafeInfoInput>
  }

  export type ProductUpdateManyWithWhereWithoutCafeInfoInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCafeInfoInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: IntFilter<"Product"> | number
    originalPrice?: IntNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    minOrderQuantity?: IntFilter<"Product"> | number
    isDisable?: BoolFilter<"Product"> | boolean
    isAvailable?: BoolFilter<"Product"> | boolean
    categoryId?: IntFilter<"Product"> | number
    cafeInfoId?: IntNullableFilter<"Product"> | number | null
    productRedirectUrl?: StringNullableFilter<"Product"> | string | null
    isSignature?: BoolFilter<"Product"> | boolean
  }

  export type CafeInfoCreateWithoutCafeThumbnailImagesInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeThumbnailImagesInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
  }

  export type CafeInfoUpsertWithoutCafeThumbnailImagesInput = {
    update: XOR<CafeInfoUpdateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput>
    create: XOR<CafeInfoCreateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedCreateWithoutCafeThumbnailImagesInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutCafeThumbnailImagesInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutCafeThumbnailImagesInput, CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput>
  }

  export type CafeInfoUpdateWithoutCafeThumbnailImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeThumbnailImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutCafeVirtualImagesInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeVirtualImagesInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
  }

  export type CafeInfoUpsertWithoutCafeVirtualImagesInput = {
    update: XOR<CafeInfoUpdateWithoutCafeVirtualImagesInput, CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput>
    create: XOR<CafeInfoCreateWithoutCafeVirtualImagesInput, CafeInfoUncheckedCreateWithoutCafeVirtualImagesInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutCafeVirtualImagesInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutCafeVirtualImagesInput, CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput>
  }

  export type CafeInfoUpdateWithoutCafeVirtualImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeVirtualImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutCafeRealImagesInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeRealImagesInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeRealImagesInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
  }

  export type CafeInfoUpsertWithoutCafeRealImagesInput = {
    update: XOR<CafeInfoUpdateWithoutCafeRealImagesInput, CafeInfoUncheckedUpdateWithoutCafeRealImagesInput>
    create: XOR<CafeInfoCreateWithoutCafeRealImagesInput, CafeInfoUncheckedCreateWithoutCafeRealImagesInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutCafeRealImagesInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutCafeRealImagesInput, CafeInfoUncheckedUpdateWithoutCafeRealImagesInput>
  }

  export type CafeInfoUpdateWithoutCafeRealImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeRealImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoCreateWithoutCafeVirtualLinksInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeVirtualLinksInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
  }

  export type CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput = {
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
  }

  export type CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
  }

  export type CafeVirtualLinkThumbnailImageCreateOrConnectWithoutCafeVirtualLinkInput = {
    where: CafeVirtualLinkThumbnailImageWhereUniqueInput
    create: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
  }

  export type CafeInfoUpsertWithoutCafeVirtualLinksInput = {
    update: XOR<CafeInfoUpdateWithoutCafeVirtualLinksInput, CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput>
    create: XOR<CafeInfoCreateWithoutCafeVirtualLinksInput, CafeInfoUncheckedCreateWithoutCafeVirtualLinksInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutCafeVirtualLinksInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutCafeVirtualLinksInput, CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput>
  }

  export type CafeInfoUpdateWithoutCafeVirtualLinksInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeVirtualLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeVirtualLinkThumbnailImageUpsertWithoutCafeVirtualLinkInput = {
    update: XOR<CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
    create: XOR<CafeVirtualLinkThumbnailImageCreateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedCreateWithoutCafeVirtualLinkInput>
    where?: CafeVirtualLinkThumbnailImageWhereInput
  }

  export type CafeVirtualLinkThumbnailImageUpdateToOneWithWhereWithoutCafeVirtualLinkInput = {
    where?: CafeVirtualLinkThumbnailImageWhereInput
    data: XOR<CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput, CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput>
  }

  export type CafeVirtualLinkThumbnailImageUpdateWithoutCafeVirtualLinkInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkThumbnailImageUncheckedUpdateWithoutCafeVirtualLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput = {
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeVirtualLinksInput
  }

  export type CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
    cafeInfoId: number
  }

  export type CafeVirtualLinkCreateOrConnectWithoutCafeVirtualLinkThumbnailImageInput = {
    where: CafeVirtualLinkWhereUniqueInput
    create: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
  }

  export type CafeVirtualLinkUpsertWithoutCafeVirtualLinkThumbnailImageInput = {
    update: XOR<CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput>
    create: XOR<CafeVirtualLinkCreateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedCreateWithoutCafeVirtualLinkThumbnailImageInput>
    where?: CafeVirtualLinkWhereInput
  }

  export type CafeVirtualLinkUpdateToOneWithWhereWithoutCafeVirtualLinkThumbnailImageInput = {
    where?: CafeVirtualLinkWhereInput
    data: XOR<CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput, CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput>
  }

  export type CafeVirtualLinkUpdateWithoutCafeVirtualLinkThumbnailImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeVirtualLinksNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateWithoutCafeVirtualLinkThumbnailImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponCreateWithoutCafeCouponGroupInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutCafeCouponGroupInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutCafeCouponGroupInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponCreateManyCafeCouponGroupInputEnvelope = {
    data: CafeCouponCreateManyCafeCouponGroupInput | CafeCouponCreateManyCafeCouponGroupInput[]
    skipDuplicates?: boolean
  }

  export type CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput = {
    CafeInfo: CafeInfoCreateNestedOneWithoutCafeCouponGroupPartnersInput
  }

  export type CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput = {
    cafeInfoId: number
  }

  export type CafeCouponGoupPartnerCreateOrConnectWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGoupPartnerCreateManyCafeCouponGroupInputEnvelope = {
    data: CafeCouponGoupPartnerCreateManyCafeCouponGroupInput | CafeCouponGoupPartnerCreateManyCafeCouponGroupInput[]
    skipDuplicates?: boolean
  }

  export type CafeCouponUpsertWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponWhereUniqueInput
    update: XOR<CafeCouponUpdateWithoutCafeCouponGroupInput, CafeCouponUncheckedUpdateWithoutCafeCouponGroupInput>
    create: XOR<CafeCouponCreateWithoutCafeCouponGroupInput, CafeCouponUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponUpdateWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponWhereUniqueInput
    data: XOR<CafeCouponUpdateWithoutCafeCouponGroupInput, CafeCouponUncheckedUpdateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponUpdateManyWithWhereWithoutCafeCouponGroupInput = {
    where: CafeCouponScalarWhereInput
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupInput>
  }

  export type CafeCouponScalarWhereInput = {
    AND?: CafeCouponScalarWhereInput | CafeCouponScalarWhereInput[]
    OR?: CafeCouponScalarWhereInput[]
    NOT?: CafeCouponScalarWhereInput | CafeCouponScalarWhereInput[]
    id?: IntFilter<"CafeCoupon"> | number
    createdAt?: DateTimeFilter<"CafeCoupon"> | Date | string
    name?: StringFilter<"CafeCoupon"> | string
    content?: StringFilter<"CafeCoupon"> | string
    serialNumber?: StringFilter<"CafeCoupon"> | string
    startDay?: DateTimeFilter<"CafeCoupon"> | Date | string
    endDay?: DateTimeNullableFilter<"CafeCoupon"> | Date | string | null
    isDisable?: BoolFilter<"CafeCoupon"> | boolean
    proxyUserId?: IntFilter<"CafeCoupon"> | number
    cafeCouponGroupId?: IntFilter<"CafeCoupon"> | number
  }

  export type CafeCouponGoupPartnerUpsertWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    update: XOR<CafeCouponGoupPartnerUpdateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeCouponGroupInput>
    create: XOR<CafeCouponGoupPartnerCreateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedCreateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGoupPartnerUpdateWithWhereUniqueWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerWhereUniqueInput
    data: XOR<CafeCouponGoupPartnerUpdateWithoutCafeCouponGroupInput, CafeCouponGoupPartnerUncheckedUpdateWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGoupPartnerUpdateManyWithWhereWithoutCafeCouponGroupInput = {
    where: CafeCouponGoupPartnerScalarWhereInput
    data: XOR<CafeCouponGoupPartnerUpdateManyMutationInput, CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupInput>
  }

  export type CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput = {
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupCreateOrConnectWithoutCafeCouponGoupPartnersInput = {
    where: CafeCouponGroupWhereUniqueInput
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeInfoCreateWithoutCafeCouponGroupPartnersInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutCafeCouponGroupPartnersInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
  }

  export type CafeCouponGroupUpsertWithoutCafeCouponGoupPartnersInput = {
    update: XOR<CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput>
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponGoupPartnersInput>
    where?: CafeCouponGroupWhereInput
  }

  export type CafeCouponGroupUpdateToOneWithWhereWithoutCafeCouponGoupPartnersInput = {
    where?: CafeCouponGroupWhereInput
    data: XOR<CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput>
  }

  export type CafeCouponGroupUpdateWithoutCafeCouponGoupPartnersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupUncheckedUpdateWithoutCafeCouponGoupPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeInfoUpsertWithoutCafeCouponGroupPartnersInput = {
    update: XOR<CafeInfoUpdateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput>
    create: XOR<CafeInfoCreateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedCreateWithoutCafeCouponGroupPartnersInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutCafeCouponGroupPartnersInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutCafeCouponGroupPartnersInput, CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput>
  }

  export type CafeInfoUpdateWithoutCafeCouponGroupPartnersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutCafeCouponGroupPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type UserCreateWithoutProxyUsersInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutProxyUsersInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutProxyUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
  }

  export type CafeCouponCreateWithoutProxyUserInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutProxyUserInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    cafeCouponGroupId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutProxyUserInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput>
  }

  export type CafeCouponCreateManyProxyUserInputEnvelope = {
    data: CafeCouponCreateManyProxyUserInput | CafeCouponCreateManyProxyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistProductCreateWithoutProxyUserInput = {
    createdAt?: Date | string
    Product: ProductCreateNestedOneWithoutWishlistProductsInput
  }

  export type WishlistProductUncheckedCreateWithoutProxyUserInput = {
    id?: number
    createdAt?: Date | string
    productId: number
  }

  export type WishlistProductCreateOrConnectWithoutProxyUserInput = {
    where: WishlistProductWhereUniqueInput
    create: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput>
  }

  export type WishlistProductCreateManyProxyUserInputEnvelope = {
    data: WishlistProductCreateManyProxyUserInput | WishlistProductCreateManyProxyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProxyUsersInput = {
    update: XOR<UserUpdateWithoutProxyUsersInput, UserUncheckedUpdateWithoutProxyUsersInput>
    create: XOR<UserCreateWithoutProxyUsersInput, UserUncheckedCreateWithoutProxyUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProxyUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProxyUsersInput, UserUncheckedUpdateWithoutProxyUsersInput>
  }

  export type UserUpdateWithoutProxyUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutProxyUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CafeCouponUpsertWithWhereUniqueWithoutProxyUserInput = {
    where: CafeCouponWhereUniqueInput
    update: XOR<CafeCouponUpdateWithoutProxyUserInput, CafeCouponUncheckedUpdateWithoutProxyUserInput>
    create: XOR<CafeCouponCreateWithoutProxyUserInput, CafeCouponUncheckedCreateWithoutProxyUserInput>
  }

  export type CafeCouponUpdateWithWhereUniqueWithoutProxyUserInput = {
    where: CafeCouponWhereUniqueInput
    data: XOR<CafeCouponUpdateWithoutProxyUserInput, CafeCouponUncheckedUpdateWithoutProxyUserInput>
  }

  export type CafeCouponUpdateManyWithWhereWithoutProxyUserInput = {
    where: CafeCouponScalarWhereInput
    data: XOR<CafeCouponUpdateManyMutationInput, CafeCouponUncheckedUpdateManyWithoutProxyUserInput>
  }

  export type WishlistProductUpsertWithWhereUniqueWithoutProxyUserInput = {
    where: WishlistProductWhereUniqueInput
    update: XOR<WishlistProductUpdateWithoutProxyUserInput, WishlistProductUncheckedUpdateWithoutProxyUserInput>
    create: XOR<WishlistProductCreateWithoutProxyUserInput, WishlistProductUncheckedCreateWithoutProxyUserInput>
  }

  export type WishlistProductUpdateWithWhereUniqueWithoutProxyUserInput = {
    where: WishlistProductWhereUniqueInput
    data: XOR<WishlistProductUpdateWithoutProxyUserInput, WishlistProductUncheckedUpdateWithoutProxyUserInput>
  }

  export type WishlistProductUpdateManyWithWhereWithoutProxyUserInput = {
    where: WishlistProductScalarWhereInput
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyWithoutProxyUserInput>
  }

  export type WishlistProductScalarWhereInput = {
    AND?: WishlistProductScalarWhereInput | WishlistProductScalarWhereInput[]
    OR?: WishlistProductScalarWhereInput[]
    NOT?: WishlistProductScalarWhereInput | WishlistProductScalarWhereInput[]
    id?: IntFilter<"WishlistProduct"> | number
    createdAt?: DateTimeFilter<"WishlistProduct"> | Date | string
    productId?: IntFilter<"WishlistProduct"> | number
    proxyUserId?: IntFilter<"WishlistProduct"> | number
  }

  export type ProxyUserCreateWithoutCafeCouponsInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    User?: UserCreateNestedOneWithoutProxyUsersInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateWithoutCafeCouponsInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    userId?: number | null
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserCreateOrConnectWithoutCafeCouponsInput = {
    where: ProxyUserWhereUniqueInput
    create: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
  }

  export type CafeCouponGroupCreateWithoutCafeCouponsInput = {
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput = {
    id?: number
    createdAt?: Date | string
    code: string
    name: string
    tag: string
    description: string
    isDisable?: boolean
    startDay?: Date | string
    endDay: Date | string
    issuanceStartDay: Date | string
    issuanceEndDay: Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeCouponGroupInput
  }

  export type CafeCouponGroupCreateOrConnectWithoutCafeCouponsInput = {
    where: CafeCouponGroupWhereUniqueInput
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
  }

  export type CafeCouponQRCodeCreateWithoutCafeCouponInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
  }

  export type CafeCouponQRCodeCreateOrConnectWithoutCafeCouponInput = {
    where: CafeCouponQRCodeWhereUniqueInput
    create: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeCreateManyCafeCouponInputEnvelope = {
    data: CafeCouponQRCodeCreateManyCafeCouponInput | CafeCouponQRCodeCreateManyCafeCouponInput[]
    skipDuplicates?: boolean
  }

  export type CafeCouponHistoryCreateWithoutCafeCouponInput = {
    createdAt?: Date | string
    eventType: $Enums.CafeCouponEventType
    description: string
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
    Actor: UserCreateNestedOneWithoutCafeCouponHistoriesInput
  }

  export type CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput = {
    id?: number
    createdAt?: Date | string
    eventType: $Enums.CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryCreateOrConnectWithoutCafeCouponInput = {
    where: CafeCouponHistoryWhereUniqueInput
    create: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponHistoryCreateManyCafeCouponInputEnvelope = {
    data: CafeCouponHistoryCreateManyCafeCouponInput | CafeCouponHistoryCreateManyCafeCouponInput[]
    skipDuplicates?: boolean
  }

  export type ProxyUserUpsertWithoutCafeCouponsInput = {
    update: XOR<ProxyUserUpdateWithoutCafeCouponsInput, ProxyUserUncheckedUpdateWithoutCafeCouponsInput>
    create: XOR<ProxyUserCreateWithoutCafeCouponsInput, ProxyUserUncheckedCreateWithoutCafeCouponsInput>
    where?: ProxyUserWhereInput
  }

  export type ProxyUserUpdateToOneWithWhereWithoutCafeCouponsInput = {
    where?: ProxyUserWhereInput
    data: XOR<ProxyUserUpdateWithoutCafeCouponsInput, ProxyUserUncheckedUpdateWithoutCafeCouponsInput>
  }

  export type ProxyUserUpdateWithoutCafeCouponsInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutProxyUsersNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateWithoutCafeCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type CafeCouponGroupUpsertWithoutCafeCouponsInput = {
    update: XOR<CafeCouponGroupUpdateWithoutCafeCouponsInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput>
    create: XOR<CafeCouponGroupCreateWithoutCafeCouponsInput, CafeCouponGroupUncheckedCreateWithoutCafeCouponsInput>
    where?: CafeCouponGroupWhereInput
  }

  export type CafeCouponGroupUpdateToOneWithWhereWithoutCafeCouponsInput = {
    where?: CafeCouponGroupWhereInput
    data: XOR<CafeCouponGroupUpdateWithoutCafeCouponsInput, CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput>
  }

  export type CafeCouponGroupUpdateWithoutCafeCouponsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponGroupUncheckedUpdateWithoutCafeCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceStartDay?: DateTimeFieldUpdateOperationsInput | Date | string
    issuanceEndDay?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeCouponGoupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupNestedInput
  }

  export type CafeCouponQRCodeUpsertWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponQRCodeWhereUniqueInput
    update: XOR<CafeCouponQRCodeUpdateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedUpdateWithoutCafeCouponInput>
    create: XOR<CafeCouponQRCodeCreateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeUpdateWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponQRCodeWhereUniqueInput
    data: XOR<CafeCouponQRCodeUpdateWithoutCafeCouponInput, CafeCouponQRCodeUncheckedUpdateWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeUpdateManyWithWhereWithoutCafeCouponInput = {
    where: CafeCouponQRCodeScalarWhereInput
    data: XOR<CafeCouponQRCodeUpdateManyMutationInput, CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponInput>
  }

  export type CafeCouponQRCodeScalarWhereInput = {
    AND?: CafeCouponQRCodeScalarWhereInput | CafeCouponQRCodeScalarWhereInput[]
    OR?: CafeCouponQRCodeScalarWhereInput[]
    NOT?: CafeCouponQRCodeScalarWhereInput | CafeCouponQRCodeScalarWhereInput[]
    serialNumber?: StringFilter<"CafeCouponQRCode"> | string
    createdAt?: DateTimeFilter<"CafeCouponQRCode"> | Date | string
    isDisable?: BoolFilter<"CafeCouponQRCode"> | boolean
    cafeCouponId?: IntNullableFilter<"CafeCouponQRCode"> | number | null
    size?: IntFilter<"CafeCouponQRCode"> | number
    base64Data?: StringFilter<"CafeCouponQRCode"> | string
  }

  export type CafeCouponHistoryUpsertWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponHistoryWhereUniqueInput
    update: XOR<CafeCouponHistoryUpdateWithoutCafeCouponInput, CafeCouponHistoryUncheckedUpdateWithoutCafeCouponInput>
    create: XOR<CafeCouponHistoryCreateWithoutCafeCouponInput, CafeCouponHistoryUncheckedCreateWithoutCafeCouponInput>
  }

  export type CafeCouponHistoryUpdateWithWhereUniqueWithoutCafeCouponInput = {
    where: CafeCouponHistoryWhereUniqueInput
    data: XOR<CafeCouponHistoryUpdateWithoutCafeCouponInput, CafeCouponHistoryUncheckedUpdateWithoutCafeCouponInput>
  }

  export type CafeCouponHistoryUpdateManyWithWhereWithoutCafeCouponInput = {
    where: CafeCouponHistoryScalarWhereInput
    data: XOR<CafeCouponHistoryUpdateManyMutationInput, CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponInput>
  }

  export type CafeCouponCreateWithoutCafeCouponHistoriesInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponQRCodes?: CafeCouponQRCodeCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutCafeCouponHistoriesInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
  }

  export type UserCreateWithoutCafeCouponHistoriesInput = {
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyCreateNestedManyWithoutUserInput
    Notices?: NoticeCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCafeCouponHistoriesInput = {
    id?: number
    createdAt?: Date | string
    loginId: string
    loginPw?: string | null
    username: string
    loginType: $Enums.LoginType
    userType: $Enums.UserType
    nickname: string
    email: string
    isDisable?: boolean
    Boards?: BoardUncheckedCreateNestedManyWithoutUserInput
    BoardReplies?: BoardReplyUncheckedCreateNestedManyWithoutUserInput
    Notices?: NoticeUncheckedCreateNestedManyWithoutUserInput
    ProxyUsers?: ProxyUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCafeCouponHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponUpsertWithoutCafeCouponHistoriesInput = {
    update: XOR<CafeCouponUpdateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput>
    create: XOR<CafeCouponCreateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedCreateWithoutCafeCouponHistoriesInput>
    where?: CafeCouponWhereInput
  }

  export type CafeCouponUpdateToOneWithWhereWithoutCafeCouponHistoriesInput = {
    where?: CafeCouponWhereInput
    data: XOR<CafeCouponUpdateWithoutCafeCouponHistoriesInput, CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput>
  }

  export type CafeCouponUpdateWithoutCafeCouponHistoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutCafeCouponHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type UserUpsertWithoutCafeCouponHistoriesInput = {
    update: XOR<UserUpdateWithoutCafeCouponHistoriesInput, UserUncheckedUpdateWithoutCafeCouponHistoriesInput>
    create: XOR<UserCreateWithoutCafeCouponHistoriesInput, UserUncheckedCreateWithoutCafeCouponHistoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCafeCouponHistoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCafeCouponHistoriesInput, UserUncheckedUpdateWithoutCafeCouponHistoriesInput>
  }

  export type UserUpdateWithoutCafeCouponHistoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutUserNestedInput
    Notices?: NoticeUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCafeCouponHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginId?: StringFieldUpdateOperationsInput | string
    loginPw?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    loginType?: EnumLoginTypeFieldUpdateOperationsInput | $Enums.LoginType
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Boards?: BoardUncheckedUpdateManyWithoutUserNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutUserNestedInput
    Notices?: NoticeUncheckedUpdateManyWithoutUserNestedInput
    ProxyUsers?: ProxyUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CafeCouponCreateWithoutCafeCouponQRCodesInput = {
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    ProxyUser: ProxyUserCreateNestedOneWithoutCafeCouponsInput
    CafeCouponGroup: CafeCouponGroupCreateNestedOneWithoutCafeCouponsInput
    CafeCouponHistories?: CafeCouponHistoryCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
    cafeCouponGroupId: number
    CafeCouponHistories?: CafeCouponHistoryUncheckedCreateNestedManyWithoutCafeCouponInput
  }

  export type CafeCouponCreateOrConnectWithoutCafeCouponQRCodesInput = {
    where: CafeCouponWhereUniqueInput
    create: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
  }

  export type CafeCouponUpsertWithoutCafeCouponQRCodesInput = {
    update: XOR<CafeCouponUpdateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput>
    create: XOR<CafeCouponCreateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedCreateWithoutCafeCouponQRCodesInput>
    where?: CafeCouponWhereInput
  }

  export type CafeCouponUpdateToOneWithWhereWithoutCafeCouponQRCodesInput = {
    where?: CafeCouponWhereInput
    data: XOR<CafeCouponUpdateWithoutCafeCouponQRCodesInput, CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput>
  }

  export type CafeCouponUpdateWithoutCafeCouponQRCodesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutCafeCouponQRCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeInfoCreateWithoutMetaViewerInfosInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    Products?: ProductCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutMetaViewerInfosInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    Products?: ProductUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutMetaViewerInfosInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
  }

  export type MetaViewerMapCreateWithoutMetaViewerInfoInput = {
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    ActiveRenderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    ActiveRenderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapCreateOrConnectWithoutMetaViewerInfoInput = {
    where: MetaViewerMapWhereUniqueInput
    create: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapCreateManyMetaViewerInfoInputEnvelope = {
    data: MetaViewerMapCreateManyMetaViewerInfoInput | MetaViewerMapCreateManyMetaViewerInfoInput[]
    skipDuplicates?: boolean
  }

  export type MetaViewerActiveMapCreateWithoutMetaViewerInfoInput = {
    updatedAt?: Date | string
    ActiveRenderMap: MetaViewerMapCreateNestedOneWithoutActiveRenderForInput
    ActiveColliderMap: MetaViewerMapCreateNestedOneWithoutActiveColliderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput = {
    id?: number
    updatedAt?: Date | string
    activeRenderMapId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapCreateOrConnectWithoutMetaViewerInfoInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    create: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type CafeInfoUpsertWithoutMetaViewerInfosInput = {
    update: XOR<CafeInfoUpdateWithoutMetaViewerInfosInput, CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput>
    create: XOR<CafeInfoCreateWithoutMetaViewerInfosInput, CafeInfoUncheckedCreateWithoutMetaViewerInfosInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutMetaViewerInfosInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutMetaViewerInfosInput, CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput>
  }

  export type CafeInfoUpdateWithoutMetaViewerInfosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutMetaViewerInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type MetaViewerMapUpsertWithWhereUniqueWithoutMetaViewerInfoInput = {
    where: MetaViewerMapWhereUniqueInput
    update: XOR<MetaViewerMapUpdateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedUpdateWithoutMetaViewerInfoInput>
    create: XOR<MetaViewerMapCreateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedCreateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapUpdateWithWhereUniqueWithoutMetaViewerInfoInput = {
    where: MetaViewerMapWhereUniqueInput
    data: XOR<MetaViewerMapUpdateWithoutMetaViewerInfoInput, MetaViewerMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapUpdateManyWithWhereWithoutMetaViewerInfoInput = {
    where: MetaViewerMapScalarWhereInput
    data: XOR<MetaViewerMapUpdateManyMutationInput, MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoInput>
  }

  export type MetaViewerMapScalarWhereInput = {
    AND?: MetaViewerMapScalarWhereInput | MetaViewerMapScalarWhereInput[]
    OR?: MetaViewerMapScalarWhereInput[]
    NOT?: MetaViewerMapScalarWhereInput | MetaViewerMapScalarWhereInput[]
    id?: IntFilter<"MetaViewerMap"> | number
    createdAt?: DateTimeFilter<"MetaViewerMap"> | Date | string
    type?: EnumMetaMapTypeFilter<"MetaViewerMap"> | $Enums.MetaMapType
    version?: FloatFilter<"MetaViewerMap"> | number
    url?: StringFilter<"MetaViewerMap"> | string
    size?: IntFilter<"MetaViewerMap"> | number
    contentKey?: StringNullableFilter<"MetaViewerMap"> | string | null
    isDraco?: BoolFilter<"MetaViewerMap"> | boolean
    metaViewerInfoId?: IntFilter<"MetaViewerMap"> | number
  }

  export type MetaViewerActiveMapUpsertWithoutMetaViewerInfoInput = {
    update: XOR<MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
    create: XOR<MetaViewerActiveMapCreateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedCreateWithoutMetaViewerInfoInput>
    where?: MetaViewerActiveMapWhereInput
  }

  export type MetaViewerActiveMapUpdateToOneWithWhereWithoutMetaViewerInfoInput = {
    where?: MetaViewerActiveMapWhereInput
    data: XOR<MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput, MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput>
  }

  export type MetaViewerActiveMapUpdateWithoutMetaViewerInfoInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActiveRenderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput
    ActiveColliderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateWithoutMetaViewerInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerInfoCreateWithoutMetaViewerMapsInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    CafeInfo: CafeInfoCreateNestedOneWithoutMetaViewerInfosInput
    ActiveMaps?: MetaViewerActiveMapCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
    ActiveMaps?: MetaViewerActiveMapUncheckedCreateNestedOneWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoCreateOrConnectWithoutMetaViewerMapsInput = {
    where: MetaViewerInfoWhereUniqueInput
    create: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
  }

  export type MetaViewerActiveMapCreateWithoutActiveRenderMapInput = {
    updatedAt?: Date | string
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutActiveMapsInput
    ActiveColliderMap: MetaViewerMapCreateNestedOneWithoutActiveColliderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapCreateOrConnectWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    create: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapCreateManyActiveRenderMapInputEnvelope = {
    data: MetaViewerActiveMapCreateManyActiveRenderMapInput | MetaViewerActiveMapCreateManyActiveRenderMapInput[]
    skipDuplicates?: boolean
  }

  export type MetaViewerActiveMapCreateWithoutActiveColliderMapInput = {
    updatedAt?: Date | string
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutActiveMapsInput
    ActiveRenderMap: MetaViewerMapCreateNestedOneWithoutActiveRenderForInput
  }

  export type MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
  }

  export type MetaViewerActiveMapCreateOrConnectWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    create: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>
  }

  export type MetaViewerActiveMapCreateManyActiveColliderMapInputEnvelope = {
    data: MetaViewerActiveMapCreateManyActiveColliderMapInput | MetaViewerActiveMapCreateManyActiveColliderMapInput[]
    skipDuplicates?: boolean
  }

  export type MetaViewerInfoUpsertWithoutMetaViewerMapsInput = {
    update: XOR<MetaViewerInfoUpdateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput>
    create: XOR<MetaViewerInfoCreateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedCreateWithoutMetaViewerMapsInput>
    where?: MetaViewerInfoWhereInput
  }

  export type MetaViewerInfoUpdateToOneWithWhereWithoutMetaViewerMapsInput = {
    where?: MetaViewerInfoWhereInput
    data: XOR<MetaViewerInfoUpdateWithoutMetaViewerMapsInput, MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput>
  }

  export type MetaViewerInfoUpdateWithoutMetaViewerMapsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput
    ActiveMaps?: MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateWithoutMetaViewerMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    ActiveMaps?: MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    update: XOR<MetaViewerActiveMapUpdateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveRenderMapInput>
    create: XOR<MetaViewerActiveMapCreateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    data: XOR<MetaViewerActiveMapUpdateWithoutActiveRenderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapUpdateManyWithWhereWithoutActiveRenderMapInput = {
    where: MetaViewerActiveMapScalarWhereInput
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapInput>
  }

  export type MetaViewerActiveMapScalarWhereInput = {
    AND?: MetaViewerActiveMapScalarWhereInput | MetaViewerActiveMapScalarWhereInput[]
    OR?: MetaViewerActiveMapScalarWhereInput[]
    NOT?: MetaViewerActiveMapScalarWhereInput | MetaViewerActiveMapScalarWhereInput[]
    id?: IntFilter<"MetaViewerActiveMap"> | number
    updatedAt?: DateTimeFilter<"MetaViewerActiveMap"> | Date | string
    metaViewerInfoId?: IntFilter<"MetaViewerActiveMap"> | number
    activeRenderMapId?: IntFilter<"MetaViewerActiveMap"> | number
    activeColliderMapId?: IntFilter<"MetaViewerActiveMap"> | number
  }

  export type MetaViewerActiveMapUpsertWithWhereUniqueWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    update: XOR<MetaViewerActiveMapUpdateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveColliderMapInput>
    create: XOR<MetaViewerActiveMapCreateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedCreateWithoutActiveColliderMapInput>
  }

  export type MetaViewerActiveMapUpdateWithWhereUniqueWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapWhereUniqueInput
    data: XOR<MetaViewerActiveMapUpdateWithoutActiveColliderMapInput, MetaViewerActiveMapUncheckedUpdateWithoutActiveColliderMapInput>
  }

  export type MetaViewerActiveMapUpdateManyWithWhereWithoutActiveColliderMapInput = {
    where: MetaViewerActiveMapScalarWhereInput
    data: XOR<MetaViewerActiveMapUpdateManyMutationInput, MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapInput>
  }

  export type MetaViewerInfoCreateWithoutActiveMapsInput = {
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    CafeInfo: CafeInfoCreateNestedOneWithoutMetaViewerInfosInput
    MetaViewerMaps?: MetaViewerMapCreateNestedManyWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoUncheckedCreateWithoutActiveMapsInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
    cafeInfoId: number
    MetaViewerMaps?: MetaViewerMapUncheckedCreateNestedManyWithoutMetaViewerInfoInput
  }

  export type MetaViewerInfoCreateOrConnectWithoutActiveMapsInput = {
    where: MetaViewerInfoWhereUniqueInput
    create: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
  }

  export type MetaViewerMapCreateWithoutActiveRenderForInput = {
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput
    ActiveColliderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapUncheckedCreateWithoutActiveRenderForInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
    ActiveColliderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveColliderMapInput
  }

  export type MetaViewerMapCreateOrConnectWithoutActiveRenderForInput = {
    where: MetaViewerMapWhereUniqueInput
    create: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
  }

  export type MetaViewerMapCreateWithoutActiveColliderForInput = {
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    MetaViewerInfo: MetaViewerInfoCreateNestedOneWithoutMetaViewerMapsInput
    ActiveRenderFor?: MetaViewerActiveMapCreateNestedManyWithoutActiveRenderMapInput
  }

  export type MetaViewerMapUncheckedCreateWithoutActiveColliderForInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
    metaViewerInfoId: number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedCreateNestedManyWithoutActiveRenderMapInput
  }

  export type MetaViewerMapCreateOrConnectWithoutActiveColliderForInput = {
    where: MetaViewerMapWhereUniqueInput
    create: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
  }

  export type MetaViewerInfoUpsertWithoutActiveMapsInput = {
    update: XOR<MetaViewerInfoUpdateWithoutActiveMapsInput, MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput>
    create: XOR<MetaViewerInfoCreateWithoutActiveMapsInput, MetaViewerInfoUncheckedCreateWithoutActiveMapsInput>
    where?: MetaViewerInfoWhereInput
  }

  export type MetaViewerInfoUpdateToOneWithWhereWithoutActiveMapsInput = {
    where?: MetaViewerInfoWhereInput
    data: XOR<MetaViewerInfoUpdateWithoutActiveMapsInput, MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput>
  }

  export type MetaViewerInfoUpdateWithoutActiveMapsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutMetaViewerInfosNestedInput
    MetaViewerMaps?: MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateWithoutActiveMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    MetaViewerMaps?: MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerMapUpsertWithoutActiveRenderForInput = {
    update: XOR<MetaViewerMapUpdateWithoutActiveRenderForInput, MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput>
    create: XOR<MetaViewerMapCreateWithoutActiveRenderForInput, MetaViewerMapUncheckedCreateWithoutActiveRenderForInput>
    where?: MetaViewerMapWhereInput
  }

  export type MetaViewerMapUpdateToOneWithWhereWithoutActiveRenderForInput = {
    where?: MetaViewerMapWhereInput
    data: XOR<MetaViewerMapUpdateWithoutActiveRenderForInput, MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput>
  }

  export type MetaViewerMapUpdateWithoutActiveRenderForInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateWithoutActiveRenderForInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    ActiveColliderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUpsertWithoutActiveColliderForInput = {
    update: XOR<MetaViewerMapUpdateWithoutActiveColliderForInput, MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput>
    create: XOR<MetaViewerMapCreateWithoutActiveColliderForInput, MetaViewerMapUncheckedCreateWithoutActiveColliderForInput>
    where?: MetaViewerMapWhereInput
  }

  export type MetaViewerMapUpdateToOneWithWhereWithoutActiveColliderForInput = {
    where?: MetaViewerMapWhereInput
    data: XOR<MetaViewerMapUpdateWithoutActiveColliderForInput, MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput>
  }

  export type MetaViewerMapUpdateWithoutActiveColliderForInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutMetaViewerMapsNestedInput
    ActiveRenderFor?: MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateWithoutActiveColliderForInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    ActiveRenderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput
  }

  export type ClosureProductCategoryCreateWithoutAncestorCategoryInput = {
    depth?: number
    DescendantCategory: ProductCategoryCreateNestedOneWithoutDescendantCategoriesInput
  }

  export type ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryCreateOrConnectWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    create: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryCreateManyAncestorCategoryInputEnvelope = {
    data: ClosureProductCategoryCreateManyAncestorCategoryInput | ClosureProductCategoryCreateManyAncestorCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ClosureProductCategoryCreateWithoutDescendantCategoryInput = {
    depth?: number
    AncestorCategory: ProductCategoryCreateNestedOneWithoutAncestorCategoriesInput
  }

  export type ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type ClosureProductCategoryCreateOrConnectWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    create: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureProductCategoryCreateManyDescendantCategoryInputEnvelope = {
    data: ClosureProductCategoryCreateManyDescendantCategoryInput | ClosureProductCategoryCreateManyDescendantCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutProductCategoryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    productRedirectUrl?: string | null
    isSignature?: boolean
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductCreateManyProductCategoryInputEnvelope = {
    data: ProductCreateManyProductCategoryInput | ProductCreateManyProductCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ClosureProductCategoryUpsertWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    update: XOR<ClosureProductCategoryUpdateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutAncestorCategoryInput>
    create: XOR<ClosureProductCategoryCreateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedCreateWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryUpdateWithWhereUniqueWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    data: XOR<ClosureProductCategoryUpdateWithoutAncestorCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryUpdateManyWithWhereWithoutAncestorCategoryInput = {
    where: ClosureProductCategoryScalarWhereInput
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryInput>
  }

  export type ClosureProductCategoryScalarWhereInput = {
    AND?: ClosureProductCategoryScalarWhereInput | ClosureProductCategoryScalarWhereInput[]
    OR?: ClosureProductCategoryScalarWhereInput[]
    NOT?: ClosureProductCategoryScalarWhereInput | ClosureProductCategoryScalarWhereInput[]
    ancestor?: IntFilter<"ClosureProductCategory"> | number
    descendant?: IntFilter<"ClosureProductCategory"> | number
    depth?: IntFilter<"ClosureProductCategory"> | number
  }

  export type ClosureProductCategoryUpsertWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    update: XOR<ClosureProductCategoryUpdateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutDescendantCategoryInput>
    create: XOR<ClosureProductCategoryCreateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedCreateWithoutDescendantCategoryInput>
  }

  export type ClosureProductCategoryUpdateWithWhereUniqueWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryWhereUniqueInput
    data: XOR<ClosureProductCategoryUpdateWithoutDescendantCategoryInput, ClosureProductCategoryUncheckedUpdateWithoutDescendantCategoryInput>
  }

  export type ClosureProductCategoryUpdateManyWithWhereWithoutDescendantCategoryInput = {
    where: ClosureProductCategoryScalarWhereInput
    data: XOR<ClosureProductCategoryUpdateManyMutationInput, ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type ProductCategoryCreateWithoutAncestorCategoriesInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    DescendantCategories?: ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    DescendantCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
    Products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutAncestorCategoriesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
  }

  export type ProductCategoryCreateWithoutDescendantCategoriesInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput
    Products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    Products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutDescendantCategoriesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
  }

  export type ProductCategoryUpsertWithoutAncestorCategoriesInput = {
    update: XOR<ProductCategoryUpdateWithoutAncestorCategoriesInput, ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
    create: XOR<ProductCategoryCreateWithoutAncestorCategoriesInput, ProductCategoryUncheckedCreateWithoutAncestorCategoriesInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutAncestorCategoriesInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutAncestorCategoriesInput, ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput>
  }

  export type ProductCategoryUpdateWithoutAncestorCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    DescendantCategories?: ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutAncestorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    DescendantCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
    Products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUpsertWithoutDescendantCategoriesInput = {
    update: XOR<ProductCategoryUpdateWithoutDescendantCategoriesInput, ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
    create: XOR<ProductCategoryCreateWithoutDescendantCategoriesInput, ProductCategoryUncheckedCreateWithoutDescendantCategoriesInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutDescendantCategoriesInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutDescendantCategoriesInput, ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput>
  }

  export type ProductCategoryUpdateWithoutDescendantCategoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput
    Products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutDescendantCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    Products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryCreateNestedManyWithoutDescendantCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    description?: string | null
    isDisable?: boolean
    code: string
    AncestorCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutAncestorCategoryInput
    DescendantCategories?: ClosureProductCategoryUncheckedCreateNestedManyWithoutDescendantCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CafeInfoCreateWithoutProductsInput = {
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    RegionCategory: RegionCategoryCreateNestedOneWithoutCafeInfosInput
    CafeVirtualLinks?: CafeVirtualLinkCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoUncheckedCreateWithoutProductsInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    regionCategoryId: number
    address: string
    directions: string
    businessNumber: string
    ceoName: string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeVirtualImages?: CafeVirtualImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeRealImages?: CafeRealImageUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedCreateNestedManyWithoutCafeInfoInput
    CafeBoards?: CafeBoardUncheckedCreateNestedManyWithoutCafeInfoInput
    MetaViewerInfos?: MetaViewerInfoUncheckedCreateNestedManyWithoutCafeInfoInput
  }

  export type CafeInfoCreateOrConnectWithoutProductsInput = {
    where: CafeInfoWhereUniqueInput
    create: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
  }

  export type WishlistProductCreateWithoutProductInput = {
    createdAt?: Date | string
    ProxyUser: ProxyUserCreateNestedOneWithoutWishlistProductsInput
  }

  export type WishlistProductUncheckedCreateWithoutProductInput = {
    id?: number
    createdAt?: Date | string
    proxyUserId: number
  }

  export type WishlistProductCreateOrConnectWithoutProductInput = {
    where: WishlistProductWhereUniqueInput
    create: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput>
  }

  export type WishlistProductCreateManyProductInputEnvelope = {
    data: WishlistProductCreateManyProductInput | WishlistProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    AncestorCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryNestedInput
    DescendantCategories?: ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryNestedInput
  }

  export type CafeInfoUpsertWithoutProductsInput = {
    update: XOR<CafeInfoUpdateWithoutProductsInput, CafeInfoUncheckedUpdateWithoutProductsInput>
    create: XOR<CafeInfoCreateWithoutProductsInput, CafeInfoUncheckedCreateWithoutProductsInput>
    where?: CafeInfoWhereInput
  }

  export type CafeInfoUpdateToOneWithWhereWithoutProductsInput = {
    where?: CafeInfoWhereInput
    data: XOR<CafeInfoUpdateWithoutProductsInput, CafeInfoUncheckedUpdateWithoutProductsInput>
  }

  export type CafeInfoUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    RegionCategory?: RegionCategoryUpdateOneRequiredWithoutCafeInfosNestedInput
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    regionCategoryId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type WishlistProductUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistProductWhereUniqueInput
    update: XOR<WishlistProductUpdateWithoutProductInput, WishlistProductUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistProductCreateWithoutProductInput, WishlistProductUncheckedCreateWithoutProductInput>
  }

  export type WishlistProductUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistProductWhereUniqueInput
    data: XOR<WishlistProductUpdateWithoutProductInput, WishlistProductUncheckedUpdateWithoutProductInput>
  }

  export type WishlistProductUpdateManyWithWhereWithoutProductInput = {
    where: WishlistProductScalarWhereInput
    data: XOR<WishlistProductUpdateManyMutationInput, WishlistProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    url?: StringFilter<"ProductImage"> | string
    thumbnailUrl?: StringFilter<"ProductImage"> | string
    width?: IntFilter<"ProductImage"> | number
    height?: IntFilter<"ProductImage"> | number
    size?: IntFilter<"ProductImage"> | number
    isDisable?: BoolFilter<"ProductImage"> | boolean
    isThumb?: BoolFilter<"ProductImage"> | boolean
    productId?: IntFilter<"ProductImage"> | number
  }

  export type ProductCreateWithoutWishlistProductsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    productRedirectUrl?: string | null
    isSignature?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    ProductImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWishlistProductsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
    ProductImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWishlistProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
  }

  export type ProxyUserCreateWithoutWishlistProductsInput = {
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    User?: UserCreateNestedOneWithoutProxyUsersInput
    CafeCoupons?: CafeCouponCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserUncheckedCreateWithoutWishlistProductsInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
    userId?: number | null
    CafeCoupons?: CafeCouponUncheckedCreateNestedManyWithoutProxyUserInput
  }

  export type ProxyUserCreateOrConnectWithoutWishlistProductsInput = {
    where: ProxyUserWhereUniqueInput
    create: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
  }

  export type ProductUpsertWithoutWishlistProductsInput = {
    update: XOR<ProductUpdateWithoutWishlistProductsInput, ProductUncheckedUpdateWithoutWishlistProductsInput>
    create: XOR<ProductCreateWithoutWishlistProductsInput, ProductUncheckedCreateWithoutWishlistProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWishlistProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWishlistProductsInput, ProductUncheckedUpdateWithoutWishlistProductsInput>
  }

  export type ProductUpdateWithoutWishlistProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWishlistProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProxyUserUpsertWithoutWishlistProductsInput = {
    update: XOR<ProxyUserUpdateWithoutWishlistProductsInput, ProxyUserUncheckedUpdateWithoutWishlistProductsInput>
    create: XOR<ProxyUserCreateWithoutWishlistProductsInput, ProxyUserUncheckedCreateWithoutWishlistProductsInput>
    where?: ProxyUserWhereInput
  }

  export type ProxyUserUpdateToOneWithWhereWithoutWishlistProductsInput = {
    where?: ProxyUserWhereInput
    data: XOR<ProxyUserUpdateWithoutWishlistProductsInput, ProxyUserUncheckedUpdateWithoutWishlistProductsInput>
  }

  export type ProxyUserUpdateWithoutWishlistProductsInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutProxyUsersNestedInput
    CafeCoupons?: CafeCouponUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateWithoutWishlistProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type ProductCreateWithoutProductImagesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    productRedirectUrl?: string | null
    isSignature?: boolean
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    CafeInfo?: CafeInfoCreateNestedOneWithoutProductsInput
    WishlistProducts?: WishlistProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductImagesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
    WishlistProducts?: WishlistProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductUpsertWithoutProductImagesInput = {
    update: XOR<ProductUpdateWithoutProductImagesInput, ProductUncheckedUpdateWithoutProductImagesInput>
    create: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductImagesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductImagesInput, ProductUncheckedUpdateWithoutProductImagesInput>
  }

  export type ProductUpdateWithoutProductImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BoardCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    isReplyAvaliable?: boolean
    boardType?: $Enums.BoardType
  }

  export type BoardReplyCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    boardId: number
    boardReplyId?: number | null
  }

  export type NoticeCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    title: string
    content?: string | null
    link?: string | null
  }

  export type ProxyUserCreateManyUserInput = {
    id?: number
    memberId: string
    createdAt?: Date | string
    proxyUserType: $Enums.ProxyUserType
    name: string
    token: string
  }

  export type CafeCouponHistoryCreateManyActorInput = {
    id?: number
    createdAt?: Date | string
    cafeCouponId: number
    eventType: $Enums.CafeCouponEventType
    description: string
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
  }

  export type BoardUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUpdateManyWithoutBoardNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
    BoardImages?: BoardImageUncheckedUpdateManyWithoutBoardNestedInput
    BoardReplies?: BoardReplyUncheckedUpdateManyWithoutBoardNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isReplyAvaliable?: BoolFieldUpdateOperationsInput | boolean
    boardType?: EnumBoardTypeFieldUpdateOperationsInput | $Enums.BoardType
  }

  export type BoardReplyUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    boardId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoticeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProxyUserUpdateWithoutUserInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    CafeCoupons?: CafeCouponUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    CafeCoupons?: CafeCouponUncheckedUpdateManyWithoutProxyUserNestedInput
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProxyUserNestedInput
  }

  export type ProxyUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserType?: EnumProxyUserTypeFieldUpdateOperationsInput | $Enums.ProxyUserType
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponHistoryUpdateWithoutActorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    CafeCoupon?: CafeCouponUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
  }

  export type CafeCouponHistoryUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cafeCouponId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type BoardImageCreateManyBoardInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isThumb?: boolean
    isDisable?: boolean
  }

  export type BoardReplyCreateManyBoardInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardReplyId?: number | null
  }

  export type CafeBoardCreateManyBoardInput = {
    cafeInfoId: number
    createdAt?: Date | string
  }

  export type BoardImageUpdateWithoutBoardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardImageUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardImageUncheckedUpdateManyWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isThumb?: BoolFieldUpdateOperationsInput | boolean
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardReplyUpdateWithoutBoardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardReply?: BoardReplyUpdateOneWithoutBoardNestedRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardReplyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CafeBoardUpdateWithoutBoardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeBoardsNestedInput
  }

  export type CafeBoardUncheckedUpdateWithoutBoardInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateManyWithoutBoardInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardReplyCreateManyBoardReplyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    content: string
    isDisable?: boolean
    userId: number
    boardId: number
  }

  export type BoardReplyUpdateWithoutBoardReplyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutBoardRepliesNestedInput
    Board?: BoardUpdateOneRequiredWithoutBoardRepliesNestedInput
    BoardNestedReplies?: BoardReplyUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateWithoutBoardReplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
    BoardNestedReplies?: BoardReplyUncheckedUpdateManyWithoutBoardReplyNestedInput
  }

  export type BoardReplyUncheckedUpdateManyWithoutBoardReplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeInfoCreateManyRegionCategoryInput = {
    id?: number
    createdAt?: Date | string
    isDisable?: boolean
    name: string
    code?: string | null
    address: string
    directions: string
    businessNumber: string
    ceoName: string
  }

  export type ClosureRegionCategoryCreateManyAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureRegionCategoryCreateManyDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type CafeInfoUpdateWithoutRegionCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateWithoutRegionCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
    CafeVirtualLinks?: CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeThumbnailImages?: CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeVirtualImages?: CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeRealImages?: CafeRealImageUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeCouponGroupPartners?: CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoNestedInput
    CafeBoards?: CafeBoardUncheckedUpdateManyWithoutCafeInfoNestedInput
    MetaViewerInfos?: MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoNestedInput
    Products?: ProductUncheckedUpdateManyWithoutCafeInfoNestedInput
  }

  export type CafeInfoUncheckedUpdateManyWithoutRegionCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    directions?: StringFieldUpdateOperationsInput | string
    businessNumber?: StringFieldUpdateOperationsInput | string
    ceoName?: StringFieldUpdateOperationsInput | string
  }

  export type ClosureRegionCategoryUpdateWithoutAncestorCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    DescendantCategory?: RegionCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureRegionCategoryUncheckedUpdateWithoutAncestorCategoryInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutAncestorCategoryInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUpdateWithoutDescendantCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: RegionCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
  }

  export type ClosureRegionCategoryUncheckedUpdateWithoutDescendantCategoryInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureRegionCategoryUncheckedUpdateManyWithoutDescendantCategoryInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type CafeVirtualLinkCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    url: string
    type: string
    isDisable?: boolean
    isAvaliable?: boolean
  }

  export type CafeThumbnailImageCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeVirtualImageCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeRealImageCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    url: string
    width: number
    height: number
    size: number
    priority?: number
    isDisable?: boolean
  }

  export type CafeCouponGoupPartnerCreateManyCafeInfoInput = {
    cafeCouponGroupId: number
  }

  export type CafeBoardCreateManyCafeInfoInput = {
    boardId: number
    createdAt?: Date | string
  }

  export type MetaViewerInfoCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    code: string
    isDisable?: boolean
    worldData: JsonNullValueInput | InputJsonValue
  }

  export type ProductCreateManyCafeInfoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    categoryId: number
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type CafeVirtualLinkUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
    CafeVirtualLinkThumbnailImage?: CafeVirtualLinkThumbnailImageUncheckedUpdateOneWithoutCafeVirtualLinkNestedInput
  }

  export type CafeVirtualLinkUncheckedUpdateManyWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvaliable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeThumbnailImageUncheckedUpdateManyWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeVirtualImageUncheckedUpdateManyWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeRealImageUncheckedUpdateManyWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeCouponGoupPartnerUpdateWithoutCafeInfoInput = {
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponGoupPartnersNestedInput
  }

  export type CafeCouponGoupPartnerUncheckedUpdateWithoutCafeInfoInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeInfoInput = {
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeBoardUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutCafeBoardsNestedInput
  }

  export type CafeBoardUncheckedUpdateWithoutCafeInfoInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeBoardUncheckedUpdateManyWithoutCafeInfoInput = {
    boardId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaViewerInfoUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
    MetaViewerMaps?: MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoNestedInput
    ActiveMaps?: MetaViewerActiveMapUncheckedUpdateOneWithoutMetaViewerInfoNestedInput
  }

  export type MetaViewerInfoUncheckedUpdateManyWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    worldData?: JsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateWithoutCafeInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCafeInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CafeCouponCreateManyCafeCouponGroupInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    proxyUserId: number
  }

  export type CafeCouponGoupPartnerCreateManyCafeCouponGroupInput = {
    cafeInfoId: number
  }

  export type CafeCouponUpdateWithoutCafeCouponGroupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutCafeCouponGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateManyWithoutCafeCouponGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerUpdateWithoutCafeCouponGroupInput = {
    CafeInfo?: CafeInfoUpdateOneRequiredWithoutCafeCouponGroupPartnersNestedInput
  }

  export type CafeCouponGoupPartnerUncheckedUpdateWithoutCafeCouponGroupInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponGoupPartnerUncheckedUpdateManyWithoutCafeCouponGroupInput = {
    cafeInfoId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponCreateManyProxyUserInput = {
    id?: number
    createdAt?: Date | string
    name: string
    content: string
    serialNumber: string
    startDay?: Date | string
    endDay?: Date | string | null
    isDisable?: boolean
    cafeCouponGroupId: number
  }

  export type WishlistProductCreateManyProxyUserInput = {
    id?: number
    createdAt?: Date | string
    productId: number
  }

  export type CafeCouponUpdateWithoutProxyUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    CafeCouponGroup?: CafeCouponGroupUpdateOneRequiredWithoutCafeCouponsNestedInput
    CafeCouponQRCodes?: CafeCouponQRCodeUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateWithoutProxyUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
    CafeCouponQRCodes?: CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponNestedInput
    CafeCouponHistories?: CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponNestedInput
  }

  export type CafeCouponUncheckedUpdateManyWithoutProxyUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    startDay?: DateTimeFieldUpdateOperationsInput | Date | string
    endDay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    cafeCouponGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistProductUpdateWithoutProxyUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutWishlistProductsNestedInput
  }

  export type WishlistProductUncheckedUpdateWithoutProxyUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistProductUncheckedUpdateManyWithoutProxyUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type CafeCouponQRCodeCreateManyCafeCouponInput = {
    serialNumber: string
    createdAt?: Date | string
    isDisable?: boolean
    size: number
    base64Data: string
  }

  export type CafeCouponHistoryCreateManyCafeCouponInput = {
    id?: number
    createdAt?: Date | string
    eventType: $Enums.CafeCouponEventType
    description: string
    actorId: number
    statusBefore?: $Enums.CafeCouponStatus | null
    statusAfter?: $Enums.CafeCouponStatus | null
  }

  export type CafeCouponQRCodeUpdateWithoutCafeCouponInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateWithoutCafeCouponInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponQRCodeUncheckedUpdateManyWithoutCafeCouponInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    size?: IntFieldUpdateOperationsInput | number
    base64Data?: StringFieldUpdateOperationsInput | string
  }

  export type CafeCouponHistoryUpdateWithoutCafeCouponInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    Actor?: UserUpdateOneRequiredWithoutCafeCouponHistoriesNestedInput
  }

  export type CafeCouponHistoryUncheckedUpdateWithoutCafeCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type CafeCouponHistoryUncheckedUpdateManyWithoutCafeCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EnumCafeCouponEventTypeFieldUpdateOperationsInput | $Enums.CafeCouponEventType
    description?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    statusBefore?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
    statusAfter?: NullableEnumCafeCouponStatusFieldUpdateOperationsInput | $Enums.CafeCouponStatus | null
  }

  export type MetaViewerMapCreateManyMetaViewerInfoInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.MetaMapType
    version?: number
    url: string
    size: number
    contentKey?: string | null
    isDraco: boolean
  }

  export type MetaViewerMapUpdateWithoutMetaViewerInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    ActiveRenderFor?: MetaViewerActiveMapUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateWithoutMetaViewerInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
    ActiveRenderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapNestedInput
    ActiveColliderFor?: MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapNestedInput
  }

  export type MetaViewerMapUncheckedUpdateManyWithoutMetaViewerInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMetaMapTypeFieldUpdateOperationsInput | $Enums.MetaMapType
    version?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDraco?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MetaViewerActiveMapCreateManyActiveRenderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeColliderMapId: number
  }

  export type MetaViewerActiveMapCreateManyActiveColliderMapInput = {
    id?: number
    updatedAt?: Date | string
    metaViewerInfoId: number
    activeRenderMapId: number
  }

  export type MetaViewerActiveMapUpdateWithoutActiveRenderMapInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput
    ActiveColliderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveColliderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateWithoutActiveRenderMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveRenderMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeColliderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapUpdateWithoutActiveColliderMapInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MetaViewerInfo?: MetaViewerInfoUpdateOneRequiredWithoutActiveMapsNestedInput
    ActiveRenderMap?: MetaViewerMapUpdateOneRequiredWithoutActiveRenderForNestedInput
  }

  export type MetaViewerActiveMapUncheckedUpdateWithoutActiveColliderMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type MetaViewerActiveMapUncheckedUpdateManyWithoutActiveColliderMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaViewerInfoId?: IntFieldUpdateOperationsInput | number
    activeRenderMapId?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryCreateManyAncestorCategoryInput = {
    descendant: number
    depth?: number
  }

  export type ClosureProductCategoryCreateManyDescendantCategoryInput = {
    ancestor: number
    depth?: number
  }

  export type ProductCreateManyProductCategoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
    description?: string | null
    price: number
    originalPrice?: number | null
    stockQuantity?: number
    minOrderQuantity?: number
    isDisable?: boolean
    isAvailable?: boolean
    cafeInfoId?: number | null
    productRedirectUrl?: string | null
    isSignature?: boolean
  }

  export type ClosureProductCategoryUpdateWithoutAncestorCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    DescendantCategory?: ProductCategoryUpdateOneRequiredWithoutDescendantCategoriesNestedInput
  }

  export type ClosureProductCategoryUncheckedUpdateWithoutAncestorCategoryInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutAncestorCategoryInput = {
    descendant?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUpdateWithoutDescendantCategoryInput = {
    depth?: IntFieldUpdateOperationsInput | number
    AncestorCategory?: ProductCategoryUpdateOneRequiredWithoutAncestorCategoriesNestedInput
  }

  export type ClosureProductCategoryUncheckedUpdateWithoutDescendantCategoryInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ClosureProductCategoryUncheckedUpdateManyWithoutDescendantCategoryInput = {
    ancestor?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    CafeInfo?: CafeInfoUpdateOneWithoutProductsNestedInput
    WishlistProducts?: WishlistProductUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
    WishlistProducts?: WishlistProductUncheckedUpdateManyWithoutProductNestedInput
    ProductImages?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    cafeInfoId?: NullableIntFieldUpdateOperationsInput | number | null
    productRedirectUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignature?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WishlistProductCreateManyProductInput = {
    id?: number
    createdAt?: Date | string
    proxyUserId: number
  }

  export type ProductImageCreateManyProductInput = {
    id?: number
    createdAt?: Date | string
    url: string
    thumbnailUrl: string
    width: number
    height: number
    size: number
    isDisable?: boolean
    isThumb?: boolean
  }

  export type WishlistProductUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProxyUser?: ProxyUserUpdateOneRequiredWithoutWishlistProductsNestedInput
  }

  export type WishlistProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistProductUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyUserId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductImageUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    isDisable?: BoolFieldUpdateOperationsInput | boolean
    isThumb?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}